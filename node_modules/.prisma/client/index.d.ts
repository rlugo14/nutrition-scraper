
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/index';
declare const prisma: unique symbol
export type PrismaPromise<A> = Promise<A> & {[prisma]: true}
type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};


/**
 * Model Resource
 * 
 */
export type Resource = {
  id: number
  displayName: string
  slug: string
}

/**
 * Model Label
 * 
 */
export type Label = {
  id: number
  name: string
}

/**
 * Model Fat
 * 
 */
export type Fat = {
  id: number
  totalFatId: number
  saturatedFatId: number | null
  monosaturatedFatId: number | null
  polyunsaturatedFatId: number | null
  transFatId: number | null
}

/**
 * Model TotalFat
 * 
 */
export type TotalFat = {
  id: number
  measurementId: number
}

/**
 * Model SaturatedFat
 * 
 */
export type SaturatedFat = {
  id: number
  measurementId: number
}

/**
 * Model MonosaturatedFat
 * 
 */
export type MonosaturatedFat = {
  id: number
  measurementId: number
}

/**
 * Model PolyunsaturatedFat
 * 
 */
export type PolyunsaturatedFat = {
  id: number
  measurementId: number
}

/**
 * Model TransFat
 * 
 */
export type TransFat = {
  id: number
  measurementId: number
}

/**
 * Model Carbohydrate
 * 
 */
export type Carbohydrate = {
  id: number
  totalCarbohydrateId: number | null
  sugarCarbohydrateId: number | null
}

/**
 * Model TotalCarbohydrate
 * 
 */
export type TotalCarbohydrate = {
  id: number
  measurementId: number
}

/**
 * Model SugarCarbohydrate
 * 
 */
export type SugarCarbohydrate = {
  id: number
  measurementId: number
}

/**
 * Model Vitamin
 * 
 */
export type Vitamin = {
  id: number
  vitaminCId: number | null
  vitaminAId: number | null
  vitaminDId: number | null
  vitaminEId: number | null
  vitaminB1Id: number | null
  vitaminB2Id: number | null
  vitaminB6Id: number | null
  vitaminB12Id: number | null
}

/**
 * Model VitaminC
 * 
 */
export type VitaminC = {
  id: number
  measurementId: number
}

/**
 * Model VitaminA
 * 
 */
export type VitaminA = {
  id: number
  measurementId: number
}

/**
 * Model VitaminD
 * 
 */
export type VitaminD = {
  id: number
  measurementId: number
}

/**
 * Model VitaminE
 * 
 */
export type VitaminE = {
  id: number
  measurementId: number
}

/**
 * Model VitaminB1
 * 
 */
export type VitaminB1 = {
  id: number
  measurementId: number
}

/**
 * Model VitaminB2
 * 
 */
export type VitaminB2 = {
  id: number
  measurementId: number
}

/**
 * Model VitaminB6
 * 
 */
export type VitaminB6 = {
  id: number
  measurementId: number
}

/**
 * Model VitaminB12
 * 
 */
export type VitaminB12 = {
  id: number
  measurementId: number
}

/**
 * Model Salt
 * 
 */
export type Salt = {
  id: number
  measurementId: number
}

/**
 * Model Zinc
 * 
 */
export type Zinc = {
  id: number
  measurementId: number
}

/**
 * Model Iron
 * 
 */
export type Iron = {
  id: number
  measurementId: number
}

/**
 * Model Magnesium
 * 
 */
export type Magnesium = {
  id: number
  measurementId: number
}

/**
 * Model Chloride
 * 
 */
export type Chloride = {
  id: number
  measurementId: number
}

/**
 * Model Manganese
 * 
 */
export type Manganese = {
  id: number
  measurementId: number
}

/**
 * Model Sulfur
 * 
 */
export type Sulfur = {
  id: number
  measurementId: number
}

/**
 * Model Potassium
 * 
 */
export type Potassium = {
  id: number
  measurementId: number
}

/**
 * Model Fluoride
 * 
 */
export type Fluoride = {
  id: number
  measurementId: number
}

/**
 * Model Phosphorous
 * 
 */
export type Phosphorous = {
  id: number
  measurementId: number
}

/**
 * Model Copper
 * 
 */
export type Copper = {
  id: number
  measurementId: number
}

/**
 * Model Iodine
 * 
 */
export type Iodine = {
  id: number
  measurementId: number
}

/**
 * Model Calcium
 * 
 */
export type Calcium = {
  id: number
  measurementId: number
}

/**
 * Model Mineral
 * 
 */
export type Mineral = {
  id: number
  saltId: number | null
  ironId: number | null
  zincId: number | null
  magnesiumId: number | null
  chlorideId: number | null
  manganeseId: number | null
  sulfurId: number | null
  potassiumId: number | null
  fluorideId: number | null
  phosphorousId: number | null
  copperId: number | null
  iodineId: number | null
  calciumId: number | null
}

/**
 * Model Unit
 * 
 */
export type Unit = {
  id: number
  name: string
  abbreviation: string
}

/**
 * Model Measurement
 * 
 */
export type Measurement = {
  id: number
  value: Prisma.Decimal | null
  unitId: number
  proteinId: number | null
  cholesterolId: number | null
  fiberId: number | null
  waterId: number | null
}

/**
 * Model Serving
 * 
 */
export type Serving = {
  id: number
  name: string
  measurementId: number
}

/**
 * Model Energy
 * 
 */
export type Energy = {
  id: number
  nutritionFactId: number
}

/**
 * Model Protein
 * 
 */
export type Protein = {
  id: number
}

/**
 * Model Cholesterol
 * 
 */
export type Cholesterol = {
  id: number
}

/**
 * Model Fiber
 * 
 */
export type Fiber = {
  id: number
}

/**
 * Model Water
 * 
 */
export type Water = {
  id: number
}

/**
 * Model NutritionFact
 * 
 */
export type NutritionFact = {
  id: number
  proteinId: number | null
  fatId: number | null
  carbohydrateId: number | null
  fiberId: number | null
  vitaminId: number | null
  mineralId: number | null
  cholesterolId: number | null
  waterId: number | null
  productId: number | null
}

/**
 * Model Product
 * 
 */
export type Product = {
  id: number
  name: string
  ean: string | null
  manufacturer: string
  group: string
  servingId: number
  nutritionFactId: number | null
}


/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Resources
 * const resources = await prisma.resource.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
      /**
       * @private
       */
      private fetcher;
      /**
       * @private
       */
      private readonly dmmf;
      /**
       * @private
       */
      private connectionPromise?;
      /**
       * @private
       */
      private disconnectionPromise?;
      /**
       * @private
       */
      private readonly engineConfig;
      /**
       * @private
       */
      private readonly measurePerformance;

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Resources
   * const resources = await prisma.resource.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends PrismaPromise<any>[]>(arg: [...P]): Promise<UnwrapTuple<P>>;

      /**
   * `prisma.resource`: Exposes CRUD operations for the **Resource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Resources
    * const resources = await prisma.resource.findMany()
    * ```
    */
  get resource(): Prisma.ResourceDelegate<GlobalReject>;

  /**
   * `prisma.label`: Exposes CRUD operations for the **Label** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Labels
    * const labels = await prisma.label.findMany()
    * ```
    */
  get label(): Prisma.LabelDelegate<GlobalReject>;

  /**
   * `prisma.fat`: Exposes CRUD operations for the **Fat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fats
    * const fats = await prisma.fat.findMany()
    * ```
    */
  get fat(): Prisma.FatDelegate<GlobalReject>;

  /**
   * `prisma.totalFat`: Exposes CRUD operations for the **TotalFat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TotalFats
    * const totalFats = await prisma.totalFat.findMany()
    * ```
    */
  get totalFat(): Prisma.TotalFatDelegate<GlobalReject>;

  /**
   * `prisma.saturatedFat`: Exposes CRUD operations for the **SaturatedFat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SaturatedFats
    * const saturatedFats = await prisma.saturatedFat.findMany()
    * ```
    */
  get saturatedFat(): Prisma.SaturatedFatDelegate<GlobalReject>;

  /**
   * `prisma.monosaturatedFat`: Exposes CRUD operations for the **MonosaturatedFat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MonosaturatedFats
    * const monosaturatedFats = await prisma.monosaturatedFat.findMany()
    * ```
    */
  get monosaturatedFat(): Prisma.MonosaturatedFatDelegate<GlobalReject>;

  /**
   * `prisma.polyunsaturatedFat`: Exposes CRUD operations for the **PolyunsaturatedFat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PolyunsaturatedFats
    * const polyunsaturatedFats = await prisma.polyunsaturatedFat.findMany()
    * ```
    */
  get polyunsaturatedFat(): Prisma.PolyunsaturatedFatDelegate<GlobalReject>;

  /**
   * `prisma.transFat`: Exposes CRUD operations for the **TransFat** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TransFats
    * const transFats = await prisma.transFat.findMany()
    * ```
    */
  get transFat(): Prisma.TransFatDelegate<GlobalReject>;

  /**
   * `prisma.carbohydrate`: Exposes CRUD operations for the **Carbohydrate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Carbohydrates
    * const carbohydrates = await prisma.carbohydrate.findMany()
    * ```
    */
  get carbohydrate(): Prisma.CarbohydrateDelegate<GlobalReject>;

  /**
   * `prisma.totalCarbohydrate`: Exposes CRUD operations for the **TotalCarbohydrate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TotalCarbohydrates
    * const totalCarbohydrates = await prisma.totalCarbohydrate.findMany()
    * ```
    */
  get totalCarbohydrate(): Prisma.TotalCarbohydrateDelegate<GlobalReject>;

  /**
   * `prisma.sugarCarbohydrate`: Exposes CRUD operations for the **SugarCarbohydrate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SugarCarbohydrates
    * const sugarCarbohydrates = await prisma.sugarCarbohydrate.findMany()
    * ```
    */
  get sugarCarbohydrate(): Prisma.SugarCarbohydrateDelegate<GlobalReject>;

  /**
   * `prisma.vitamin`: Exposes CRUD operations for the **Vitamin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vitamins
    * const vitamins = await prisma.vitamin.findMany()
    * ```
    */
  get vitamin(): Prisma.VitaminDelegate<GlobalReject>;

  /**
   * `prisma.vitaminC`: Exposes CRUD operations for the **VitaminC** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VitaminCS
    * const vitaminCS = await prisma.vitaminC.findMany()
    * ```
    */
  get vitaminC(): Prisma.VitaminCDelegate<GlobalReject>;

  /**
   * `prisma.vitaminA`: Exposes CRUD operations for the **VitaminA** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VitaminAS
    * const vitaminAS = await prisma.vitaminA.findMany()
    * ```
    */
  get vitaminA(): Prisma.VitaminADelegate<GlobalReject>;

  /**
   * `prisma.vitaminD`: Exposes CRUD operations for the **VitaminD** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VitaminDS
    * const vitaminDS = await prisma.vitaminD.findMany()
    * ```
    */
  get vitaminD(): Prisma.VitaminDDelegate<GlobalReject>;

  /**
   * `prisma.vitaminE`: Exposes CRUD operations for the **VitaminE** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VitaminES
    * const vitaminES = await prisma.vitaminE.findMany()
    * ```
    */
  get vitaminE(): Prisma.VitaminEDelegate<GlobalReject>;

  /**
   * `prisma.vitaminB1`: Exposes CRUD operations for the **VitaminB1** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VitaminB1s
    * const vitaminB1s = await prisma.vitaminB1.findMany()
    * ```
    */
  get vitaminB1(): Prisma.VitaminB1Delegate<GlobalReject>;

  /**
   * `prisma.vitaminB2`: Exposes CRUD operations for the **VitaminB2** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VitaminB2s
    * const vitaminB2s = await prisma.vitaminB2.findMany()
    * ```
    */
  get vitaminB2(): Prisma.VitaminB2Delegate<GlobalReject>;

  /**
   * `prisma.vitaminB6`: Exposes CRUD operations for the **VitaminB6** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VitaminB6s
    * const vitaminB6s = await prisma.vitaminB6.findMany()
    * ```
    */
  get vitaminB6(): Prisma.VitaminB6Delegate<GlobalReject>;

  /**
   * `prisma.vitaminB12`: Exposes CRUD operations for the **VitaminB12** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VitaminB12s
    * const vitaminB12s = await prisma.vitaminB12.findMany()
    * ```
    */
  get vitaminB12(): Prisma.VitaminB12Delegate<GlobalReject>;

  /**
   * `prisma.salt`: Exposes CRUD operations for the **Salt** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Salts
    * const salts = await prisma.salt.findMany()
    * ```
    */
  get salt(): Prisma.SaltDelegate<GlobalReject>;

  /**
   * `prisma.zinc`: Exposes CRUD operations for the **Zinc** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Zincs
    * const zincs = await prisma.zinc.findMany()
    * ```
    */
  get zinc(): Prisma.ZincDelegate<GlobalReject>;

  /**
   * `prisma.iron`: Exposes CRUD operations for the **Iron** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Irons
    * const irons = await prisma.iron.findMany()
    * ```
    */
  get iron(): Prisma.IronDelegate<GlobalReject>;

  /**
   * `prisma.magnesium`: Exposes CRUD operations for the **Magnesium** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Magnesiums
    * const magnesiums = await prisma.magnesium.findMany()
    * ```
    */
  get magnesium(): Prisma.MagnesiumDelegate<GlobalReject>;

  /**
   * `prisma.chloride`: Exposes CRUD operations for the **Chloride** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Chlorides
    * const chlorides = await prisma.chloride.findMany()
    * ```
    */
  get chloride(): Prisma.ChlorideDelegate<GlobalReject>;

  /**
   * `prisma.manganese`: Exposes CRUD operations for the **Manganese** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Manganese
    * const manganese = await prisma.manganese.findMany()
    * ```
    */
  get manganese(): Prisma.ManganeseDelegate<GlobalReject>;

  /**
   * `prisma.sulfur`: Exposes CRUD operations for the **Sulfur** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sulfurs
    * const sulfurs = await prisma.sulfur.findMany()
    * ```
    */
  get sulfur(): Prisma.SulfurDelegate<GlobalReject>;

  /**
   * `prisma.potassium`: Exposes CRUD operations for the **Potassium** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Potassiums
    * const potassiums = await prisma.potassium.findMany()
    * ```
    */
  get potassium(): Prisma.PotassiumDelegate<GlobalReject>;

  /**
   * `prisma.fluoride`: Exposes CRUD operations for the **Fluoride** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fluorides
    * const fluorides = await prisma.fluoride.findMany()
    * ```
    */
  get fluoride(): Prisma.FluorideDelegate<GlobalReject>;

  /**
   * `prisma.phosphorous`: Exposes CRUD operations for the **Phosphorous** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Phosphorous
    * const phosphorous = await prisma.phosphorous.findMany()
    * ```
    */
  get phosphorous(): Prisma.PhosphorousDelegate<GlobalReject>;

  /**
   * `prisma.copper`: Exposes CRUD operations for the **Copper** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Coppers
    * const coppers = await prisma.copper.findMany()
    * ```
    */
  get copper(): Prisma.CopperDelegate<GlobalReject>;

  /**
   * `prisma.iodine`: Exposes CRUD operations for the **Iodine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Iodines
    * const iodines = await prisma.iodine.findMany()
    * ```
    */
  get iodine(): Prisma.IodineDelegate<GlobalReject>;

  /**
   * `prisma.calcium`: Exposes CRUD operations for the **Calcium** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Calciums
    * const calciums = await prisma.calcium.findMany()
    * ```
    */
  get calcium(): Prisma.CalciumDelegate<GlobalReject>;

  /**
   * `prisma.mineral`: Exposes CRUD operations for the **Mineral** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Minerals
    * const minerals = await prisma.mineral.findMany()
    * ```
    */
  get mineral(): Prisma.MineralDelegate<GlobalReject>;

  /**
   * `prisma.unit`: Exposes CRUD operations for the **Unit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Units
    * const units = await prisma.unit.findMany()
    * ```
    */
  get unit(): Prisma.UnitDelegate<GlobalReject>;

  /**
   * `prisma.measurement`: Exposes CRUD operations for the **Measurement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Measurements
    * const measurements = await prisma.measurement.findMany()
    * ```
    */
  get measurement(): Prisma.MeasurementDelegate<GlobalReject>;

  /**
   * `prisma.serving`: Exposes CRUD operations for the **Serving** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Servings
    * const servings = await prisma.serving.findMany()
    * ```
    */
  get serving(): Prisma.ServingDelegate<GlobalReject>;

  /**
   * `prisma.energy`: Exposes CRUD operations for the **Energy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Energy
    * const energy = await prisma.energy.findMany()
    * ```
    */
  get energy(): Prisma.EnergyDelegate<GlobalReject>;

  /**
   * `prisma.protein`: Exposes CRUD operations for the **Protein** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Proteins
    * const proteins = await prisma.protein.findMany()
    * ```
    */
  get protein(): Prisma.ProteinDelegate<GlobalReject>;

  /**
   * `prisma.cholesterol`: Exposes CRUD operations for the **Cholesterol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cholesterols
    * const cholesterols = await prisma.cholesterol.findMany()
    * ```
    */
  get cholesterol(): Prisma.CholesterolDelegate<GlobalReject>;

  /**
   * `prisma.fiber`: Exposes CRUD operations for the **Fiber** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fibers
    * const fibers = await prisma.fiber.findMany()
    * ```
    */
  get fiber(): Prisma.FiberDelegate<GlobalReject>;

  /**
   * `prisma.water`: Exposes CRUD operations for the **Water** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Waters
    * const waters = await prisma.water.findMany()
    * ```
    */
  get water(): Prisma.WaterDelegate<GlobalReject>;

  /**
   * `prisma.nutritionFact`: Exposes CRUD operations for the **NutritionFact** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more NutritionFacts
    * const nutritionFacts = await prisma.nutritionFact.findMany()
    * ```
    */
  get nutritionFact(): Prisma.NutritionFactDelegate<GlobalReject>;

  /**
   * `prisma.product`: Exposes CRUD operations for the **Product** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Products
    * const products = await prisma.product.findMany()
    * ```
    */
  get product(): Prisma.ProductDelegate<GlobalReject>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  /**
   * Prisma Client JS version: 3.10.0
   * Query Engine version: 73e60b76d394f8d37d8ebd1f8918c79029f0db86
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: 'DbNull'

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: 'JsonNull'

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: 'AnyNull'

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = {
    [key in keyof T]: T[key] extends false | undefined | null ? never : key
  }[keyof T]

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Buffer
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Exact<A, W = unknown> = 
  W extends unknown ? A extends Narrowable ? Cast<A, W> : Cast<
  {[K in keyof A]: K extends keyof W ? Exact<A[K], W[K]> : never},
  {[K in keyof W]: K extends keyof A ? Exact<A[K], W[K]> : W[K]}>
  : never;

  type Narrowable = string | number | boolean | bigint;

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: Exact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T

  class PrismaClientFetcher {
    private readonly prisma;
    private readonly debug;
    private readonly hooks?;
    constructor(prisma: PrismaClient<any, any>, debug?: boolean, hooks?: Hooks | undefined);
    request<T>(document: any, dataPath?: string[], rootField?: string, typeName?: string, isList?: boolean, callsite?: string): Promise<T>;
    sanitizeMessage(message: string): string;
    protected unpack(document: any, data: any, path: string[], rootField?: string, isList?: boolean): any;
  }

  export const ModelName: {
    Resource: 'Resource',
    Label: 'Label',
    Fat: 'Fat',
    TotalFat: 'TotalFat',
    SaturatedFat: 'SaturatedFat',
    MonosaturatedFat: 'MonosaturatedFat',
    PolyunsaturatedFat: 'PolyunsaturatedFat',
    TransFat: 'TransFat',
    Carbohydrate: 'Carbohydrate',
    TotalCarbohydrate: 'TotalCarbohydrate',
    SugarCarbohydrate: 'SugarCarbohydrate',
    Vitamin: 'Vitamin',
    VitaminC: 'VitaminC',
    VitaminA: 'VitaminA',
    VitaminD: 'VitaminD',
    VitaminE: 'VitaminE',
    VitaminB1: 'VitaminB1',
    VitaminB2: 'VitaminB2',
    VitaminB6: 'VitaminB6',
    VitaminB12: 'VitaminB12',
    Salt: 'Salt',
    Zinc: 'Zinc',
    Iron: 'Iron',
    Magnesium: 'Magnesium',
    Chloride: 'Chloride',
    Manganese: 'Manganese',
    Sulfur: 'Sulfur',
    Potassium: 'Potassium',
    Fluoride: 'Fluoride',
    Phosphorous: 'Phosphorous',
    Copper: 'Copper',
    Iodine: 'Iodine',
    Calcium: 'Calcium',
    Mineral: 'Mineral',
    Unit: 'Unit',
    Measurement: 'Measurement',
    Serving: 'Serving',
    Energy: 'Energy',
    Protein: 'Protein',
    Cholesterol: 'Cholesterol',
    Fiber: 'Fiber',
    Water: 'Water',
    NutritionFact: 'NutritionFact',
    Product: 'Product'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends boolean
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     *  * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your prisma.schema file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  export type Hooks = {
    beforeRequest?: (options: { query: string, path: string[], rootField?: string, typeName?: string, document: any }) => any
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'

  /**
   * These options are being passed in to the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined; 
  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type LabelCountOutputType
   */


  export type LabelCountOutputType = {
    products: number
  }

  export type LabelCountOutputTypeSelect = {
    products?: boolean
  }

  export type LabelCountOutputTypeGetPayload<
    S extends boolean | null | undefined | LabelCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? LabelCountOutputType
    : S extends undefined
    ? never
    : S extends LabelCountOutputTypeArgs
    ?'include' extends U
    ? LabelCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof LabelCountOutputType ? LabelCountOutputType[P] : never
  } 
    : LabelCountOutputType
  : LabelCountOutputType




  // Custom InputTypes

  /**
   * LabelCountOutputType without action
   */
  export type LabelCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the LabelCountOutputType
     * 
    **/
    select?: LabelCountOutputTypeSelect | null
  }



  /**
   * Count Type FatCountOutputType
   */


  export type FatCountOutputType = {
    nutritionFacts: number
  }

  export type FatCountOutputTypeSelect = {
    nutritionFacts?: boolean
  }

  export type FatCountOutputTypeGetPayload<
    S extends boolean | null | undefined | FatCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? FatCountOutputType
    : S extends undefined
    ? never
    : S extends FatCountOutputTypeArgs
    ?'include' extends U
    ? FatCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof FatCountOutputType ? FatCountOutputType[P] : never
  } 
    : FatCountOutputType
  : FatCountOutputType




  // Custom InputTypes

  /**
   * FatCountOutputType without action
   */
  export type FatCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FatCountOutputType
     * 
    **/
    select?: FatCountOutputTypeSelect | null
  }



  /**
   * Count Type CarbohydrateCountOutputType
   */


  export type CarbohydrateCountOutputType = {
    nutritionFacts: number
  }

  export type CarbohydrateCountOutputTypeSelect = {
    nutritionFacts?: boolean
  }

  export type CarbohydrateCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CarbohydrateCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CarbohydrateCountOutputType
    : S extends undefined
    ? never
    : S extends CarbohydrateCountOutputTypeArgs
    ?'include' extends U
    ? CarbohydrateCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CarbohydrateCountOutputType ? CarbohydrateCountOutputType[P] : never
  } 
    : CarbohydrateCountOutputType
  : CarbohydrateCountOutputType




  // Custom InputTypes

  /**
   * CarbohydrateCountOutputType without action
   */
  export type CarbohydrateCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CarbohydrateCountOutputType
     * 
    **/
    select?: CarbohydrateCountOutputTypeSelect | null
  }



  /**
   * Count Type VitaminCountOutputType
   */


  export type VitaminCountOutputType = {
    nutritionFacts: number
    measurements: number
  }

  export type VitaminCountOutputTypeSelect = {
    nutritionFacts?: boolean
    measurements?: boolean
  }

  export type VitaminCountOutputTypeGetPayload<
    S extends boolean | null | undefined | VitaminCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? VitaminCountOutputType
    : S extends undefined
    ? never
    : S extends VitaminCountOutputTypeArgs
    ?'include' extends U
    ? VitaminCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof VitaminCountOutputType ? VitaminCountOutputType[P] : never
  } 
    : VitaminCountOutputType
  : VitaminCountOutputType




  // Custom InputTypes

  /**
   * VitaminCountOutputType without action
   */
  export type VitaminCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the VitaminCountOutputType
     * 
    **/
    select?: VitaminCountOutputTypeSelect | null
  }



  /**
   * Count Type SaltCountOutputType
   */


  export type SaltCountOutputType = {
    minerals: number
  }

  export type SaltCountOutputTypeSelect = {
    minerals?: boolean
  }

  export type SaltCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SaltCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SaltCountOutputType
    : S extends undefined
    ? never
    : S extends SaltCountOutputTypeArgs
    ?'include' extends U
    ? SaltCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SaltCountOutputType ? SaltCountOutputType[P] : never
  } 
    : SaltCountOutputType
  : SaltCountOutputType




  // Custom InputTypes

  /**
   * SaltCountOutputType without action
   */
  export type SaltCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SaltCountOutputType
     * 
    **/
    select?: SaltCountOutputTypeSelect | null
  }



  /**
   * Count Type ZincCountOutputType
   */


  export type ZincCountOutputType = {
    minerals: number
  }

  export type ZincCountOutputTypeSelect = {
    minerals?: boolean
  }

  export type ZincCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ZincCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ZincCountOutputType
    : S extends undefined
    ? never
    : S extends ZincCountOutputTypeArgs
    ?'include' extends U
    ? ZincCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ZincCountOutputType ? ZincCountOutputType[P] : never
  } 
    : ZincCountOutputType
  : ZincCountOutputType




  // Custom InputTypes

  /**
   * ZincCountOutputType without action
   */
  export type ZincCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ZincCountOutputType
     * 
    **/
    select?: ZincCountOutputTypeSelect | null
  }



  /**
   * Count Type IronCountOutputType
   */


  export type IronCountOutputType = {
    minerals: number
  }

  export type IronCountOutputTypeSelect = {
    minerals?: boolean
  }

  export type IronCountOutputTypeGetPayload<
    S extends boolean | null | undefined | IronCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? IronCountOutputType
    : S extends undefined
    ? never
    : S extends IronCountOutputTypeArgs
    ?'include' extends U
    ? IronCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof IronCountOutputType ? IronCountOutputType[P] : never
  } 
    : IronCountOutputType
  : IronCountOutputType




  // Custom InputTypes

  /**
   * IronCountOutputType without action
   */
  export type IronCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the IronCountOutputType
     * 
    **/
    select?: IronCountOutputTypeSelect | null
  }



  /**
   * Count Type MagnesiumCountOutputType
   */


  export type MagnesiumCountOutputType = {
    minerals: number
  }

  export type MagnesiumCountOutputTypeSelect = {
    minerals?: boolean
  }

  export type MagnesiumCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MagnesiumCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MagnesiumCountOutputType
    : S extends undefined
    ? never
    : S extends MagnesiumCountOutputTypeArgs
    ?'include' extends U
    ? MagnesiumCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof MagnesiumCountOutputType ? MagnesiumCountOutputType[P] : never
  } 
    : MagnesiumCountOutputType
  : MagnesiumCountOutputType




  // Custom InputTypes

  /**
   * MagnesiumCountOutputType without action
   */
  export type MagnesiumCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MagnesiumCountOutputType
     * 
    **/
    select?: MagnesiumCountOutputTypeSelect | null
  }



  /**
   * Count Type ChlorideCountOutputType
   */


  export type ChlorideCountOutputType = {
    minerals: number
  }

  export type ChlorideCountOutputTypeSelect = {
    minerals?: boolean
  }

  export type ChlorideCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ChlorideCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ChlorideCountOutputType
    : S extends undefined
    ? never
    : S extends ChlorideCountOutputTypeArgs
    ?'include' extends U
    ? ChlorideCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ChlorideCountOutputType ? ChlorideCountOutputType[P] : never
  } 
    : ChlorideCountOutputType
  : ChlorideCountOutputType




  // Custom InputTypes

  /**
   * ChlorideCountOutputType without action
   */
  export type ChlorideCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ChlorideCountOutputType
     * 
    **/
    select?: ChlorideCountOutputTypeSelect | null
  }



  /**
   * Count Type ManganeseCountOutputType
   */


  export type ManganeseCountOutputType = {
    minerals: number
  }

  export type ManganeseCountOutputTypeSelect = {
    minerals?: boolean
  }

  export type ManganeseCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ManganeseCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ManganeseCountOutputType
    : S extends undefined
    ? never
    : S extends ManganeseCountOutputTypeArgs
    ?'include' extends U
    ? ManganeseCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ManganeseCountOutputType ? ManganeseCountOutputType[P] : never
  } 
    : ManganeseCountOutputType
  : ManganeseCountOutputType




  // Custom InputTypes

  /**
   * ManganeseCountOutputType without action
   */
  export type ManganeseCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ManganeseCountOutputType
     * 
    **/
    select?: ManganeseCountOutputTypeSelect | null
  }



  /**
   * Count Type SulfurCountOutputType
   */


  export type SulfurCountOutputType = {
    minerals: number
  }

  export type SulfurCountOutputTypeSelect = {
    minerals?: boolean
  }

  export type SulfurCountOutputTypeGetPayload<
    S extends boolean | null | undefined | SulfurCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? SulfurCountOutputType
    : S extends undefined
    ? never
    : S extends SulfurCountOutputTypeArgs
    ?'include' extends U
    ? SulfurCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof SulfurCountOutputType ? SulfurCountOutputType[P] : never
  } 
    : SulfurCountOutputType
  : SulfurCountOutputType




  // Custom InputTypes

  /**
   * SulfurCountOutputType without action
   */
  export type SulfurCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SulfurCountOutputType
     * 
    **/
    select?: SulfurCountOutputTypeSelect | null
  }



  /**
   * Count Type PotassiumCountOutputType
   */


  export type PotassiumCountOutputType = {
    minerals: number
  }

  export type PotassiumCountOutputTypeSelect = {
    minerals?: boolean
  }

  export type PotassiumCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PotassiumCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PotassiumCountOutputType
    : S extends undefined
    ? never
    : S extends PotassiumCountOutputTypeArgs
    ?'include' extends U
    ? PotassiumCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PotassiumCountOutputType ? PotassiumCountOutputType[P] : never
  } 
    : PotassiumCountOutputType
  : PotassiumCountOutputType




  // Custom InputTypes

  /**
   * PotassiumCountOutputType without action
   */
  export type PotassiumCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PotassiumCountOutputType
     * 
    **/
    select?: PotassiumCountOutputTypeSelect | null
  }



  /**
   * Count Type FluorideCountOutputType
   */


  export type FluorideCountOutputType = {
    minerals: number
  }

  export type FluorideCountOutputTypeSelect = {
    minerals?: boolean
  }

  export type FluorideCountOutputTypeGetPayload<
    S extends boolean | null | undefined | FluorideCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? FluorideCountOutputType
    : S extends undefined
    ? never
    : S extends FluorideCountOutputTypeArgs
    ?'include' extends U
    ? FluorideCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof FluorideCountOutputType ? FluorideCountOutputType[P] : never
  } 
    : FluorideCountOutputType
  : FluorideCountOutputType




  // Custom InputTypes

  /**
   * FluorideCountOutputType without action
   */
  export type FluorideCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FluorideCountOutputType
     * 
    **/
    select?: FluorideCountOutputTypeSelect | null
  }



  /**
   * Count Type PhosphorousCountOutputType
   */


  export type PhosphorousCountOutputType = {
    minerals: number
  }

  export type PhosphorousCountOutputTypeSelect = {
    minerals?: boolean
  }

  export type PhosphorousCountOutputTypeGetPayload<
    S extends boolean | null | undefined | PhosphorousCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? PhosphorousCountOutputType
    : S extends undefined
    ? never
    : S extends PhosphorousCountOutputTypeArgs
    ?'include' extends U
    ? PhosphorousCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof PhosphorousCountOutputType ? PhosphorousCountOutputType[P] : never
  } 
    : PhosphorousCountOutputType
  : PhosphorousCountOutputType




  // Custom InputTypes

  /**
   * PhosphorousCountOutputType without action
   */
  export type PhosphorousCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the PhosphorousCountOutputType
     * 
    **/
    select?: PhosphorousCountOutputTypeSelect | null
  }



  /**
   * Count Type CopperCountOutputType
   */


  export type CopperCountOutputType = {
    minerals: number
  }

  export type CopperCountOutputTypeSelect = {
    minerals?: boolean
  }

  export type CopperCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CopperCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CopperCountOutputType
    : S extends undefined
    ? never
    : S extends CopperCountOutputTypeArgs
    ?'include' extends U
    ? CopperCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CopperCountOutputType ? CopperCountOutputType[P] : never
  } 
    : CopperCountOutputType
  : CopperCountOutputType




  // Custom InputTypes

  /**
   * CopperCountOutputType without action
   */
  export type CopperCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CopperCountOutputType
     * 
    **/
    select?: CopperCountOutputTypeSelect | null
  }



  /**
   * Count Type IodineCountOutputType
   */


  export type IodineCountOutputType = {
    minerals: number
  }

  export type IodineCountOutputTypeSelect = {
    minerals?: boolean
  }

  export type IodineCountOutputTypeGetPayload<
    S extends boolean | null | undefined | IodineCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? IodineCountOutputType
    : S extends undefined
    ? never
    : S extends IodineCountOutputTypeArgs
    ?'include' extends U
    ? IodineCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof IodineCountOutputType ? IodineCountOutputType[P] : never
  } 
    : IodineCountOutputType
  : IodineCountOutputType




  // Custom InputTypes

  /**
   * IodineCountOutputType without action
   */
  export type IodineCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the IodineCountOutputType
     * 
    **/
    select?: IodineCountOutputTypeSelect | null
  }



  /**
   * Count Type CalciumCountOutputType
   */


  export type CalciumCountOutputType = {
    minerals: number
  }

  export type CalciumCountOutputTypeSelect = {
    minerals?: boolean
  }

  export type CalciumCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CalciumCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CalciumCountOutputType
    : S extends undefined
    ? never
    : S extends CalciumCountOutputTypeArgs
    ?'include' extends U
    ? CalciumCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CalciumCountOutputType ? CalciumCountOutputType[P] : never
  } 
    : CalciumCountOutputType
  : CalciumCountOutputType




  // Custom InputTypes

  /**
   * CalciumCountOutputType without action
   */
  export type CalciumCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CalciumCountOutputType
     * 
    **/
    select?: CalciumCountOutputTypeSelect | null
  }



  /**
   * Count Type MineralCountOutputType
   */


  export type MineralCountOutputType = {
    nutritionFact: number
  }

  export type MineralCountOutputTypeSelect = {
    nutritionFact?: boolean
  }

  export type MineralCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MineralCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MineralCountOutputType
    : S extends undefined
    ? never
    : S extends MineralCountOutputTypeArgs
    ?'include' extends U
    ? MineralCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof MineralCountOutputType ? MineralCountOutputType[P] : never
  } 
    : MineralCountOutputType
  : MineralCountOutputType




  // Custom InputTypes

  /**
   * MineralCountOutputType without action
   */
  export type MineralCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MineralCountOutputType
     * 
    **/
    select?: MineralCountOutputTypeSelect | null
  }



  /**
   * Count Type UnitCountOutputType
   */


  export type UnitCountOutputType = {
    measurements: number
  }

  export type UnitCountOutputTypeSelect = {
    measurements?: boolean
  }

  export type UnitCountOutputTypeGetPayload<
    S extends boolean | null | undefined | UnitCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? UnitCountOutputType
    : S extends undefined
    ? never
    : S extends UnitCountOutputTypeArgs
    ?'include' extends U
    ? UnitCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof UnitCountOutputType ? UnitCountOutputType[P] : never
  } 
    : UnitCountOutputType
  : UnitCountOutputType




  // Custom InputTypes

  /**
   * UnitCountOutputType without action
   */
  export type UnitCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UnitCountOutputType
     * 
    **/
    select?: UnitCountOutputTypeSelect | null
  }



  /**
   * Count Type MeasurementCountOutputType
   */


  export type MeasurementCountOutputType = {
    servings: number
    vitamin: number
    salt: number
    zinc: number
    iron: number
    magnesium: number
    chloride: number
    manganese: number
    sulfur: number
    potassium: number
    fluoride: number
    phosphorous: number
    copper: number
    iodine: number
    calcium: number
    totalFat: number
    saturatedFat: number
    monosaturatedFat: number
    polyunsaturatedFat: number
    transFat: number
    totalCarbohydrate: number
    sugarCarbohydrate: number
    vitaminC: number
    vitaminA: number
    vitaminD: number
    vitaminE: number
    vitaminB1: number
    vitaminB2: number
    vitaminB6: number
    vitaminB12: number
    energy: number
  }

  export type MeasurementCountOutputTypeSelect = {
    servings?: boolean
    vitamin?: boolean
    salt?: boolean
    zinc?: boolean
    iron?: boolean
    magnesium?: boolean
    chloride?: boolean
    manganese?: boolean
    sulfur?: boolean
    potassium?: boolean
    fluoride?: boolean
    phosphorous?: boolean
    copper?: boolean
    iodine?: boolean
    calcium?: boolean
    totalFat?: boolean
    saturatedFat?: boolean
    monosaturatedFat?: boolean
    polyunsaturatedFat?: boolean
    transFat?: boolean
    totalCarbohydrate?: boolean
    sugarCarbohydrate?: boolean
    vitaminC?: boolean
    vitaminA?: boolean
    vitaminD?: boolean
    vitaminE?: boolean
    vitaminB1?: boolean
    vitaminB2?: boolean
    vitaminB6?: boolean
    vitaminB12?: boolean
    energy?: boolean
  }

  export type MeasurementCountOutputTypeGetPayload<
    S extends boolean | null | undefined | MeasurementCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? MeasurementCountOutputType
    : S extends undefined
    ? never
    : S extends MeasurementCountOutputTypeArgs
    ?'include' extends U
    ? MeasurementCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof MeasurementCountOutputType ? MeasurementCountOutputType[P] : never
  } 
    : MeasurementCountOutputType
  : MeasurementCountOutputType




  // Custom InputTypes

  /**
   * MeasurementCountOutputType without action
   */
  export type MeasurementCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MeasurementCountOutputType
     * 
    **/
    select?: MeasurementCountOutputTypeSelect | null
  }



  /**
   * Count Type ServingCountOutputType
   */


  export type ServingCountOutputType = {
    products: number
  }

  export type ServingCountOutputTypeSelect = {
    products?: boolean
  }

  export type ServingCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ServingCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ServingCountOutputType
    : S extends undefined
    ? never
    : S extends ServingCountOutputTypeArgs
    ?'include' extends U
    ? ServingCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ServingCountOutputType ? ServingCountOutputType[P] : never
  } 
    : ServingCountOutputType
  : ServingCountOutputType




  // Custom InputTypes

  /**
   * ServingCountOutputType without action
   */
  export type ServingCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ServingCountOutputType
     * 
    **/
    select?: ServingCountOutputTypeSelect | null
  }



  /**
   * Count Type EnergyCountOutputType
   */


  export type EnergyCountOutputType = {
    measurements: number
  }

  export type EnergyCountOutputTypeSelect = {
    measurements?: boolean
  }

  export type EnergyCountOutputTypeGetPayload<
    S extends boolean | null | undefined | EnergyCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? EnergyCountOutputType
    : S extends undefined
    ? never
    : S extends EnergyCountOutputTypeArgs
    ?'include' extends U
    ? EnergyCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof EnergyCountOutputType ? EnergyCountOutputType[P] : never
  } 
    : EnergyCountOutputType
  : EnergyCountOutputType




  // Custom InputTypes

  /**
   * EnergyCountOutputType without action
   */
  export type EnergyCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EnergyCountOutputType
     * 
    **/
    select?: EnergyCountOutputTypeSelect | null
  }



  /**
   * Count Type ProteinCountOutputType
   */


  export type ProteinCountOutputType = {
    measurements: number
    NutritionFact: number
  }

  export type ProteinCountOutputTypeSelect = {
    measurements?: boolean
    NutritionFact?: boolean
  }

  export type ProteinCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProteinCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProteinCountOutputType
    : S extends undefined
    ? never
    : S extends ProteinCountOutputTypeArgs
    ?'include' extends U
    ? ProteinCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProteinCountOutputType ? ProteinCountOutputType[P] : never
  } 
    : ProteinCountOutputType
  : ProteinCountOutputType




  // Custom InputTypes

  /**
   * ProteinCountOutputType without action
   */
  export type ProteinCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProteinCountOutputType
     * 
    **/
    select?: ProteinCountOutputTypeSelect | null
  }



  /**
   * Count Type CholesterolCountOutputType
   */


  export type CholesterolCountOutputType = {
    measurements: number
    NutritionFact: number
  }

  export type CholesterolCountOutputTypeSelect = {
    measurements?: boolean
    NutritionFact?: boolean
  }

  export type CholesterolCountOutputTypeGetPayload<
    S extends boolean | null | undefined | CholesterolCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? CholesterolCountOutputType
    : S extends undefined
    ? never
    : S extends CholesterolCountOutputTypeArgs
    ?'include' extends U
    ? CholesterolCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof CholesterolCountOutputType ? CholesterolCountOutputType[P] : never
  } 
    : CholesterolCountOutputType
  : CholesterolCountOutputType




  // Custom InputTypes

  /**
   * CholesterolCountOutputType without action
   */
  export type CholesterolCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CholesterolCountOutputType
     * 
    **/
    select?: CholesterolCountOutputTypeSelect | null
  }



  /**
   * Count Type FiberCountOutputType
   */


  export type FiberCountOutputType = {
    measurements: number
    NutritionFact: number
  }

  export type FiberCountOutputTypeSelect = {
    measurements?: boolean
    NutritionFact?: boolean
  }

  export type FiberCountOutputTypeGetPayload<
    S extends boolean | null | undefined | FiberCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? FiberCountOutputType
    : S extends undefined
    ? never
    : S extends FiberCountOutputTypeArgs
    ?'include' extends U
    ? FiberCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof FiberCountOutputType ? FiberCountOutputType[P] : never
  } 
    : FiberCountOutputType
  : FiberCountOutputType




  // Custom InputTypes

  /**
   * FiberCountOutputType without action
   */
  export type FiberCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the FiberCountOutputType
     * 
    **/
    select?: FiberCountOutputTypeSelect | null
  }



  /**
   * Count Type WaterCountOutputType
   */


  export type WaterCountOutputType = {
    measurements: number
    NutritionFact: number
  }

  export type WaterCountOutputTypeSelect = {
    measurements?: boolean
    NutritionFact?: boolean
  }

  export type WaterCountOutputTypeGetPayload<
    S extends boolean | null | undefined | WaterCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? WaterCountOutputType
    : S extends undefined
    ? never
    : S extends WaterCountOutputTypeArgs
    ?'include' extends U
    ? WaterCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof WaterCountOutputType ? WaterCountOutputType[P] : never
  } 
    : WaterCountOutputType
  : WaterCountOutputType




  // Custom InputTypes

  /**
   * WaterCountOutputType without action
   */
  export type WaterCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the WaterCountOutputType
     * 
    **/
    select?: WaterCountOutputTypeSelect | null
  }



  /**
   * Count Type NutritionFactCountOutputType
   */


  export type NutritionFactCountOutputType = {
    energy: number
  }

  export type NutritionFactCountOutputTypeSelect = {
    energy?: boolean
  }

  export type NutritionFactCountOutputTypeGetPayload<
    S extends boolean | null | undefined | NutritionFactCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? NutritionFactCountOutputType
    : S extends undefined
    ? never
    : S extends NutritionFactCountOutputTypeArgs
    ?'include' extends U
    ? NutritionFactCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof NutritionFactCountOutputType ? NutritionFactCountOutputType[P] : never
  } 
    : NutritionFactCountOutputType
  : NutritionFactCountOutputType




  // Custom InputTypes

  /**
   * NutritionFactCountOutputType without action
   */
  export type NutritionFactCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the NutritionFactCountOutputType
     * 
    **/
    select?: NutritionFactCountOutputTypeSelect | null
  }



  /**
   * Count Type ProductCountOutputType
   */


  export type ProductCountOutputType = {
    labels: number
  }

  export type ProductCountOutputTypeSelect = {
    labels?: boolean
  }

  export type ProductCountOutputTypeGetPayload<
    S extends boolean | null | undefined | ProductCountOutputTypeArgs,
    U = keyof S
      > = S extends true
        ? ProductCountOutputType
    : S extends undefined
    ? never
    : S extends ProductCountOutputTypeArgs
    ?'include' extends U
    ? ProductCountOutputType 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof ProductCountOutputType ? ProductCountOutputType[P] : never
  } 
    : ProductCountOutputType
  : ProductCountOutputType




  // Custom InputTypes

  /**
   * ProductCountOutputType without action
   */
  export type ProductCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the ProductCountOutputType
     * 
    **/
    select?: ProductCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model Resource
   */


  export type AggregateResource = {
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  export type ResourceAvgAggregateOutputType = {
    id: number | null
  }

  export type ResourceSumAggregateOutputType = {
    id: number | null
  }

  export type ResourceMinAggregateOutputType = {
    id: number | null
    displayName: string | null
    slug: string | null
  }

  export type ResourceMaxAggregateOutputType = {
    id: number | null
    displayName: string | null
    slug: string | null
  }

  export type ResourceCountAggregateOutputType = {
    id: number
    displayName: number
    slug: number
    _all: number
  }


  export type ResourceAvgAggregateInputType = {
    id?: true
  }

  export type ResourceSumAggregateInputType = {
    id?: true
  }

  export type ResourceMinAggregateInputType = {
    id?: true
    displayName?: true
    slug?: true
  }

  export type ResourceMaxAggregateInputType = {
    id?: true
    displayName?: true
    slug?: true
  }

  export type ResourceCountAggregateInputType = {
    id?: true
    displayName?: true
    slug?: true
    _all?: true
  }

  export type ResourceAggregateArgs = {
    /**
     * Filter which Resource to aggregate.
     * 
    **/
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     * 
    **/
    orderBy?: Enumerable<ResourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Resources
    **/
    _count?: true | ResourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ResourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ResourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ResourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ResourceMaxAggregateInputType
  }

  export type GetResourceAggregateType<T extends ResourceAggregateArgs> = {
        [P in keyof T & keyof AggregateResource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateResource[P]>
      : GetScalarType<T[P], AggregateResource[P]>
  }




  export type ResourceGroupByArgs = {
    where?: ResourceWhereInput
    orderBy?: Enumerable<ResourceOrderByWithAggregationInput>
    by: Array<ResourceScalarFieldEnum>
    having?: ResourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ResourceCountAggregateInputType | true
    _avg?: ResourceAvgAggregateInputType
    _sum?: ResourceSumAggregateInputType
    _min?: ResourceMinAggregateInputType
    _max?: ResourceMaxAggregateInputType
  }


  export type ResourceGroupByOutputType = {
    id: number
    displayName: string
    slug: string
    _count: ResourceCountAggregateOutputType | null
    _avg: ResourceAvgAggregateOutputType | null
    _sum: ResourceSumAggregateOutputType | null
    _min: ResourceMinAggregateOutputType | null
    _max: ResourceMaxAggregateOutputType | null
  }

  type GetResourceGroupByPayload<T extends ResourceGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ResourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ResourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ResourceGroupByOutputType[P]>
            : GetScalarType<T[P], ResourceGroupByOutputType[P]>
        }
      >
    >


  export type ResourceSelect = {
    id?: boolean
    displayName?: boolean
    slug?: boolean
  }

  export type ResourceGetPayload<
    S extends boolean | null | undefined | ResourceArgs,
    U = keyof S
      > = S extends true
        ? Resource
    : S extends undefined
    ? never
    : S extends ResourceArgs | ResourceFindManyArgs
    ?'include' extends U
    ? Resource 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
    P extends keyof Resource ? Resource[P] : never
  } 
    : Resource
  : Resource


  type ResourceCountArgs = Merge<
    Omit<ResourceFindManyArgs, 'select' | 'include'> & {
      select?: ResourceCountAggregateInputType | true
    }
  >

  export interface ResourceDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Resource that matches the filter.
     * @param {ResourceFindUniqueArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ResourceFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ResourceFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Resource'> extends True ? CheckSelect<T, Prisma__ResourceClient<Resource>, Prisma__ResourceClient<ResourceGetPayload<T>>> : CheckSelect<T, Prisma__ResourceClient<Resource | null >, Prisma__ResourceClient<ResourceGetPayload<T> | null >>

    /**
     * Find the first Resource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindFirstArgs} args - Arguments to find a Resource
     * @example
     * // Get one Resource
     * const resource = await prisma.resource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ResourceFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ResourceFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Resource'> extends True ? CheckSelect<T, Prisma__ResourceClient<Resource>, Prisma__ResourceClient<ResourceGetPayload<T>>> : CheckSelect<T, Prisma__ResourceClient<Resource | null >, Prisma__ResourceClient<ResourceGetPayload<T> | null >>

    /**
     * Find zero or more Resources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Resources
     * const resources = await prisma.resource.findMany()
     * 
     * // Get first 10 Resources
     * const resources = await prisma.resource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const resourceWithIdOnly = await prisma.resource.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ResourceFindManyArgs>(
      args?: SelectSubset<T, ResourceFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Resource>>, PrismaPromise<Array<ResourceGetPayload<T>>>>

    /**
     * Create a Resource.
     * @param {ResourceCreateArgs} args - Arguments to create a Resource.
     * @example
     * // Create one Resource
     * const Resource = await prisma.resource.create({
     *   data: {
     *     // ... data to create a Resource
     *   }
     * })
     * 
    **/
    create<T extends ResourceCreateArgs>(
      args: SelectSubset<T, ResourceCreateArgs>
    ): CheckSelect<T, Prisma__ResourceClient<Resource>, Prisma__ResourceClient<ResourceGetPayload<T>>>

    /**
     * Create many Resources.
     *     @param {ResourceCreateManyArgs} args - Arguments to create many Resources.
     *     @example
     *     // Create many Resources
     *     const resource = await prisma.resource.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ResourceCreateManyArgs>(
      args?: SelectSubset<T, ResourceCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Resource.
     * @param {ResourceDeleteArgs} args - Arguments to delete one Resource.
     * @example
     * // Delete one Resource
     * const Resource = await prisma.resource.delete({
     *   where: {
     *     // ... filter to delete one Resource
     *   }
     * })
     * 
    **/
    delete<T extends ResourceDeleteArgs>(
      args: SelectSubset<T, ResourceDeleteArgs>
    ): CheckSelect<T, Prisma__ResourceClient<Resource>, Prisma__ResourceClient<ResourceGetPayload<T>>>

    /**
     * Update one Resource.
     * @param {ResourceUpdateArgs} args - Arguments to update one Resource.
     * @example
     * // Update one Resource
     * const resource = await prisma.resource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ResourceUpdateArgs>(
      args: SelectSubset<T, ResourceUpdateArgs>
    ): CheckSelect<T, Prisma__ResourceClient<Resource>, Prisma__ResourceClient<ResourceGetPayload<T>>>

    /**
     * Delete zero or more Resources.
     * @param {ResourceDeleteManyArgs} args - Arguments to filter Resources to delete.
     * @example
     * // Delete a few Resources
     * const { count } = await prisma.resource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ResourceDeleteManyArgs>(
      args?: SelectSubset<T, ResourceDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Resources
     * const resource = await prisma.resource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ResourceUpdateManyArgs>(
      args: SelectSubset<T, ResourceUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Resource.
     * @param {ResourceUpsertArgs} args - Arguments to update or create a Resource.
     * @example
     * // Update or create a Resource
     * const resource = await prisma.resource.upsert({
     *   create: {
     *     // ... data to create a Resource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Resource we want to update
     *   }
     * })
    **/
    upsert<T extends ResourceUpsertArgs>(
      args: SelectSubset<T, ResourceUpsertArgs>
    ): CheckSelect<T, Prisma__ResourceClient<Resource>, Prisma__ResourceClient<ResourceGetPayload<T>>>

    /**
     * Count the number of Resources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceCountArgs} args - Arguments to filter Resources to count.
     * @example
     * // Count the number of Resources
     * const count = await prisma.resource.count({
     *   where: {
     *     // ... the filter for the Resources we want to count
     *   }
     * })
    **/
    count<T extends ResourceCountArgs>(
      args?: Subset<T, ResourceCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ResourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ResourceAggregateArgs>(args: Subset<T, ResourceAggregateArgs>): PrismaPromise<GetResourceAggregateType<T>>

    /**
     * Group by Resource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ResourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ResourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ResourceGroupByArgs['orderBy'] }
        : { orderBy?: ResourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ResourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetResourceGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Resource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ResourceClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Resource findUnique
   */
  export type ResourceFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Resource
     * 
    **/
    select?: ResourceSelect | null
    /**
     * Throw an Error if a Resource can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Resource to fetch.
     * 
    **/
    where: ResourceWhereUniqueInput
  }


  /**
   * Resource findFirst
   */
  export type ResourceFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Resource
     * 
    **/
    select?: ResourceSelect | null
    /**
     * Throw an Error if a Resource can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Resource to fetch.
     * 
    **/
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     * 
    **/
    orderBy?: Enumerable<ResourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Resources.
     * 
    **/
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Resources.
     * 
    **/
    distinct?: Enumerable<ResourceScalarFieldEnum>
  }


  /**
   * Resource findMany
   */
  export type ResourceFindManyArgs = {
    /**
     * Select specific fields to fetch from the Resource
     * 
    **/
    select?: ResourceSelect | null
    /**
     * Filter, which Resources to fetch.
     * 
    **/
    where?: ResourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Resources to fetch.
     * 
    **/
    orderBy?: Enumerable<ResourceOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Resources.
     * 
    **/
    cursor?: ResourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Resources from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Resources.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ResourceScalarFieldEnum>
  }


  /**
   * Resource create
   */
  export type ResourceCreateArgs = {
    /**
     * Select specific fields to fetch from the Resource
     * 
    **/
    select?: ResourceSelect | null
    /**
     * The data needed to create a Resource.
     * 
    **/
    data: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
  }


  /**
   * Resource createMany
   */
  export type ResourceCreateManyArgs = {
    /**
     * The data used to create many Resources.
     * 
    **/
    data: Enumerable<ResourceCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Resource update
   */
  export type ResourceUpdateArgs = {
    /**
     * Select specific fields to fetch from the Resource
     * 
    **/
    select?: ResourceSelect | null
    /**
     * The data needed to update a Resource.
     * 
    **/
    data: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
    /**
     * Choose, which Resource to update.
     * 
    **/
    where: ResourceWhereUniqueInput
  }


  /**
   * Resource updateMany
   */
  export type ResourceUpdateManyArgs = {
    /**
     * The data used to update Resources.
     * 
    **/
    data: XOR<ResourceUpdateManyMutationInput, ResourceUncheckedUpdateManyInput>
    /**
     * Filter which Resources to update
     * 
    **/
    where?: ResourceWhereInput
  }


  /**
   * Resource upsert
   */
  export type ResourceUpsertArgs = {
    /**
     * Select specific fields to fetch from the Resource
     * 
    **/
    select?: ResourceSelect | null
    /**
     * The filter to search for the Resource to update in case it exists.
     * 
    **/
    where: ResourceWhereUniqueInput
    /**
     * In case the Resource found by the `where` argument doesn't exist, create a new Resource with this data.
     * 
    **/
    create: XOR<ResourceCreateInput, ResourceUncheckedCreateInput>
    /**
     * In case the Resource was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ResourceUpdateInput, ResourceUncheckedUpdateInput>
  }


  /**
   * Resource delete
   */
  export type ResourceDeleteArgs = {
    /**
     * Select specific fields to fetch from the Resource
     * 
    **/
    select?: ResourceSelect | null
    /**
     * Filter which Resource to delete.
     * 
    **/
    where: ResourceWhereUniqueInput
  }


  /**
   * Resource deleteMany
   */
  export type ResourceDeleteManyArgs = {
    /**
     * Filter which Resources to delete
     * 
    **/
    where?: ResourceWhereInput
  }


  /**
   * Resource without action
   */
  export type ResourceArgs = {
    /**
     * Select specific fields to fetch from the Resource
     * 
    **/
    select?: ResourceSelect | null
  }



  /**
   * Model Label
   */


  export type AggregateLabel = {
    _count: LabelCountAggregateOutputType | null
    _avg: LabelAvgAggregateOutputType | null
    _sum: LabelSumAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  export type LabelAvgAggregateOutputType = {
    id: number | null
  }

  export type LabelSumAggregateOutputType = {
    id: number | null
  }

  export type LabelMinAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type LabelMaxAggregateOutputType = {
    id: number | null
    name: string | null
  }

  export type LabelCountAggregateOutputType = {
    id: number
    name: number
    _all: number
  }


  export type LabelAvgAggregateInputType = {
    id?: true
  }

  export type LabelSumAggregateInputType = {
    id?: true
  }

  export type LabelMinAggregateInputType = {
    id?: true
    name?: true
  }

  export type LabelMaxAggregateInputType = {
    id?: true
    name?: true
  }

  export type LabelCountAggregateInputType = {
    id?: true
    name?: true
    _all?: true
  }

  export type LabelAggregateArgs = {
    /**
     * Filter which Label to aggregate.
     * 
    **/
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Labels
    **/
    _count?: true | LabelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LabelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LabelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabelMaxAggregateInputType
  }

  export type GetLabelAggregateType<T extends LabelAggregateArgs> = {
        [P in keyof T & keyof AggregateLabel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabel[P]>
      : GetScalarType<T[P], AggregateLabel[P]>
  }




  export type LabelGroupByArgs = {
    where?: LabelWhereInput
    orderBy?: Enumerable<LabelOrderByWithAggregationInput>
    by: Array<LabelScalarFieldEnum>
    having?: LabelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabelCountAggregateInputType | true
    _avg?: LabelAvgAggregateInputType
    _sum?: LabelSumAggregateInputType
    _min?: LabelMinAggregateInputType
    _max?: LabelMaxAggregateInputType
  }


  export type LabelGroupByOutputType = {
    id: number
    name: string
    _count: LabelCountAggregateOutputType | null
    _avg: LabelAvgAggregateOutputType | null
    _sum: LabelSumAggregateOutputType | null
    _min: LabelMinAggregateOutputType | null
    _max: LabelMaxAggregateOutputType | null
  }

  type GetLabelGroupByPayload<T extends LabelGroupByArgs> = PrismaPromise<
    Array<
      PickArray<LabelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabelGroupByOutputType[P]>
            : GetScalarType<T[P], LabelGroupByOutputType[P]>
        }
      >
    >


  export type LabelSelect = {
    id?: boolean
    name?: boolean
    products?: boolean | ProductFindManyArgs
    _count?: boolean | LabelCountOutputTypeArgs
  }

  export type LabelInclude = {
    products?: boolean | ProductFindManyArgs
    _count?: boolean | LabelCountOutputTypeArgs
  }

  export type LabelGetPayload<
    S extends boolean | null | undefined | LabelArgs,
    U = keyof S
      > = S extends true
        ? Label
    : S extends undefined
    ? never
    : S extends LabelArgs | LabelFindManyArgs
    ?'include' extends U
    ? Label  & {
    [P in TrueKeys<S['include']>]:
        P extends 'products' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends '_count' ? LabelCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'products' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends '_count' ? LabelCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Label ? Label[P] : never
  } 
    : Label
  : Label


  type LabelCountArgs = Merge<
    Omit<LabelFindManyArgs, 'select' | 'include'> & {
      select?: LabelCountAggregateInputType | true
    }
  >

  export interface LabelDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Label that matches the filter.
     * @param {LabelFindUniqueArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends LabelFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, LabelFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Label'> extends True ? CheckSelect<T, Prisma__LabelClient<Label>, Prisma__LabelClient<LabelGetPayload<T>>> : CheckSelect<T, Prisma__LabelClient<Label | null >, Prisma__LabelClient<LabelGetPayload<T> | null >>

    /**
     * Find the first Label that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindFirstArgs} args - Arguments to find a Label
     * @example
     * // Get one Label
     * const label = await prisma.label.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends LabelFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, LabelFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Label'> extends True ? CheckSelect<T, Prisma__LabelClient<Label>, Prisma__LabelClient<LabelGetPayload<T>>> : CheckSelect<T, Prisma__LabelClient<Label | null >, Prisma__LabelClient<LabelGetPayload<T> | null >>

    /**
     * Find zero or more Labels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Labels
     * const labels = await prisma.label.findMany()
     * 
     * // Get first 10 Labels
     * const labels = await prisma.label.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labelWithIdOnly = await prisma.label.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends LabelFindManyArgs>(
      args?: SelectSubset<T, LabelFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Label>>, PrismaPromise<Array<LabelGetPayload<T>>>>

    /**
     * Create a Label.
     * @param {LabelCreateArgs} args - Arguments to create a Label.
     * @example
     * // Create one Label
     * const Label = await prisma.label.create({
     *   data: {
     *     // ... data to create a Label
     *   }
     * })
     * 
    **/
    create<T extends LabelCreateArgs>(
      args: SelectSubset<T, LabelCreateArgs>
    ): CheckSelect<T, Prisma__LabelClient<Label>, Prisma__LabelClient<LabelGetPayload<T>>>

    /**
     * Create many Labels.
     *     @param {LabelCreateManyArgs} args - Arguments to create many Labels.
     *     @example
     *     // Create many Labels
     *     const label = await prisma.label.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends LabelCreateManyArgs>(
      args?: SelectSubset<T, LabelCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Label.
     * @param {LabelDeleteArgs} args - Arguments to delete one Label.
     * @example
     * // Delete one Label
     * const Label = await prisma.label.delete({
     *   where: {
     *     // ... filter to delete one Label
     *   }
     * })
     * 
    **/
    delete<T extends LabelDeleteArgs>(
      args: SelectSubset<T, LabelDeleteArgs>
    ): CheckSelect<T, Prisma__LabelClient<Label>, Prisma__LabelClient<LabelGetPayload<T>>>

    /**
     * Update one Label.
     * @param {LabelUpdateArgs} args - Arguments to update one Label.
     * @example
     * // Update one Label
     * const label = await prisma.label.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends LabelUpdateArgs>(
      args: SelectSubset<T, LabelUpdateArgs>
    ): CheckSelect<T, Prisma__LabelClient<Label>, Prisma__LabelClient<LabelGetPayload<T>>>

    /**
     * Delete zero or more Labels.
     * @param {LabelDeleteManyArgs} args - Arguments to filter Labels to delete.
     * @example
     * // Delete a few Labels
     * const { count } = await prisma.label.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends LabelDeleteManyArgs>(
      args?: SelectSubset<T, LabelDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Labels
     * const label = await prisma.label.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends LabelUpdateManyArgs>(
      args: SelectSubset<T, LabelUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Label.
     * @param {LabelUpsertArgs} args - Arguments to update or create a Label.
     * @example
     * // Update or create a Label
     * const label = await prisma.label.upsert({
     *   create: {
     *     // ... data to create a Label
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Label we want to update
     *   }
     * })
    **/
    upsert<T extends LabelUpsertArgs>(
      args: SelectSubset<T, LabelUpsertArgs>
    ): CheckSelect<T, Prisma__LabelClient<Label>, Prisma__LabelClient<LabelGetPayload<T>>>

    /**
     * Count the number of Labels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelCountArgs} args - Arguments to filter Labels to count.
     * @example
     * // Count the number of Labels
     * const count = await prisma.label.count({
     *   where: {
     *     // ... the filter for the Labels we want to count
     *   }
     * })
    **/
    count<T extends LabelCountArgs>(
      args?: Subset<T, LabelCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabelAggregateArgs>(args: Subset<T, LabelAggregateArgs>): PrismaPromise<GetLabelAggregateType<T>>

    /**
     * Group by Label.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabelGroupByArgs['orderBy'] }
        : { orderBy?: LabelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabelGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Label.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__LabelClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Label findUnique
   */
  export type LabelFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
    /**
     * Throw an Error if a Label can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Label to fetch.
     * 
    **/
    where: LabelWhereUniqueInput
  }


  /**
   * Label findFirst
   */
  export type LabelFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
    /**
     * Throw an Error if a Label can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Label to fetch.
     * 
    **/
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Labels.
     * 
    **/
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Labels.
     * 
    **/
    distinct?: Enumerable<LabelScalarFieldEnum>
  }


  /**
   * Label findMany
   */
  export type LabelFindManyArgs = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
    /**
     * Filter, which Labels to fetch.
     * 
    **/
    where?: LabelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Labels to fetch.
     * 
    **/
    orderBy?: Enumerable<LabelOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Labels.
     * 
    **/
    cursor?: LabelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Labels from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Labels.
     * 
    **/
    skip?: number
    distinct?: Enumerable<LabelScalarFieldEnum>
  }


  /**
   * Label create
   */
  export type LabelCreateArgs = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
    /**
     * The data needed to create a Label.
     * 
    **/
    data: XOR<LabelCreateInput, LabelUncheckedCreateInput>
  }


  /**
   * Label createMany
   */
  export type LabelCreateManyArgs = {
    /**
     * The data used to create many Labels.
     * 
    **/
    data: Enumerable<LabelCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Label update
   */
  export type LabelUpdateArgs = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
    /**
     * The data needed to update a Label.
     * 
    **/
    data: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
    /**
     * Choose, which Label to update.
     * 
    **/
    where: LabelWhereUniqueInput
  }


  /**
   * Label updateMany
   */
  export type LabelUpdateManyArgs = {
    /**
     * The data used to update Labels.
     * 
    **/
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyInput>
    /**
     * Filter which Labels to update
     * 
    **/
    where?: LabelWhereInput
  }


  /**
   * Label upsert
   */
  export type LabelUpsertArgs = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
    /**
     * The filter to search for the Label to update in case it exists.
     * 
    **/
    where: LabelWhereUniqueInput
    /**
     * In case the Label found by the `where` argument doesn't exist, create a new Label with this data.
     * 
    **/
    create: XOR<LabelCreateInput, LabelUncheckedCreateInput>
    /**
     * In case the Label was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<LabelUpdateInput, LabelUncheckedUpdateInput>
  }


  /**
   * Label delete
   */
  export type LabelDeleteArgs = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
    /**
     * Filter which Label to delete.
     * 
    **/
    where: LabelWhereUniqueInput
  }


  /**
   * Label deleteMany
   */
  export type LabelDeleteManyArgs = {
    /**
     * Filter which Labels to delete
     * 
    **/
    where?: LabelWhereInput
  }


  /**
   * Label without action
   */
  export type LabelArgs = {
    /**
     * Select specific fields to fetch from the Label
     * 
    **/
    select?: LabelSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: LabelInclude | null
  }



  /**
   * Model Fat
   */


  export type AggregateFat = {
    _count: FatCountAggregateOutputType | null
    _avg: FatAvgAggregateOutputType | null
    _sum: FatSumAggregateOutputType | null
    _min: FatMinAggregateOutputType | null
    _max: FatMaxAggregateOutputType | null
  }

  export type FatAvgAggregateOutputType = {
    id: number | null
    totalFatId: number | null
    saturatedFatId: number | null
    monosaturatedFatId: number | null
    polyunsaturatedFatId: number | null
    transFatId: number | null
  }

  export type FatSumAggregateOutputType = {
    id: number | null
    totalFatId: number | null
    saturatedFatId: number | null
    monosaturatedFatId: number | null
    polyunsaturatedFatId: number | null
    transFatId: number | null
  }

  export type FatMinAggregateOutputType = {
    id: number | null
    totalFatId: number | null
    saturatedFatId: number | null
    monosaturatedFatId: number | null
    polyunsaturatedFatId: number | null
    transFatId: number | null
  }

  export type FatMaxAggregateOutputType = {
    id: number | null
    totalFatId: number | null
    saturatedFatId: number | null
    monosaturatedFatId: number | null
    polyunsaturatedFatId: number | null
    transFatId: number | null
  }

  export type FatCountAggregateOutputType = {
    id: number
    totalFatId: number
    saturatedFatId: number
    monosaturatedFatId: number
    polyunsaturatedFatId: number
    transFatId: number
    _all: number
  }


  export type FatAvgAggregateInputType = {
    id?: true
    totalFatId?: true
    saturatedFatId?: true
    monosaturatedFatId?: true
    polyunsaturatedFatId?: true
    transFatId?: true
  }

  export type FatSumAggregateInputType = {
    id?: true
    totalFatId?: true
    saturatedFatId?: true
    monosaturatedFatId?: true
    polyunsaturatedFatId?: true
    transFatId?: true
  }

  export type FatMinAggregateInputType = {
    id?: true
    totalFatId?: true
    saturatedFatId?: true
    monosaturatedFatId?: true
    polyunsaturatedFatId?: true
    transFatId?: true
  }

  export type FatMaxAggregateInputType = {
    id?: true
    totalFatId?: true
    saturatedFatId?: true
    monosaturatedFatId?: true
    polyunsaturatedFatId?: true
    transFatId?: true
  }

  export type FatCountAggregateInputType = {
    id?: true
    totalFatId?: true
    saturatedFatId?: true
    monosaturatedFatId?: true
    polyunsaturatedFatId?: true
    transFatId?: true
    _all?: true
  }

  export type FatAggregateArgs = {
    /**
     * Filter which Fat to aggregate.
     * 
    **/
    where?: FatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fats to fetch.
     * 
    **/
    orderBy?: Enumerable<FatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fats
    **/
    _count?: true | FatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FatMaxAggregateInputType
  }

  export type GetFatAggregateType<T extends FatAggregateArgs> = {
        [P in keyof T & keyof AggregateFat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFat[P]>
      : GetScalarType<T[P], AggregateFat[P]>
  }




  export type FatGroupByArgs = {
    where?: FatWhereInput
    orderBy?: Enumerable<FatOrderByWithAggregationInput>
    by: Array<FatScalarFieldEnum>
    having?: FatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FatCountAggregateInputType | true
    _avg?: FatAvgAggregateInputType
    _sum?: FatSumAggregateInputType
    _min?: FatMinAggregateInputType
    _max?: FatMaxAggregateInputType
  }


  export type FatGroupByOutputType = {
    id: number
    totalFatId: number
    saturatedFatId: number | null
    monosaturatedFatId: number | null
    polyunsaturatedFatId: number | null
    transFatId: number | null
    _count: FatCountAggregateOutputType | null
    _avg: FatAvgAggregateOutputType | null
    _sum: FatSumAggregateOutputType | null
    _min: FatMinAggregateOutputType | null
    _max: FatMaxAggregateOutputType | null
  }

  type GetFatGroupByPayload<T extends FatGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FatGroupByOutputType[P]>
            : GetScalarType<T[P], FatGroupByOutputType[P]>
        }
      >
    >


  export type FatSelect = {
    id?: boolean
    total?: boolean | TotalFatArgs
    totalFatId?: boolean
    saturated?: boolean | SaturatedFatArgs
    saturatedFatId?: boolean
    monounsaturated?: boolean | MonosaturatedFatArgs
    monosaturatedFatId?: boolean
    polyunsaturated?: boolean | PolyunsaturatedFatArgs
    polyunsaturatedFatId?: boolean
    trans?: boolean | TransFatArgs
    transFatId?: boolean
    nutritionFacts?: boolean | NutritionFactFindManyArgs
    _count?: boolean | FatCountOutputTypeArgs
  }

  export type FatInclude = {
    total?: boolean | TotalFatArgs
    saturated?: boolean | SaturatedFatArgs
    monounsaturated?: boolean | MonosaturatedFatArgs
    polyunsaturated?: boolean | PolyunsaturatedFatArgs
    trans?: boolean | TransFatArgs
    nutritionFacts?: boolean | NutritionFactFindManyArgs
    _count?: boolean | FatCountOutputTypeArgs
  }

  export type FatGetPayload<
    S extends boolean | null | undefined | FatArgs,
    U = keyof S
      > = S extends true
        ? Fat
    : S extends undefined
    ? never
    : S extends FatArgs | FatFindManyArgs
    ?'include' extends U
    ? Fat  & {
    [P in TrueKeys<S['include']>]:
        P extends 'total' ? TotalFatGetPayload<S['include'][P]> | null :
        P extends 'saturated' ? SaturatedFatGetPayload<S['include'][P]> | null :
        P extends 'monounsaturated' ? MonosaturatedFatGetPayload<S['include'][P]> | null :
        P extends 'polyunsaturated' ? PolyunsaturatedFatGetPayload<S['include'][P]> | null :
        P extends 'trans' ? TransFatGetPayload<S['include'][P]> | null :
        P extends 'nutritionFacts' ? Array < NutritionFactGetPayload<S['include'][P]>>  :
        P extends '_count' ? FatCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'total' ? TotalFatGetPayload<S['select'][P]> | null :
        P extends 'saturated' ? SaturatedFatGetPayload<S['select'][P]> | null :
        P extends 'monounsaturated' ? MonosaturatedFatGetPayload<S['select'][P]> | null :
        P extends 'polyunsaturated' ? PolyunsaturatedFatGetPayload<S['select'][P]> | null :
        P extends 'trans' ? TransFatGetPayload<S['select'][P]> | null :
        P extends 'nutritionFacts' ? Array < NutritionFactGetPayload<S['select'][P]>>  :
        P extends '_count' ? FatCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Fat ? Fat[P] : never
  } 
    : Fat
  : Fat


  type FatCountArgs = Merge<
    Omit<FatFindManyArgs, 'select' | 'include'> & {
      select?: FatCountAggregateInputType | true
    }
  >

  export interface FatDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Fat that matches the filter.
     * @param {FatFindUniqueArgs} args - Arguments to find a Fat
     * @example
     * // Get one Fat
     * const fat = await prisma.fat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FatFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FatFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Fat'> extends True ? CheckSelect<T, Prisma__FatClient<Fat>, Prisma__FatClient<FatGetPayload<T>>> : CheckSelect<T, Prisma__FatClient<Fat | null >, Prisma__FatClient<FatGetPayload<T> | null >>

    /**
     * Find the first Fat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FatFindFirstArgs} args - Arguments to find a Fat
     * @example
     * // Get one Fat
     * const fat = await prisma.fat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FatFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FatFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Fat'> extends True ? CheckSelect<T, Prisma__FatClient<Fat>, Prisma__FatClient<FatGetPayload<T>>> : CheckSelect<T, Prisma__FatClient<Fat | null >, Prisma__FatClient<FatGetPayload<T> | null >>

    /**
     * Find zero or more Fats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fats
     * const fats = await prisma.fat.findMany()
     * 
     * // Get first 10 Fats
     * const fats = await prisma.fat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fatWithIdOnly = await prisma.fat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FatFindManyArgs>(
      args?: SelectSubset<T, FatFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Fat>>, PrismaPromise<Array<FatGetPayload<T>>>>

    /**
     * Create a Fat.
     * @param {FatCreateArgs} args - Arguments to create a Fat.
     * @example
     * // Create one Fat
     * const Fat = await prisma.fat.create({
     *   data: {
     *     // ... data to create a Fat
     *   }
     * })
     * 
    **/
    create<T extends FatCreateArgs>(
      args: SelectSubset<T, FatCreateArgs>
    ): CheckSelect<T, Prisma__FatClient<Fat>, Prisma__FatClient<FatGetPayload<T>>>

    /**
     * Create many Fats.
     *     @param {FatCreateManyArgs} args - Arguments to create many Fats.
     *     @example
     *     // Create many Fats
     *     const fat = await prisma.fat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FatCreateManyArgs>(
      args?: SelectSubset<T, FatCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Fat.
     * @param {FatDeleteArgs} args - Arguments to delete one Fat.
     * @example
     * // Delete one Fat
     * const Fat = await prisma.fat.delete({
     *   where: {
     *     // ... filter to delete one Fat
     *   }
     * })
     * 
    **/
    delete<T extends FatDeleteArgs>(
      args: SelectSubset<T, FatDeleteArgs>
    ): CheckSelect<T, Prisma__FatClient<Fat>, Prisma__FatClient<FatGetPayload<T>>>

    /**
     * Update one Fat.
     * @param {FatUpdateArgs} args - Arguments to update one Fat.
     * @example
     * // Update one Fat
     * const fat = await prisma.fat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FatUpdateArgs>(
      args: SelectSubset<T, FatUpdateArgs>
    ): CheckSelect<T, Prisma__FatClient<Fat>, Prisma__FatClient<FatGetPayload<T>>>

    /**
     * Delete zero or more Fats.
     * @param {FatDeleteManyArgs} args - Arguments to filter Fats to delete.
     * @example
     * // Delete a few Fats
     * const { count } = await prisma.fat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FatDeleteManyArgs>(
      args?: SelectSubset<T, FatDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fats
     * const fat = await prisma.fat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FatUpdateManyArgs>(
      args: SelectSubset<T, FatUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Fat.
     * @param {FatUpsertArgs} args - Arguments to update or create a Fat.
     * @example
     * // Update or create a Fat
     * const fat = await prisma.fat.upsert({
     *   create: {
     *     // ... data to create a Fat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fat we want to update
     *   }
     * })
    **/
    upsert<T extends FatUpsertArgs>(
      args: SelectSubset<T, FatUpsertArgs>
    ): CheckSelect<T, Prisma__FatClient<Fat>, Prisma__FatClient<FatGetPayload<T>>>

    /**
     * Count the number of Fats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FatCountArgs} args - Arguments to filter Fats to count.
     * @example
     * // Count the number of Fats
     * const count = await prisma.fat.count({
     *   where: {
     *     // ... the filter for the Fats we want to count
     *   }
     * })
    **/
    count<T extends FatCountArgs>(
      args?: Subset<T, FatCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FatAggregateArgs>(args: Subset<T, FatAggregateArgs>): PrismaPromise<GetFatAggregateType<T>>

    /**
     * Group by Fat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FatGroupByArgs['orderBy'] }
        : { orderBy?: FatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFatGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FatClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    total<T extends TotalFatArgs = {}>(args?: Subset<T, TotalFatArgs>): CheckSelect<T, Prisma__TotalFatClient<TotalFat | null >, Prisma__TotalFatClient<TotalFatGetPayload<T> | null >>;

    saturated<T extends SaturatedFatArgs = {}>(args?: Subset<T, SaturatedFatArgs>): CheckSelect<T, Prisma__SaturatedFatClient<SaturatedFat | null >, Prisma__SaturatedFatClient<SaturatedFatGetPayload<T> | null >>;

    monounsaturated<T extends MonosaturatedFatArgs = {}>(args?: Subset<T, MonosaturatedFatArgs>): CheckSelect<T, Prisma__MonosaturatedFatClient<MonosaturatedFat | null >, Prisma__MonosaturatedFatClient<MonosaturatedFatGetPayload<T> | null >>;

    polyunsaturated<T extends PolyunsaturatedFatArgs = {}>(args?: Subset<T, PolyunsaturatedFatArgs>): CheckSelect<T, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFat | null >, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFatGetPayload<T> | null >>;

    trans<T extends TransFatArgs = {}>(args?: Subset<T, TransFatArgs>): CheckSelect<T, Prisma__TransFatClient<TransFat | null >, Prisma__TransFatClient<TransFatGetPayload<T> | null >>;

    nutritionFacts<T extends NutritionFactFindManyArgs = {}>(args?: Subset<T, NutritionFactFindManyArgs>): CheckSelect<T, PrismaPromise<Array<NutritionFact>>, PrismaPromise<Array<NutritionFactGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Fat findUnique
   */
  export type FatFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Fat
     * 
    **/
    select?: FatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FatInclude | null
    /**
     * Throw an Error if a Fat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Fat to fetch.
     * 
    **/
    where: FatWhereUniqueInput
  }


  /**
   * Fat findFirst
   */
  export type FatFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Fat
     * 
    **/
    select?: FatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FatInclude | null
    /**
     * Throw an Error if a Fat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Fat to fetch.
     * 
    **/
    where?: FatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fats to fetch.
     * 
    **/
    orderBy?: Enumerable<FatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fats.
     * 
    **/
    cursor?: FatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fats.
     * 
    **/
    distinct?: Enumerable<FatScalarFieldEnum>
  }


  /**
   * Fat findMany
   */
  export type FatFindManyArgs = {
    /**
     * Select specific fields to fetch from the Fat
     * 
    **/
    select?: FatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FatInclude | null
    /**
     * Filter, which Fats to fetch.
     * 
    **/
    where?: FatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fats to fetch.
     * 
    **/
    orderBy?: Enumerable<FatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fats.
     * 
    **/
    cursor?: FatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fats.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FatScalarFieldEnum>
  }


  /**
   * Fat create
   */
  export type FatCreateArgs = {
    /**
     * Select specific fields to fetch from the Fat
     * 
    **/
    select?: FatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FatInclude | null
    /**
     * The data needed to create a Fat.
     * 
    **/
    data: XOR<FatCreateInput, FatUncheckedCreateInput>
  }


  /**
   * Fat createMany
   */
  export type FatCreateManyArgs = {
    /**
     * The data used to create many Fats.
     * 
    **/
    data: Enumerable<FatCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Fat update
   */
  export type FatUpdateArgs = {
    /**
     * Select specific fields to fetch from the Fat
     * 
    **/
    select?: FatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FatInclude | null
    /**
     * The data needed to update a Fat.
     * 
    **/
    data: XOR<FatUpdateInput, FatUncheckedUpdateInput>
    /**
     * Choose, which Fat to update.
     * 
    **/
    where: FatWhereUniqueInput
  }


  /**
   * Fat updateMany
   */
  export type FatUpdateManyArgs = {
    /**
     * The data used to update Fats.
     * 
    **/
    data: XOR<FatUpdateManyMutationInput, FatUncheckedUpdateManyInput>
    /**
     * Filter which Fats to update
     * 
    **/
    where?: FatWhereInput
  }


  /**
   * Fat upsert
   */
  export type FatUpsertArgs = {
    /**
     * Select specific fields to fetch from the Fat
     * 
    **/
    select?: FatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FatInclude | null
    /**
     * The filter to search for the Fat to update in case it exists.
     * 
    **/
    where: FatWhereUniqueInput
    /**
     * In case the Fat found by the `where` argument doesn't exist, create a new Fat with this data.
     * 
    **/
    create: XOR<FatCreateInput, FatUncheckedCreateInput>
    /**
     * In case the Fat was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FatUpdateInput, FatUncheckedUpdateInput>
  }


  /**
   * Fat delete
   */
  export type FatDeleteArgs = {
    /**
     * Select specific fields to fetch from the Fat
     * 
    **/
    select?: FatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FatInclude | null
    /**
     * Filter which Fat to delete.
     * 
    **/
    where: FatWhereUniqueInput
  }


  /**
   * Fat deleteMany
   */
  export type FatDeleteManyArgs = {
    /**
     * Filter which Fats to delete
     * 
    **/
    where?: FatWhereInput
  }


  /**
   * Fat without action
   */
  export type FatArgs = {
    /**
     * Select specific fields to fetch from the Fat
     * 
    **/
    select?: FatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FatInclude | null
  }



  /**
   * Model TotalFat
   */


  export type AggregateTotalFat = {
    _count: TotalFatCountAggregateOutputType | null
    _avg: TotalFatAvgAggregateOutputType | null
    _sum: TotalFatSumAggregateOutputType | null
    _min: TotalFatMinAggregateOutputType | null
    _max: TotalFatMaxAggregateOutputType | null
  }

  export type TotalFatAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type TotalFatSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type TotalFatMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type TotalFatMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type TotalFatCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type TotalFatAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type TotalFatSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type TotalFatMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type TotalFatMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type TotalFatCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type TotalFatAggregateArgs = {
    /**
     * Filter which TotalFat to aggregate.
     * 
    **/
    where?: TotalFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TotalFats to fetch.
     * 
    **/
    orderBy?: Enumerable<TotalFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TotalFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TotalFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TotalFats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TotalFats
    **/
    _count?: true | TotalFatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TotalFatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TotalFatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TotalFatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TotalFatMaxAggregateInputType
  }

  export type GetTotalFatAggregateType<T extends TotalFatAggregateArgs> = {
        [P in keyof T & keyof AggregateTotalFat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTotalFat[P]>
      : GetScalarType<T[P], AggregateTotalFat[P]>
  }




  export type TotalFatGroupByArgs = {
    where?: TotalFatWhereInput
    orderBy?: Enumerable<TotalFatOrderByWithAggregationInput>
    by: Array<TotalFatScalarFieldEnum>
    having?: TotalFatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TotalFatCountAggregateInputType | true
    _avg?: TotalFatAvgAggregateInputType
    _sum?: TotalFatSumAggregateInputType
    _min?: TotalFatMinAggregateInputType
    _max?: TotalFatMaxAggregateInputType
  }


  export type TotalFatGroupByOutputType = {
    id: number
    measurementId: number
    _count: TotalFatCountAggregateOutputType | null
    _avg: TotalFatAvgAggregateOutputType | null
    _sum: TotalFatSumAggregateOutputType | null
    _min: TotalFatMinAggregateOutputType | null
    _max: TotalFatMaxAggregateOutputType | null
  }

  type GetTotalFatGroupByPayload<T extends TotalFatGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TotalFatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TotalFatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TotalFatGroupByOutputType[P]>
            : GetScalarType<T[P], TotalFatGroupByOutputType[P]>
        }
      >
    >


  export type TotalFatSelect = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    fat?: boolean | FatArgs
    measurementId?: boolean
  }

  export type TotalFatInclude = {
    measurement?: boolean | MeasurementArgs
    fat?: boolean | FatArgs
  }

  export type TotalFatGetPayload<
    S extends boolean | null | undefined | TotalFatArgs,
    U = keyof S
      > = S extends true
        ? TotalFat
    : S extends undefined
    ? never
    : S extends TotalFatArgs | TotalFatFindManyArgs
    ?'include' extends U
    ? TotalFat  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> | null :
        P extends 'fat' ? FatGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> | null :
        P extends 'fat' ? FatGetPayload<S['select'][P]> | null :  P extends keyof TotalFat ? TotalFat[P] : never
  } 
    : TotalFat
  : TotalFat


  type TotalFatCountArgs = Merge<
    Omit<TotalFatFindManyArgs, 'select' | 'include'> & {
      select?: TotalFatCountAggregateInputType | true
    }
  >

  export interface TotalFatDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TotalFat that matches the filter.
     * @param {TotalFatFindUniqueArgs} args - Arguments to find a TotalFat
     * @example
     * // Get one TotalFat
     * const totalFat = await prisma.totalFat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TotalFatFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TotalFatFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TotalFat'> extends True ? CheckSelect<T, Prisma__TotalFatClient<TotalFat>, Prisma__TotalFatClient<TotalFatGetPayload<T>>> : CheckSelect<T, Prisma__TotalFatClient<TotalFat | null >, Prisma__TotalFatClient<TotalFatGetPayload<T> | null >>

    /**
     * Find the first TotalFat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalFatFindFirstArgs} args - Arguments to find a TotalFat
     * @example
     * // Get one TotalFat
     * const totalFat = await prisma.totalFat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TotalFatFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TotalFatFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TotalFat'> extends True ? CheckSelect<T, Prisma__TotalFatClient<TotalFat>, Prisma__TotalFatClient<TotalFatGetPayload<T>>> : CheckSelect<T, Prisma__TotalFatClient<TotalFat | null >, Prisma__TotalFatClient<TotalFatGetPayload<T> | null >>

    /**
     * Find zero or more TotalFats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalFatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TotalFats
     * const totalFats = await prisma.totalFat.findMany()
     * 
     * // Get first 10 TotalFats
     * const totalFats = await prisma.totalFat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const totalFatWithIdOnly = await prisma.totalFat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TotalFatFindManyArgs>(
      args?: SelectSubset<T, TotalFatFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TotalFat>>, PrismaPromise<Array<TotalFatGetPayload<T>>>>

    /**
     * Create a TotalFat.
     * @param {TotalFatCreateArgs} args - Arguments to create a TotalFat.
     * @example
     * // Create one TotalFat
     * const TotalFat = await prisma.totalFat.create({
     *   data: {
     *     // ... data to create a TotalFat
     *   }
     * })
     * 
    **/
    create<T extends TotalFatCreateArgs>(
      args: SelectSubset<T, TotalFatCreateArgs>
    ): CheckSelect<T, Prisma__TotalFatClient<TotalFat>, Prisma__TotalFatClient<TotalFatGetPayload<T>>>

    /**
     * Create many TotalFats.
     *     @param {TotalFatCreateManyArgs} args - Arguments to create many TotalFats.
     *     @example
     *     // Create many TotalFats
     *     const totalFat = await prisma.totalFat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TotalFatCreateManyArgs>(
      args?: SelectSubset<T, TotalFatCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TotalFat.
     * @param {TotalFatDeleteArgs} args - Arguments to delete one TotalFat.
     * @example
     * // Delete one TotalFat
     * const TotalFat = await prisma.totalFat.delete({
     *   where: {
     *     // ... filter to delete one TotalFat
     *   }
     * })
     * 
    **/
    delete<T extends TotalFatDeleteArgs>(
      args: SelectSubset<T, TotalFatDeleteArgs>
    ): CheckSelect<T, Prisma__TotalFatClient<TotalFat>, Prisma__TotalFatClient<TotalFatGetPayload<T>>>

    /**
     * Update one TotalFat.
     * @param {TotalFatUpdateArgs} args - Arguments to update one TotalFat.
     * @example
     * // Update one TotalFat
     * const totalFat = await prisma.totalFat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TotalFatUpdateArgs>(
      args: SelectSubset<T, TotalFatUpdateArgs>
    ): CheckSelect<T, Prisma__TotalFatClient<TotalFat>, Prisma__TotalFatClient<TotalFatGetPayload<T>>>

    /**
     * Delete zero or more TotalFats.
     * @param {TotalFatDeleteManyArgs} args - Arguments to filter TotalFats to delete.
     * @example
     * // Delete a few TotalFats
     * const { count } = await prisma.totalFat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TotalFatDeleteManyArgs>(
      args?: SelectSubset<T, TotalFatDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TotalFats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalFatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TotalFats
     * const totalFat = await prisma.totalFat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TotalFatUpdateManyArgs>(
      args: SelectSubset<T, TotalFatUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TotalFat.
     * @param {TotalFatUpsertArgs} args - Arguments to update or create a TotalFat.
     * @example
     * // Update or create a TotalFat
     * const totalFat = await prisma.totalFat.upsert({
     *   create: {
     *     // ... data to create a TotalFat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TotalFat we want to update
     *   }
     * })
    **/
    upsert<T extends TotalFatUpsertArgs>(
      args: SelectSubset<T, TotalFatUpsertArgs>
    ): CheckSelect<T, Prisma__TotalFatClient<TotalFat>, Prisma__TotalFatClient<TotalFatGetPayload<T>>>

    /**
     * Count the number of TotalFats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalFatCountArgs} args - Arguments to filter TotalFats to count.
     * @example
     * // Count the number of TotalFats
     * const count = await prisma.totalFat.count({
     *   where: {
     *     // ... the filter for the TotalFats we want to count
     *   }
     * })
    **/
    count<T extends TotalFatCountArgs>(
      args?: Subset<T, TotalFatCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TotalFatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TotalFat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalFatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TotalFatAggregateArgs>(args: Subset<T, TotalFatAggregateArgs>): PrismaPromise<GetTotalFatAggregateType<T>>

    /**
     * Group by TotalFat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalFatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TotalFatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TotalFatGroupByArgs['orderBy'] }
        : { orderBy?: TotalFatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TotalFatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTotalFatGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TotalFat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TotalFatClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    fat<T extends FatArgs = {}>(args?: Subset<T, FatArgs>): CheckSelect<T, Prisma__FatClient<Fat | null >, Prisma__FatClient<FatGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TotalFat findUnique
   */
  export type TotalFatFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TotalFat
     * 
    **/
    select?: TotalFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalFatInclude | null
    /**
     * Throw an Error if a TotalFat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TotalFat to fetch.
     * 
    **/
    where: TotalFatWhereUniqueInput
  }


  /**
   * TotalFat findFirst
   */
  export type TotalFatFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TotalFat
     * 
    **/
    select?: TotalFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalFatInclude | null
    /**
     * Throw an Error if a TotalFat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TotalFat to fetch.
     * 
    **/
    where?: TotalFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TotalFats to fetch.
     * 
    **/
    orderBy?: Enumerable<TotalFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TotalFats.
     * 
    **/
    cursor?: TotalFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TotalFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TotalFats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TotalFats.
     * 
    **/
    distinct?: Enumerable<TotalFatScalarFieldEnum>
  }


  /**
   * TotalFat findMany
   */
  export type TotalFatFindManyArgs = {
    /**
     * Select specific fields to fetch from the TotalFat
     * 
    **/
    select?: TotalFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalFatInclude | null
    /**
     * Filter, which TotalFats to fetch.
     * 
    **/
    where?: TotalFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TotalFats to fetch.
     * 
    **/
    orderBy?: Enumerable<TotalFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TotalFats.
     * 
    **/
    cursor?: TotalFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TotalFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TotalFats.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TotalFatScalarFieldEnum>
  }


  /**
   * TotalFat create
   */
  export type TotalFatCreateArgs = {
    /**
     * Select specific fields to fetch from the TotalFat
     * 
    **/
    select?: TotalFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalFatInclude | null
    /**
     * The data needed to create a TotalFat.
     * 
    **/
    data: XOR<TotalFatCreateInput, TotalFatUncheckedCreateInput>
  }


  /**
   * TotalFat createMany
   */
  export type TotalFatCreateManyArgs = {
    /**
     * The data used to create many TotalFats.
     * 
    **/
    data: Enumerable<TotalFatCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TotalFat update
   */
  export type TotalFatUpdateArgs = {
    /**
     * Select specific fields to fetch from the TotalFat
     * 
    **/
    select?: TotalFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalFatInclude | null
    /**
     * The data needed to update a TotalFat.
     * 
    **/
    data: XOR<TotalFatUpdateInput, TotalFatUncheckedUpdateInput>
    /**
     * Choose, which TotalFat to update.
     * 
    **/
    where: TotalFatWhereUniqueInput
  }


  /**
   * TotalFat updateMany
   */
  export type TotalFatUpdateManyArgs = {
    /**
     * The data used to update TotalFats.
     * 
    **/
    data: XOR<TotalFatUpdateManyMutationInput, TotalFatUncheckedUpdateManyInput>
    /**
     * Filter which TotalFats to update
     * 
    **/
    where?: TotalFatWhereInput
  }


  /**
   * TotalFat upsert
   */
  export type TotalFatUpsertArgs = {
    /**
     * Select specific fields to fetch from the TotalFat
     * 
    **/
    select?: TotalFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalFatInclude | null
    /**
     * The filter to search for the TotalFat to update in case it exists.
     * 
    **/
    where: TotalFatWhereUniqueInput
    /**
     * In case the TotalFat found by the `where` argument doesn't exist, create a new TotalFat with this data.
     * 
    **/
    create: XOR<TotalFatCreateInput, TotalFatUncheckedCreateInput>
    /**
     * In case the TotalFat was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TotalFatUpdateInput, TotalFatUncheckedUpdateInput>
  }


  /**
   * TotalFat delete
   */
  export type TotalFatDeleteArgs = {
    /**
     * Select specific fields to fetch from the TotalFat
     * 
    **/
    select?: TotalFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalFatInclude | null
    /**
     * Filter which TotalFat to delete.
     * 
    **/
    where: TotalFatWhereUniqueInput
  }


  /**
   * TotalFat deleteMany
   */
  export type TotalFatDeleteManyArgs = {
    /**
     * Filter which TotalFats to delete
     * 
    **/
    where?: TotalFatWhereInput
  }


  /**
   * TotalFat without action
   */
  export type TotalFatArgs = {
    /**
     * Select specific fields to fetch from the TotalFat
     * 
    **/
    select?: TotalFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalFatInclude | null
  }



  /**
   * Model SaturatedFat
   */


  export type AggregateSaturatedFat = {
    _count: SaturatedFatCountAggregateOutputType | null
    _avg: SaturatedFatAvgAggregateOutputType | null
    _sum: SaturatedFatSumAggregateOutputType | null
    _min: SaturatedFatMinAggregateOutputType | null
    _max: SaturatedFatMaxAggregateOutputType | null
  }

  export type SaturatedFatAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SaturatedFatSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SaturatedFatMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SaturatedFatMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SaturatedFatCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type SaturatedFatAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SaturatedFatSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SaturatedFatMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SaturatedFatMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SaturatedFatCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type SaturatedFatAggregateArgs = {
    /**
     * Filter which SaturatedFat to aggregate.
     * 
    **/
    where?: SaturatedFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaturatedFats to fetch.
     * 
    **/
    orderBy?: Enumerable<SaturatedFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SaturatedFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaturatedFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaturatedFats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SaturatedFats
    **/
    _count?: true | SaturatedFatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaturatedFatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaturatedFatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaturatedFatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaturatedFatMaxAggregateInputType
  }

  export type GetSaturatedFatAggregateType<T extends SaturatedFatAggregateArgs> = {
        [P in keyof T & keyof AggregateSaturatedFat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSaturatedFat[P]>
      : GetScalarType<T[P], AggregateSaturatedFat[P]>
  }




  export type SaturatedFatGroupByArgs = {
    where?: SaturatedFatWhereInput
    orderBy?: Enumerable<SaturatedFatOrderByWithAggregationInput>
    by: Array<SaturatedFatScalarFieldEnum>
    having?: SaturatedFatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaturatedFatCountAggregateInputType | true
    _avg?: SaturatedFatAvgAggregateInputType
    _sum?: SaturatedFatSumAggregateInputType
    _min?: SaturatedFatMinAggregateInputType
    _max?: SaturatedFatMaxAggregateInputType
  }


  export type SaturatedFatGroupByOutputType = {
    id: number
    measurementId: number
    _count: SaturatedFatCountAggregateOutputType | null
    _avg: SaturatedFatAvgAggregateOutputType | null
    _sum: SaturatedFatSumAggregateOutputType | null
    _min: SaturatedFatMinAggregateOutputType | null
    _max: SaturatedFatMaxAggregateOutputType | null
  }

  type GetSaturatedFatGroupByPayload<T extends SaturatedFatGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SaturatedFatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaturatedFatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaturatedFatGroupByOutputType[P]>
            : GetScalarType<T[P], SaturatedFatGroupByOutputType[P]>
        }
      >
    >


  export type SaturatedFatSelect = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    fat?: boolean | FatArgs
    measurementId?: boolean
  }

  export type SaturatedFatInclude = {
    measurement?: boolean | MeasurementArgs
    fat?: boolean | FatArgs
  }

  export type SaturatedFatGetPayload<
    S extends boolean | null | undefined | SaturatedFatArgs,
    U = keyof S
      > = S extends true
        ? SaturatedFat
    : S extends undefined
    ? never
    : S extends SaturatedFatArgs | SaturatedFatFindManyArgs
    ?'include' extends U
    ? SaturatedFat  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'fat' ? FatGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'fat' ? FatGetPayload<S['select'][P]> | null :  P extends keyof SaturatedFat ? SaturatedFat[P] : never
  } 
    : SaturatedFat
  : SaturatedFat


  type SaturatedFatCountArgs = Merge<
    Omit<SaturatedFatFindManyArgs, 'select' | 'include'> & {
      select?: SaturatedFatCountAggregateInputType | true
    }
  >

  export interface SaturatedFatDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SaturatedFat that matches the filter.
     * @param {SaturatedFatFindUniqueArgs} args - Arguments to find a SaturatedFat
     * @example
     * // Get one SaturatedFat
     * const saturatedFat = await prisma.saturatedFat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SaturatedFatFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SaturatedFatFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SaturatedFat'> extends True ? CheckSelect<T, Prisma__SaturatedFatClient<SaturatedFat>, Prisma__SaturatedFatClient<SaturatedFatGetPayload<T>>> : CheckSelect<T, Prisma__SaturatedFatClient<SaturatedFat | null >, Prisma__SaturatedFatClient<SaturatedFatGetPayload<T> | null >>

    /**
     * Find the first SaturatedFat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaturatedFatFindFirstArgs} args - Arguments to find a SaturatedFat
     * @example
     * // Get one SaturatedFat
     * const saturatedFat = await prisma.saturatedFat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SaturatedFatFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SaturatedFatFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SaturatedFat'> extends True ? CheckSelect<T, Prisma__SaturatedFatClient<SaturatedFat>, Prisma__SaturatedFatClient<SaturatedFatGetPayload<T>>> : CheckSelect<T, Prisma__SaturatedFatClient<SaturatedFat | null >, Prisma__SaturatedFatClient<SaturatedFatGetPayload<T> | null >>

    /**
     * Find zero or more SaturatedFats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaturatedFatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SaturatedFats
     * const saturatedFats = await prisma.saturatedFat.findMany()
     * 
     * // Get first 10 SaturatedFats
     * const saturatedFats = await prisma.saturatedFat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saturatedFatWithIdOnly = await prisma.saturatedFat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SaturatedFatFindManyArgs>(
      args?: SelectSubset<T, SaturatedFatFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SaturatedFat>>, PrismaPromise<Array<SaturatedFatGetPayload<T>>>>

    /**
     * Create a SaturatedFat.
     * @param {SaturatedFatCreateArgs} args - Arguments to create a SaturatedFat.
     * @example
     * // Create one SaturatedFat
     * const SaturatedFat = await prisma.saturatedFat.create({
     *   data: {
     *     // ... data to create a SaturatedFat
     *   }
     * })
     * 
    **/
    create<T extends SaturatedFatCreateArgs>(
      args: SelectSubset<T, SaturatedFatCreateArgs>
    ): CheckSelect<T, Prisma__SaturatedFatClient<SaturatedFat>, Prisma__SaturatedFatClient<SaturatedFatGetPayload<T>>>

    /**
     * Create many SaturatedFats.
     *     @param {SaturatedFatCreateManyArgs} args - Arguments to create many SaturatedFats.
     *     @example
     *     // Create many SaturatedFats
     *     const saturatedFat = await prisma.saturatedFat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SaturatedFatCreateManyArgs>(
      args?: SelectSubset<T, SaturatedFatCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SaturatedFat.
     * @param {SaturatedFatDeleteArgs} args - Arguments to delete one SaturatedFat.
     * @example
     * // Delete one SaturatedFat
     * const SaturatedFat = await prisma.saturatedFat.delete({
     *   where: {
     *     // ... filter to delete one SaturatedFat
     *   }
     * })
     * 
    **/
    delete<T extends SaturatedFatDeleteArgs>(
      args: SelectSubset<T, SaturatedFatDeleteArgs>
    ): CheckSelect<T, Prisma__SaturatedFatClient<SaturatedFat>, Prisma__SaturatedFatClient<SaturatedFatGetPayload<T>>>

    /**
     * Update one SaturatedFat.
     * @param {SaturatedFatUpdateArgs} args - Arguments to update one SaturatedFat.
     * @example
     * // Update one SaturatedFat
     * const saturatedFat = await prisma.saturatedFat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SaturatedFatUpdateArgs>(
      args: SelectSubset<T, SaturatedFatUpdateArgs>
    ): CheckSelect<T, Prisma__SaturatedFatClient<SaturatedFat>, Prisma__SaturatedFatClient<SaturatedFatGetPayload<T>>>

    /**
     * Delete zero or more SaturatedFats.
     * @param {SaturatedFatDeleteManyArgs} args - Arguments to filter SaturatedFats to delete.
     * @example
     * // Delete a few SaturatedFats
     * const { count } = await prisma.saturatedFat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SaturatedFatDeleteManyArgs>(
      args?: SelectSubset<T, SaturatedFatDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SaturatedFats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaturatedFatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SaturatedFats
     * const saturatedFat = await prisma.saturatedFat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SaturatedFatUpdateManyArgs>(
      args: SelectSubset<T, SaturatedFatUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SaturatedFat.
     * @param {SaturatedFatUpsertArgs} args - Arguments to update or create a SaturatedFat.
     * @example
     * // Update or create a SaturatedFat
     * const saturatedFat = await prisma.saturatedFat.upsert({
     *   create: {
     *     // ... data to create a SaturatedFat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SaturatedFat we want to update
     *   }
     * })
    **/
    upsert<T extends SaturatedFatUpsertArgs>(
      args: SelectSubset<T, SaturatedFatUpsertArgs>
    ): CheckSelect<T, Prisma__SaturatedFatClient<SaturatedFat>, Prisma__SaturatedFatClient<SaturatedFatGetPayload<T>>>

    /**
     * Count the number of SaturatedFats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaturatedFatCountArgs} args - Arguments to filter SaturatedFats to count.
     * @example
     * // Count the number of SaturatedFats
     * const count = await prisma.saturatedFat.count({
     *   where: {
     *     // ... the filter for the SaturatedFats we want to count
     *   }
     * })
    **/
    count<T extends SaturatedFatCountArgs>(
      args?: Subset<T, SaturatedFatCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaturatedFatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SaturatedFat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaturatedFatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaturatedFatAggregateArgs>(args: Subset<T, SaturatedFatAggregateArgs>): PrismaPromise<GetSaturatedFatAggregateType<T>>

    /**
     * Group by SaturatedFat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaturatedFatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaturatedFatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaturatedFatGroupByArgs['orderBy'] }
        : { orderBy?: SaturatedFatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaturatedFatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaturatedFatGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SaturatedFat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SaturatedFatClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    fat<T extends FatArgs = {}>(args?: Subset<T, FatArgs>): CheckSelect<T, Prisma__FatClient<Fat | null >, Prisma__FatClient<FatGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SaturatedFat findUnique
   */
  export type SaturatedFatFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SaturatedFat
     * 
    **/
    select?: SaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaturatedFatInclude | null
    /**
     * Throw an Error if a SaturatedFat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SaturatedFat to fetch.
     * 
    **/
    where: SaturatedFatWhereUniqueInput
  }


  /**
   * SaturatedFat findFirst
   */
  export type SaturatedFatFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SaturatedFat
     * 
    **/
    select?: SaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaturatedFatInclude | null
    /**
     * Throw an Error if a SaturatedFat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SaturatedFat to fetch.
     * 
    **/
    where?: SaturatedFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaturatedFats to fetch.
     * 
    **/
    orderBy?: Enumerable<SaturatedFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SaturatedFats.
     * 
    **/
    cursor?: SaturatedFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaturatedFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaturatedFats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SaturatedFats.
     * 
    **/
    distinct?: Enumerable<SaturatedFatScalarFieldEnum>
  }


  /**
   * SaturatedFat findMany
   */
  export type SaturatedFatFindManyArgs = {
    /**
     * Select specific fields to fetch from the SaturatedFat
     * 
    **/
    select?: SaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaturatedFatInclude | null
    /**
     * Filter, which SaturatedFats to fetch.
     * 
    **/
    where?: SaturatedFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SaturatedFats to fetch.
     * 
    **/
    orderBy?: Enumerable<SaturatedFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SaturatedFats.
     * 
    **/
    cursor?: SaturatedFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SaturatedFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SaturatedFats.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SaturatedFatScalarFieldEnum>
  }


  /**
   * SaturatedFat create
   */
  export type SaturatedFatCreateArgs = {
    /**
     * Select specific fields to fetch from the SaturatedFat
     * 
    **/
    select?: SaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaturatedFatInclude | null
    /**
     * The data needed to create a SaturatedFat.
     * 
    **/
    data: XOR<SaturatedFatCreateInput, SaturatedFatUncheckedCreateInput>
  }


  /**
   * SaturatedFat createMany
   */
  export type SaturatedFatCreateManyArgs = {
    /**
     * The data used to create many SaturatedFats.
     * 
    **/
    data: Enumerable<SaturatedFatCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SaturatedFat update
   */
  export type SaturatedFatUpdateArgs = {
    /**
     * Select specific fields to fetch from the SaturatedFat
     * 
    **/
    select?: SaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaturatedFatInclude | null
    /**
     * The data needed to update a SaturatedFat.
     * 
    **/
    data: XOR<SaturatedFatUpdateInput, SaturatedFatUncheckedUpdateInput>
    /**
     * Choose, which SaturatedFat to update.
     * 
    **/
    where: SaturatedFatWhereUniqueInput
  }


  /**
   * SaturatedFat updateMany
   */
  export type SaturatedFatUpdateManyArgs = {
    /**
     * The data used to update SaturatedFats.
     * 
    **/
    data: XOR<SaturatedFatUpdateManyMutationInput, SaturatedFatUncheckedUpdateManyInput>
    /**
     * Filter which SaturatedFats to update
     * 
    **/
    where?: SaturatedFatWhereInput
  }


  /**
   * SaturatedFat upsert
   */
  export type SaturatedFatUpsertArgs = {
    /**
     * Select specific fields to fetch from the SaturatedFat
     * 
    **/
    select?: SaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaturatedFatInclude | null
    /**
     * The filter to search for the SaturatedFat to update in case it exists.
     * 
    **/
    where: SaturatedFatWhereUniqueInput
    /**
     * In case the SaturatedFat found by the `where` argument doesn't exist, create a new SaturatedFat with this data.
     * 
    **/
    create: XOR<SaturatedFatCreateInput, SaturatedFatUncheckedCreateInput>
    /**
     * In case the SaturatedFat was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SaturatedFatUpdateInput, SaturatedFatUncheckedUpdateInput>
  }


  /**
   * SaturatedFat delete
   */
  export type SaturatedFatDeleteArgs = {
    /**
     * Select specific fields to fetch from the SaturatedFat
     * 
    **/
    select?: SaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaturatedFatInclude | null
    /**
     * Filter which SaturatedFat to delete.
     * 
    **/
    where: SaturatedFatWhereUniqueInput
  }


  /**
   * SaturatedFat deleteMany
   */
  export type SaturatedFatDeleteManyArgs = {
    /**
     * Filter which SaturatedFats to delete
     * 
    **/
    where?: SaturatedFatWhereInput
  }


  /**
   * SaturatedFat without action
   */
  export type SaturatedFatArgs = {
    /**
     * Select specific fields to fetch from the SaturatedFat
     * 
    **/
    select?: SaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaturatedFatInclude | null
  }



  /**
   * Model MonosaturatedFat
   */


  export type AggregateMonosaturatedFat = {
    _count: MonosaturatedFatCountAggregateOutputType | null
    _avg: MonosaturatedFatAvgAggregateOutputType | null
    _sum: MonosaturatedFatSumAggregateOutputType | null
    _min: MonosaturatedFatMinAggregateOutputType | null
    _max: MonosaturatedFatMaxAggregateOutputType | null
  }

  export type MonosaturatedFatAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type MonosaturatedFatSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type MonosaturatedFatMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type MonosaturatedFatMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type MonosaturatedFatCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type MonosaturatedFatAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type MonosaturatedFatSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type MonosaturatedFatMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type MonosaturatedFatMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type MonosaturatedFatCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type MonosaturatedFatAggregateArgs = {
    /**
     * Filter which MonosaturatedFat to aggregate.
     * 
    **/
    where?: MonosaturatedFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonosaturatedFats to fetch.
     * 
    **/
    orderBy?: Enumerable<MonosaturatedFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MonosaturatedFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonosaturatedFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonosaturatedFats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MonosaturatedFats
    **/
    _count?: true | MonosaturatedFatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MonosaturatedFatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MonosaturatedFatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MonosaturatedFatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MonosaturatedFatMaxAggregateInputType
  }

  export type GetMonosaturatedFatAggregateType<T extends MonosaturatedFatAggregateArgs> = {
        [P in keyof T & keyof AggregateMonosaturatedFat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMonosaturatedFat[P]>
      : GetScalarType<T[P], AggregateMonosaturatedFat[P]>
  }




  export type MonosaturatedFatGroupByArgs = {
    where?: MonosaturatedFatWhereInput
    orderBy?: Enumerable<MonosaturatedFatOrderByWithAggregationInput>
    by: Array<MonosaturatedFatScalarFieldEnum>
    having?: MonosaturatedFatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MonosaturatedFatCountAggregateInputType | true
    _avg?: MonosaturatedFatAvgAggregateInputType
    _sum?: MonosaturatedFatSumAggregateInputType
    _min?: MonosaturatedFatMinAggregateInputType
    _max?: MonosaturatedFatMaxAggregateInputType
  }


  export type MonosaturatedFatGroupByOutputType = {
    id: number
    measurementId: number
    _count: MonosaturatedFatCountAggregateOutputType | null
    _avg: MonosaturatedFatAvgAggregateOutputType | null
    _sum: MonosaturatedFatSumAggregateOutputType | null
    _min: MonosaturatedFatMinAggregateOutputType | null
    _max: MonosaturatedFatMaxAggregateOutputType | null
  }

  type GetMonosaturatedFatGroupByPayload<T extends MonosaturatedFatGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MonosaturatedFatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MonosaturatedFatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MonosaturatedFatGroupByOutputType[P]>
            : GetScalarType<T[P], MonosaturatedFatGroupByOutputType[P]>
        }
      >
    >


  export type MonosaturatedFatSelect = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    fat?: boolean | FatArgs
    measurementId?: boolean
  }

  export type MonosaturatedFatInclude = {
    measurement?: boolean | MeasurementArgs
    fat?: boolean | FatArgs
  }

  export type MonosaturatedFatGetPayload<
    S extends boolean | null | undefined | MonosaturatedFatArgs,
    U = keyof S
      > = S extends true
        ? MonosaturatedFat
    : S extends undefined
    ? never
    : S extends MonosaturatedFatArgs | MonosaturatedFatFindManyArgs
    ?'include' extends U
    ? MonosaturatedFat  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'fat' ? FatGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'fat' ? FatGetPayload<S['select'][P]> | null :  P extends keyof MonosaturatedFat ? MonosaturatedFat[P] : never
  } 
    : MonosaturatedFat
  : MonosaturatedFat


  type MonosaturatedFatCountArgs = Merge<
    Omit<MonosaturatedFatFindManyArgs, 'select' | 'include'> & {
      select?: MonosaturatedFatCountAggregateInputType | true
    }
  >

  export interface MonosaturatedFatDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one MonosaturatedFat that matches the filter.
     * @param {MonosaturatedFatFindUniqueArgs} args - Arguments to find a MonosaturatedFat
     * @example
     * // Get one MonosaturatedFat
     * const monosaturatedFat = await prisma.monosaturatedFat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MonosaturatedFatFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MonosaturatedFatFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'MonosaturatedFat'> extends True ? CheckSelect<T, Prisma__MonosaturatedFatClient<MonosaturatedFat>, Prisma__MonosaturatedFatClient<MonosaturatedFatGetPayload<T>>> : CheckSelect<T, Prisma__MonosaturatedFatClient<MonosaturatedFat | null >, Prisma__MonosaturatedFatClient<MonosaturatedFatGetPayload<T> | null >>

    /**
     * Find the first MonosaturatedFat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonosaturatedFatFindFirstArgs} args - Arguments to find a MonosaturatedFat
     * @example
     * // Get one MonosaturatedFat
     * const monosaturatedFat = await prisma.monosaturatedFat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MonosaturatedFatFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MonosaturatedFatFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'MonosaturatedFat'> extends True ? CheckSelect<T, Prisma__MonosaturatedFatClient<MonosaturatedFat>, Prisma__MonosaturatedFatClient<MonosaturatedFatGetPayload<T>>> : CheckSelect<T, Prisma__MonosaturatedFatClient<MonosaturatedFat | null >, Prisma__MonosaturatedFatClient<MonosaturatedFatGetPayload<T> | null >>

    /**
     * Find zero or more MonosaturatedFats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonosaturatedFatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MonosaturatedFats
     * const monosaturatedFats = await prisma.monosaturatedFat.findMany()
     * 
     * // Get first 10 MonosaturatedFats
     * const monosaturatedFats = await prisma.monosaturatedFat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const monosaturatedFatWithIdOnly = await prisma.monosaturatedFat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MonosaturatedFatFindManyArgs>(
      args?: SelectSubset<T, MonosaturatedFatFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<MonosaturatedFat>>, PrismaPromise<Array<MonosaturatedFatGetPayload<T>>>>

    /**
     * Create a MonosaturatedFat.
     * @param {MonosaturatedFatCreateArgs} args - Arguments to create a MonosaturatedFat.
     * @example
     * // Create one MonosaturatedFat
     * const MonosaturatedFat = await prisma.monosaturatedFat.create({
     *   data: {
     *     // ... data to create a MonosaturatedFat
     *   }
     * })
     * 
    **/
    create<T extends MonosaturatedFatCreateArgs>(
      args: SelectSubset<T, MonosaturatedFatCreateArgs>
    ): CheckSelect<T, Prisma__MonosaturatedFatClient<MonosaturatedFat>, Prisma__MonosaturatedFatClient<MonosaturatedFatGetPayload<T>>>

    /**
     * Create many MonosaturatedFats.
     *     @param {MonosaturatedFatCreateManyArgs} args - Arguments to create many MonosaturatedFats.
     *     @example
     *     // Create many MonosaturatedFats
     *     const monosaturatedFat = await prisma.monosaturatedFat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MonosaturatedFatCreateManyArgs>(
      args?: SelectSubset<T, MonosaturatedFatCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a MonosaturatedFat.
     * @param {MonosaturatedFatDeleteArgs} args - Arguments to delete one MonosaturatedFat.
     * @example
     * // Delete one MonosaturatedFat
     * const MonosaturatedFat = await prisma.monosaturatedFat.delete({
     *   where: {
     *     // ... filter to delete one MonosaturatedFat
     *   }
     * })
     * 
    **/
    delete<T extends MonosaturatedFatDeleteArgs>(
      args: SelectSubset<T, MonosaturatedFatDeleteArgs>
    ): CheckSelect<T, Prisma__MonosaturatedFatClient<MonosaturatedFat>, Prisma__MonosaturatedFatClient<MonosaturatedFatGetPayload<T>>>

    /**
     * Update one MonosaturatedFat.
     * @param {MonosaturatedFatUpdateArgs} args - Arguments to update one MonosaturatedFat.
     * @example
     * // Update one MonosaturatedFat
     * const monosaturatedFat = await prisma.monosaturatedFat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MonosaturatedFatUpdateArgs>(
      args: SelectSubset<T, MonosaturatedFatUpdateArgs>
    ): CheckSelect<T, Prisma__MonosaturatedFatClient<MonosaturatedFat>, Prisma__MonosaturatedFatClient<MonosaturatedFatGetPayload<T>>>

    /**
     * Delete zero or more MonosaturatedFats.
     * @param {MonosaturatedFatDeleteManyArgs} args - Arguments to filter MonosaturatedFats to delete.
     * @example
     * // Delete a few MonosaturatedFats
     * const { count } = await prisma.monosaturatedFat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MonosaturatedFatDeleteManyArgs>(
      args?: SelectSubset<T, MonosaturatedFatDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more MonosaturatedFats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonosaturatedFatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MonosaturatedFats
     * const monosaturatedFat = await prisma.monosaturatedFat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MonosaturatedFatUpdateManyArgs>(
      args: SelectSubset<T, MonosaturatedFatUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one MonosaturatedFat.
     * @param {MonosaturatedFatUpsertArgs} args - Arguments to update or create a MonosaturatedFat.
     * @example
     * // Update or create a MonosaturatedFat
     * const monosaturatedFat = await prisma.monosaturatedFat.upsert({
     *   create: {
     *     // ... data to create a MonosaturatedFat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MonosaturatedFat we want to update
     *   }
     * })
    **/
    upsert<T extends MonosaturatedFatUpsertArgs>(
      args: SelectSubset<T, MonosaturatedFatUpsertArgs>
    ): CheckSelect<T, Prisma__MonosaturatedFatClient<MonosaturatedFat>, Prisma__MonosaturatedFatClient<MonosaturatedFatGetPayload<T>>>

    /**
     * Count the number of MonosaturatedFats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonosaturatedFatCountArgs} args - Arguments to filter MonosaturatedFats to count.
     * @example
     * // Count the number of MonosaturatedFats
     * const count = await prisma.monosaturatedFat.count({
     *   where: {
     *     // ... the filter for the MonosaturatedFats we want to count
     *   }
     * })
    **/
    count<T extends MonosaturatedFatCountArgs>(
      args?: Subset<T, MonosaturatedFatCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MonosaturatedFatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MonosaturatedFat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonosaturatedFatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MonosaturatedFatAggregateArgs>(args: Subset<T, MonosaturatedFatAggregateArgs>): PrismaPromise<GetMonosaturatedFatAggregateType<T>>

    /**
     * Group by MonosaturatedFat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MonosaturatedFatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MonosaturatedFatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MonosaturatedFatGroupByArgs['orderBy'] }
        : { orderBy?: MonosaturatedFatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MonosaturatedFatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMonosaturatedFatGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for MonosaturatedFat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MonosaturatedFatClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    fat<T extends FatArgs = {}>(args?: Subset<T, FatArgs>): CheckSelect<T, Prisma__FatClient<Fat | null >, Prisma__FatClient<FatGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * MonosaturatedFat findUnique
   */
  export type MonosaturatedFatFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the MonosaturatedFat
     * 
    **/
    select?: MonosaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MonosaturatedFatInclude | null
    /**
     * Throw an Error if a MonosaturatedFat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MonosaturatedFat to fetch.
     * 
    **/
    where: MonosaturatedFatWhereUniqueInput
  }


  /**
   * MonosaturatedFat findFirst
   */
  export type MonosaturatedFatFindFirstArgs = {
    /**
     * Select specific fields to fetch from the MonosaturatedFat
     * 
    **/
    select?: MonosaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MonosaturatedFatInclude | null
    /**
     * Throw an Error if a MonosaturatedFat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which MonosaturatedFat to fetch.
     * 
    **/
    where?: MonosaturatedFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonosaturatedFats to fetch.
     * 
    **/
    orderBy?: Enumerable<MonosaturatedFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MonosaturatedFats.
     * 
    **/
    cursor?: MonosaturatedFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonosaturatedFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonosaturatedFats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MonosaturatedFats.
     * 
    **/
    distinct?: Enumerable<MonosaturatedFatScalarFieldEnum>
  }


  /**
   * MonosaturatedFat findMany
   */
  export type MonosaturatedFatFindManyArgs = {
    /**
     * Select specific fields to fetch from the MonosaturatedFat
     * 
    **/
    select?: MonosaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MonosaturatedFatInclude | null
    /**
     * Filter, which MonosaturatedFats to fetch.
     * 
    **/
    where?: MonosaturatedFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MonosaturatedFats to fetch.
     * 
    **/
    orderBy?: Enumerable<MonosaturatedFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MonosaturatedFats.
     * 
    **/
    cursor?: MonosaturatedFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MonosaturatedFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MonosaturatedFats.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MonosaturatedFatScalarFieldEnum>
  }


  /**
   * MonosaturatedFat create
   */
  export type MonosaturatedFatCreateArgs = {
    /**
     * Select specific fields to fetch from the MonosaturatedFat
     * 
    **/
    select?: MonosaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MonosaturatedFatInclude | null
    /**
     * The data needed to create a MonosaturatedFat.
     * 
    **/
    data: XOR<MonosaturatedFatCreateInput, MonosaturatedFatUncheckedCreateInput>
  }


  /**
   * MonosaturatedFat createMany
   */
  export type MonosaturatedFatCreateManyArgs = {
    /**
     * The data used to create many MonosaturatedFats.
     * 
    **/
    data: Enumerable<MonosaturatedFatCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * MonosaturatedFat update
   */
  export type MonosaturatedFatUpdateArgs = {
    /**
     * Select specific fields to fetch from the MonosaturatedFat
     * 
    **/
    select?: MonosaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MonosaturatedFatInclude | null
    /**
     * The data needed to update a MonosaturatedFat.
     * 
    **/
    data: XOR<MonosaturatedFatUpdateInput, MonosaturatedFatUncheckedUpdateInput>
    /**
     * Choose, which MonosaturatedFat to update.
     * 
    **/
    where: MonosaturatedFatWhereUniqueInput
  }


  /**
   * MonosaturatedFat updateMany
   */
  export type MonosaturatedFatUpdateManyArgs = {
    /**
     * The data used to update MonosaturatedFats.
     * 
    **/
    data: XOR<MonosaturatedFatUpdateManyMutationInput, MonosaturatedFatUncheckedUpdateManyInput>
    /**
     * Filter which MonosaturatedFats to update
     * 
    **/
    where?: MonosaturatedFatWhereInput
  }


  /**
   * MonosaturatedFat upsert
   */
  export type MonosaturatedFatUpsertArgs = {
    /**
     * Select specific fields to fetch from the MonosaturatedFat
     * 
    **/
    select?: MonosaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MonosaturatedFatInclude | null
    /**
     * The filter to search for the MonosaturatedFat to update in case it exists.
     * 
    **/
    where: MonosaturatedFatWhereUniqueInput
    /**
     * In case the MonosaturatedFat found by the `where` argument doesn't exist, create a new MonosaturatedFat with this data.
     * 
    **/
    create: XOR<MonosaturatedFatCreateInput, MonosaturatedFatUncheckedCreateInput>
    /**
     * In case the MonosaturatedFat was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MonosaturatedFatUpdateInput, MonosaturatedFatUncheckedUpdateInput>
  }


  /**
   * MonosaturatedFat delete
   */
  export type MonosaturatedFatDeleteArgs = {
    /**
     * Select specific fields to fetch from the MonosaturatedFat
     * 
    **/
    select?: MonosaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MonosaturatedFatInclude | null
    /**
     * Filter which MonosaturatedFat to delete.
     * 
    **/
    where: MonosaturatedFatWhereUniqueInput
  }


  /**
   * MonosaturatedFat deleteMany
   */
  export type MonosaturatedFatDeleteManyArgs = {
    /**
     * Filter which MonosaturatedFats to delete
     * 
    **/
    where?: MonosaturatedFatWhereInput
  }


  /**
   * MonosaturatedFat without action
   */
  export type MonosaturatedFatArgs = {
    /**
     * Select specific fields to fetch from the MonosaturatedFat
     * 
    **/
    select?: MonosaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MonosaturatedFatInclude | null
  }



  /**
   * Model PolyunsaturatedFat
   */


  export type AggregatePolyunsaturatedFat = {
    _count: PolyunsaturatedFatCountAggregateOutputType | null
    _avg: PolyunsaturatedFatAvgAggregateOutputType | null
    _sum: PolyunsaturatedFatSumAggregateOutputType | null
    _min: PolyunsaturatedFatMinAggregateOutputType | null
    _max: PolyunsaturatedFatMaxAggregateOutputType | null
  }

  export type PolyunsaturatedFatAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type PolyunsaturatedFatSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type PolyunsaturatedFatMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type PolyunsaturatedFatMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type PolyunsaturatedFatCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type PolyunsaturatedFatAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type PolyunsaturatedFatSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type PolyunsaturatedFatMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type PolyunsaturatedFatMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type PolyunsaturatedFatCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type PolyunsaturatedFatAggregateArgs = {
    /**
     * Filter which PolyunsaturatedFat to aggregate.
     * 
    **/
    where?: PolyunsaturatedFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolyunsaturatedFats to fetch.
     * 
    **/
    orderBy?: Enumerable<PolyunsaturatedFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PolyunsaturatedFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolyunsaturatedFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolyunsaturatedFats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PolyunsaturatedFats
    **/
    _count?: true | PolyunsaturatedFatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PolyunsaturatedFatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PolyunsaturatedFatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PolyunsaturatedFatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PolyunsaturatedFatMaxAggregateInputType
  }

  export type GetPolyunsaturatedFatAggregateType<T extends PolyunsaturatedFatAggregateArgs> = {
        [P in keyof T & keyof AggregatePolyunsaturatedFat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePolyunsaturatedFat[P]>
      : GetScalarType<T[P], AggregatePolyunsaturatedFat[P]>
  }




  export type PolyunsaturatedFatGroupByArgs = {
    where?: PolyunsaturatedFatWhereInput
    orderBy?: Enumerable<PolyunsaturatedFatOrderByWithAggregationInput>
    by: Array<PolyunsaturatedFatScalarFieldEnum>
    having?: PolyunsaturatedFatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PolyunsaturatedFatCountAggregateInputType | true
    _avg?: PolyunsaturatedFatAvgAggregateInputType
    _sum?: PolyunsaturatedFatSumAggregateInputType
    _min?: PolyunsaturatedFatMinAggregateInputType
    _max?: PolyunsaturatedFatMaxAggregateInputType
  }


  export type PolyunsaturatedFatGroupByOutputType = {
    id: number
    measurementId: number
    _count: PolyunsaturatedFatCountAggregateOutputType | null
    _avg: PolyunsaturatedFatAvgAggregateOutputType | null
    _sum: PolyunsaturatedFatSumAggregateOutputType | null
    _min: PolyunsaturatedFatMinAggregateOutputType | null
    _max: PolyunsaturatedFatMaxAggregateOutputType | null
  }

  type GetPolyunsaturatedFatGroupByPayload<T extends PolyunsaturatedFatGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PolyunsaturatedFatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PolyunsaturatedFatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PolyunsaturatedFatGroupByOutputType[P]>
            : GetScalarType<T[P], PolyunsaturatedFatGroupByOutputType[P]>
        }
      >
    >


  export type PolyunsaturatedFatSelect = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    fat?: boolean | FatArgs
    measurementId?: boolean
  }

  export type PolyunsaturatedFatInclude = {
    measurement?: boolean | MeasurementArgs
    fat?: boolean | FatArgs
  }

  export type PolyunsaturatedFatGetPayload<
    S extends boolean | null | undefined | PolyunsaturatedFatArgs,
    U = keyof S
      > = S extends true
        ? PolyunsaturatedFat
    : S extends undefined
    ? never
    : S extends PolyunsaturatedFatArgs | PolyunsaturatedFatFindManyArgs
    ?'include' extends U
    ? PolyunsaturatedFat  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'fat' ? FatGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'fat' ? FatGetPayload<S['select'][P]> | null :  P extends keyof PolyunsaturatedFat ? PolyunsaturatedFat[P] : never
  } 
    : PolyunsaturatedFat
  : PolyunsaturatedFat


  type PolyunsaturatedFatCountArgs = Merge<
    Omit<PolyunsaturatedFatFindManyArgs, 'select' | 'include'> & {
      select?: PolyunsaturatedFatCountAggregateInputType | true
    }
  >

  export interface PolyunsaturatedFatDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one PolyunsaturatedFat that matches the filter.
     * @param {PolyunsaturatedFatFindUniqueArgs} args - Arguments to find a PolyunsaturatedFat
     * @example
     * // Get one PolyunsaturatedFat
     * const polyunsaturatedFat = await prisma.polyunsaturatedFat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PolyunsaturatedFatFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PolyunsaturatedFatFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'PolyunsaturatedFat'> extends True ? CheckSelect<T, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFat>, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFatGetPayload<T>>> : CheckSelect<T, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFat | null >, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFatGetPayload<T> | null >>

    /**
     * Find the first PolyunsaturatedFat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolyunsaturatedFatFindFirstArgs} args - Arguments to find a PolyunsaturatedFat
     * @example
     * // Get one PolyunsaturatedFat
     * const polyunsaturatedFat = await prisma.polyunsaturatedFat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PolyunsaturatedFatFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PolyunsaturatedFatFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'PolyunsaturatedFat'> extends True ? CheckSelect<T, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFat>, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFatGetPayload<T>>> : CheckSelect<T, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFat | null >, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFatGetPayload<T> | null >>

    /**
     * Find zero or more PolyunsaturatedFats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolyunsaturatedFatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PolyunsaturatedFats
     * const polyunsaturatedFats = await prisma.polyunsaturatedFat.findMany()
     * 
     * // Get first 10 PolyunsaturatedFats
     * const polyunsaturatedFats = await prisma.polyunsaturatedFat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const polyunsaturatedFatWithIdOnly = await prisma.polyunsaturatedFat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PolyunsaturatedFatFindManyArgs>(
      args?: SelectSubset<T, PolyunsaturatedFatFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<PolyunsaturatedFat>>, PrismaPromise<Array<PolyunsaturatedFatGetPayload<T>>>>

    /**
     * Create a PolyunsaturatedFat.
     * @param {PolyunsaturatedFatCreateArgs} args - Arguments to create a PolyunsaturatedFat.
     * @example
     * // Create one PolyunsaturatedFat
     * const PolyunsaturatedFat = await prisma.polyunsaturatedFat.create({
     *   data: {
     *     // ... data to create a PolyunsaturatedFat
     *   }
     * })
     * 
    **/
    create<T extends PolyunsaturatedFatCreateArgs>(
      args: SelectSubset<T, PolyunsaturatedFatCreateArgs>
    ): CheckSelect<T, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFat>, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFatGetPayload<T>>>

    /**
     * Create many PolyunsaturatedFats.
     *     @param {PolyunsaturatedFatCreateManyArgs} args - Arguments to create many PolyunsaturatedFats.
     *     @example
     *     // Create many PolyunsaturatedFats
     *     const polyunsaturatedFat = await prisma.polyunsaturatedFat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PolyunsaturatedFatCreateManyArgs>(
      args?: SelectSubset<T, PolyunsaturatedFatCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a PolyunsaturatedFat.
     * @param {PolyunsaturatedFatDeleteArgs} args - Arguments to delete one PolyunsaturatedFat.
     * @example
     * // Delete one PolyunsaturatedFat
     * const PolyunsaturatedFat = await prisma.polyunsaturatedFat.delete({
     *   where: {
     *     // ... filter to delete one PolyunsaturatedFat
     *   }
     * })
     * 
    **/
    delete<T extends PolyunsaturatedFatDeleteArgs>(
      args: SelectSubset<T, PolyunsaturatedFatDeleteArgs>
    ): CheckSelect<T, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFat>, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFatGetPayload<T>>>

    /**
     * Update one PolyunsaturatedFat.
     * @param {PolyunsaturatedFatUpdateArgs} args - Arguments to update one PolyunsaturatedFat.
     * @example
     * // Update one PolyunsaturatedFat
     * const polyunsaturatedFat = await prisma.polyunsaturatedFat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PolyunsaturatedFatUpdateArgs>(
      args: SelectSubset<T, PolyunsaturatedFatUpdateArgs>
    ): CheckSelect<T, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFat>, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFatGetPayload<T>>>

    /**
     * Delete zero or more PolyunsaturatedFats.
     * @param {PolyunsaturatedFatDeleteManyArgs} args - Arguments to filter PolyunsaturatedFats to delete.
     * @example
     * // Delete a few PolyunsaturatedFats
     * const { count } = await prisma.polyunsaturatedFat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PolyunsaturatedFatDeleteManyArgs>(
      args?: SelectSubset<T, PolyunsaturatedFatDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more PolyunsaturatedFats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolyunsaturatedFatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PolyunsaturatedFats
     * const polyunsaturatedFat = await prisma.polyunsaturatedFat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PolyunsaturatedFatUpdateManyArgs>(
      args: SelectSubset<T, PolyunsaturatedFatUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one PolyunsaturatedFat.
     * @param {PolyunsaturatedFatUpsertArgs} args - Arguments to update or create a PolyunsaturatedFat.
     * @example
     * // Update or create a PolyunsaturatedFat
     * const polyunsaturatedFat = await prisma.polyunsaturatedFat.upsert({
     *   create: {
     *     // ... data to create a PolyunsaturatedFat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PolyunsaturatedFat we want to update
     *   }
     * })
    **/
    upsert<T extends PolyunsaturatedFatUpsertArgs>(
      args: SelectSubset<T, PolyunsaturatedFatUpsertArgs>
    ): CheckSelect<T, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFat>, Prisma__PolyunsaturatedFatClient<PolyunsaturatedFatGetPayload<T>>>

    /**
     * Count the number of PolyunsaturatedFats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolyunsaturatedFatCountArgs} args - Arguments to filter PolyunsaturatedFats to count.
     * @example
     * // Count the number of PolyunsaturatedFats
     * const count = await prisma.polyunsaturatedFat.count({
     *   where: {
     *     // ... the filter for the PolyunsaturatedFats we want to count
     *   }
     * })
    **/
    count<T extends PolyunsaturatedFatCountArgs>(
      args?: Subset<T, PolyunsaturatedFatCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PolyunsaturatedFatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PolyunsaturatedFat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolyunsaturatedFatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PolyunsaturatedFatAggregateArgs>(args: Subset<T, PolyunsaturatedFatAggregateArgs>): PrismaPromise<GetPolyunsaturatedFatAggregateType<T>>

    /**
     * Group by PolyunsaturatedFat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PolyunsaturatedFatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PolyunsaturatedFatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PolyunsaturatedFatGroupByArgs['orderBy'] }
        : { orderBy?: PolyunsaturatedFatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PolyunsaturatedFatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPolyunsaturatedFatGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for PolyunsaturatedFat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PolyunsaturatedFatClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    fat<T extends FatArgs = {}>(args?: Subset<T, FatArgs>): CheckSelect<T, Prisma__FatClient<Fat | null >, Prisma__FatClient<FatGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * PolyunsaturatedFat findUnique
   */
  export type PolyunsaturatedFatFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the PolyunsaturatedFat
     * 
    **/
    select?: PolyunsaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolyunsaturatedFatInclude | null
    /**
     * Throw an Error if a PolyunsaturatedFat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PolyunsaturatedFat to fetch.
     * 
    **/
    where: PolyunsaturatedFatWhereUniqueInput
  }


  /**
   * PolyunsaturatedFat findFirst
   */
  export type PolyunsaturatedFatFindFirstArgs = {
    /**
     * Select specific fields to fetch from the PolyunsaturatedFat
     * 
    **/
    select?: PolyunsaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolyunsaturatedFatInclude | null
    /**
     * Throw an Error if a PolyunsaturatedFat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which PolyunsaturatedFat to fetch.
     * 
    **/
    where?: PolyunsaturatedFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolyunsaturatedFats to fetch.
     * 
    **/
    orderBy?: Enumerable<PolyunsaturatedFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PolyunsaturatedFats.
     * 
    **/
    cursor?: PolyunsaturatedFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolyunsaturatedFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolyunsaturatedFats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PolyunsaturatedFats.
     * 
    **/
    distinct?: Enumerable<PolyunsaturatedFatScalarFieldEnum>
  }


  /**
   * PolyunsaturatedFat findMany
   */
  export type PolyunsaturatedFatFindManyArgs = {
    /**
     * Select specific fields to fetch from the PolyunsaturatedFat
     * 
    **/
    select?: PolyunsaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolyunsaturatedFatInclude | null
    /**
     * Filter, which PolyunsaturatedFats to fetch.
     * 
    **/
    where?: PolyunsaturatedFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PolyunsaturatedFats to fetch.
     * 
    **/
    orderBy?: Enumerable<PolyunsaturatedFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PolyunsaturatedFats.
     * 
    **/
    cursor?: PolyunsaturatedFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PolyunsaturatedFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PolyunsaturatedFats.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PolyunsaturatedFatScalarFieldEnum>
  }


  /**
   * PolyunsaturatedFat create
   */
  export type PolyunsaturatedFatCreateArgs = {
    /**
     * Select specific fields to fetch from the PolyunsaturatedFat
     * 
    **/
    select?: PolyunsaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolyunsaturatedFatInclude | null
    /**
     * The data needed to create a PolyunsaturatedFat.
     * 
    **/
    data: XOR<PolyunsaturatedFatCreateInput, PolyunsaturatedFatUncheckedCreateInput>
  }


  /**
   * PolyunsaturatedFat createMany
   */
  export type PolyunsaturatedFatCreateManyArgs = {
    /**
     * The data used to create many PolyunsaturatedFats.
     * 
    **/
    data: Enumerable<PolyunsaturatedFatCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * PolyunsaturatedFat update
   */
  export type PolyunsaturatedFatUpdateArgs = {
    /**
     * Select specific fields to fetch from the PolyunsaturatedFat
     * 
    **/
    select?: PolyunsaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolyunsaturatedFatInclude | null
    /**
     * The data needed to update a PolyunsaturatedFat.
     * 
    **/
    data: XOR<PolyunsaturatedFatUpdateInput, PolyunsaturatedFatUncheckedUpdateInput>
    /**
     * Choose, which PolyunsaturatedFat to update.
     * 
    **/
    where: PolyunsaturatedFatWhereUniqueInput
  }


  /**
   * PolyunsaturatedFat updateMany
   */
  export type PolyunsaturatedFatUpdateManyArgs = {
    /**
     * The data used to update PolyunsaturatedFats.
     * 
    **/
    data: XOR<PolyunsaturatedFatUpdateManyMutationInput, PolyunsaturatedFatUncheckedUpdateManyInput>
    /**
     * Filter which PolyunsaturatedFats to update
     * 
    **/
    where?: PolyunsaturatedFatWhereInput
  }


  /**
   * PolyunsaturatedFat upsert
   */
  export type PolyunsaturatedFatUpsertArgs = {
    /**
     * Select specific fields to fetch from the PolyunsaturatedFat
     * 
    **/
    select?: PolyunsaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolyunsaturatedFatInclude | null
    /**
     * The filter to search for the PolyunsaturatedFat to update in case it exists.
     * 
    **/
    where: PolyunsaturatedFatWhereUniqueInput
    /**
     * In case the PolyunsaturatedFat found by the `where` argument doesn't exist, create a new PolyunsaturatedFat with this data.
     * 
    **/
    create: XOR<PolyunsaturatedFatCreateInput, PolyunsaturatedFatUncheckedCreateInput>
    /**
     * In case the PolyunsaturatedFat was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PolyunsaturatedFatUpdateInput, PolyunsaturatedFatUncheckedUpdateInput>
  }


  /**
   * PolyunsaturatedFat delete
   */
  export type PolyunsaturatedFatDeleteArgs = {
    /**
     * Select specific fields to fetch from the PolyunsaturatedFat
     * 
    **/
    select?: PolyunsaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolyunsaturatedFatInclude | null
    /**
     * Filter which PolyunsaturatedFat to delete.
     * 
    **/
    where: PolyunsaturatedFatWhereUniqueInput
  }


  /**
   * PolyunsaturatedFat deleteMany
   */
  export type PolyunsaturatedFatDeleteManyArgs = {
    /**
     * Filter which PolyunsaturatedFats to delete
     * 
    **/
    where?: PolyunsaturatedFatWhereInput
  }


  /**
   * PolyunsaturatedFat without action
   */
  export type PolyunsaturatedFatArgs = {
    /**
     * Select specific fields to fetch from the PolyunsaturatedFat
     * 
    **/
    select?: PolyunsaturatedFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PolyunsaturatedFatInclude | null
  }



  /**
   * Model TransFat
   */


  export type AggregateTransFat = {
    _count: TransFatCountAggregateOutputType | null
    _avg: TransFatAvgAggregateOutputType | null
    _sum: TransFatSumAggregateOutputType | null
    _min: TransFatMinAggregateOutputType | null
    _max: TransFatMaxAggregateOutputType | null
  }

  export type TransFatAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type TransFatSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type TransFatMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type TransFatMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type TransFatCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type TransFatAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type TransFatSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type TransFatMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type TransFatMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type TransFatCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type TransFatAggregateArgs = {
    /**
     * Filter which TransFat to aggregate.
     * 
    **/
    where?: TransFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransFats to fetch.
     * 
    **/
    orderBy?: Enumerable<TransFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TransFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransFats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TransFats
    **/
    _count?: true | TransFatCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransFatAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransFatSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransFatMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransFatMaxAggregateInputType
  }

  export type GetTransFatAggregateType<T extends TransFatAggregateArgs> = {
        [P in keyof T & keyof AggregateTransFat]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransFat[P]>
      : GetScalarType<T[P], AggregateTransFat[P]>
  }




  export type TransFatGroupByArgs = {
    where?: TransFatWhereInput
    orderBy?: Enumerable<TransFatOrderByWithAggregationInput>
    by: Array<TransFatScalarFieldEnum>
    having?: TransFatScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransFatCountAggregateInputType | true
    _avg?: TransFatAvgAggregateInputType
    _sum?: TransFatSumAggregateInputType
    _min?: TransFatMinAggregateInputType
    _max?: TransFatMaxAggregateInputType
  }


  export type TransFatGroupByOutputType = {
    id: number
    measurementId: number
    _count: TransFatCountAggregateOutputType | null
    _avg: TransFatAvgAggregateOutputType | null
    _sum: TransFatSumAggregateOutputType | null
    _min: TransFatMinAggregateOutputType | null
    _max: TransFatMaxAggregateOutputType | null
  }

  type GetTransFatGroupByPayload<T extends TransFatGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TransFatGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransFatGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransFatGroupByOutputType[P]>
            : GetScalarType<T[P], TransFatGroupByOutputType[P]>
        }
      >
    >


  export type TransFatSelect = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    fat?: boolean | FatArgs
    measurementId?: boolean
  }

  export type TransFatInclude = {
    measurement?: boolean | MeasurementArgs
    fat?: boolean | FatArgs
  }

  export type TransFatGetPayload<
    S extends boolean | null | undefined | TransFatArgs,
    U = keyof S
      > = S extends true
        ? TransFat
    : S extends undefined
    ? never
    : S extends TransFatArgs | TransFatFindManyArgs
    ?'include' extends U
    ? TransFat  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'fat' ? FatGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'fat' ? FatGetPayload<S['select'][P]> | null :  P extends keyof TransFat ? TransFat[P] : never
  } 
    : TransFat
  : TransFat


  type TransFatCountArgs = Merge<
    Omit<TransFatFindManyArgs, 'select' | 'include'> & {
      select?: TransFatCountAggregateInputType | true
    }
  >

  export interface TransFatDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TransFat that matches the filter.
     * @param {TransFatFindUniqueArgs} args - Arguments to find a TransFat
     * @example
     * // Get one TransFat
     * const transFat = await prisma.transFat.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TransFatFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TransFatFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TransFat'> extends True ? CheckSelect<T, Prisma__TransFatClient<TransFat>, Prisma__TransFatClient<TransFatGetPayload<T>>> : CheckSelect<T, Prisma__TransFatClient<TransFat | null >, Prisma__TransFatClient<TransFatGetPayload<T> | null >>

    /**
     * Find the first TransFat that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransFatFindFirstArgs} args - Arguments to find a TransFat
     * @example
     * // Get one TransFat
     * const transFat = await prisma.transFat.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TransFatFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TransFatFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TransFat'> extends True ? CheckSelect<T, Prisma__TransFatClient<TransFat>, Prisma__TransFatClient<TransFatGetPayload<T>>> : CheckSelect<T, Prisma__TransFatClient<TransFat | null >, Prisma__TransFatClient<TransFatGetPayload<T> | null >>

    /**
     * Find zero or more TransFats that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransFatFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TransFats
     * const transFats = await prisma.transFat.findMany()
     * 
     * // Get first 10 TransFats
     * const transFats = await prisma.transFat.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transFatWithIdOnly = await prisma.transFat.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TransFatFindManyArgs>(
      args?: SelectSubset<T, TransFatFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TransFat>>, PrismaPromise<Array<TransFatGetPayload<T>>>>

    /**
     * Create a TransFat.
     * @param {TransFatCreateArgs} args - Arguments to create a TransFat.
     * @example
     * // Create one TransFat
     * const TransFat = await prisma.transFat.create({
     *   data: {
     *     // ... data to create a TransFat
     *   }
     * })
     * 
    **/
    create<T extends TransFatCreateArgs>(
      args: SelectSubset<T, TransFatCreateArgs>
    ): CheckSelect<T, Prisma__TransFatClient<TransFat>, Prisma__TransFatClient<TransFatGetPayload<T>>>

    /**
     * Create many TransFats.
     *     @param {TransFatCreateManyArgs} args - Arguments to create many TransFats.
     *     @example
     *     // Create many TransFats
     *     const transFat = await prisma.transFat.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TransFatCreateManyArgs>(
      args?: SelectSubset<T, TransFatCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TransFat.
     * @param {TransFatDeleteArgs} args - Arguments to delete one TransFat.
     * @example
     * // Delete one TransFat
     * const TransFat = await prisma.transFat.delete({
     *   where: {
     *     // ... filter to delete one TransFat
     *   }
     * })
     * 
    **/
    delete<T extends TransFatDeleteArgs>(
      args: SelectSubset<T, TransFatDeleteArgs>
    ): CheckSelect<T, Prisma__TransFatClient<TransFat>, Prisma__TransFatClient<TransFatGetPayload<T>>>

    /**
     * Update one TransFat.
     * @param {TransFatUpdateArgs} args - Arguments to update one TransFat.
     * @example
     * // Update one TransFat
     * const transFat = await prisma.transFat.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TransFatUpdateArgs>(
      args: SelectSubset<T, TransFatUpdateArgs>
    ): CheckSelect<T, Prisma__TransFatClient<TransFat>, Prisma__TransFatClient<TransFatGetPayload<T>>>

    /**
     * Delete zero or more TransFats.
     * @param {TransFatDeleteManyArgs} args - Arguments to filter TransFats to delete.
     * @example
     * // Delete a few TransFats
     * const { count } = await prisma.transFat.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TransFatDeleteManyArgs>(
      args?: SelectSubset<T, TransFatDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TransFats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransFatUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TransFats
     * const transFat = await prisma.transFat.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TransFatUpdateManyArgs>(
      args: SelectSubset<T, TransFatUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TransFat.
     * @param {TransFatUpsertArgs} args - Arguments to update or create a TransFat.
     * @example
     * // Update or create a TransFat
     * const transFat = await prisma.transFat.upsert({
     *   create: {
     *     // ... data to create a TransFat
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TransFat we want to update
     *   }
     * })
    **/
    upsert<T extends TransFatUpsertArgs>(
      args: SelectSubset<T, TransFatUpsertArgs>
    ): CheckSelect<T, Prisma__TransFatClient<TransFat>, Prisma__TransFatClient<TransFatGetPayload<T>>>

    /**
     * Count the number of TransFats.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransFatCountArgs} args - Arguments to filter TransFats to count.
     * @example
     * // Count the number of TransFats
     * const count = await prisma.transFat.count({
     *   where: {
     *     // ... the filter for the TransFats we want to count
     *   }
     * })
    **/
    count<T extends TransFatCountArgs>(
      args?: Subset<T, TransFatCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransFatCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TransFat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransFatAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransFatAggregateArgs>(args: Subset<T, TransFatAggregateArgs>): PrismaPromise<GetTransFatAggregateType<T>>

    /**
     * Group by TransFat.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransFatGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransFatGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransFatGroupByArgs['orderBy'] }
        : { orderBy?: TransFatGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransFatGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransFatGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TransFat.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TransFatClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    fat<T extends FatArgs = {}>(args?: Subset<T, FatArgs>): CheckSelect<T, Prisma__FatClient<Fat | null >, Prisma__FatClient<FatGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TransFat findUnique
   */
  export type TransFatFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TransFat
     * 
    **/
    select?: TransFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransFatInclude | null
    /**
     * Throw an Error if a TransFat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TransFat to fetch.
     * 
    **/
    where: TransFatWhereUniqueInput
  }


  /**
   * TransFat findFirst
   */
  export type TransFatFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TransFat
     * 
    **/
    select?: TransFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransFatInclude | null
    /**
     * Throw an Error if a TransFat can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TransFat to fetch.
     * 
    **/
    where?: TransFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransFats to fetch.
     * 
    **/
    orderBy?: Enumerable<TransFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TransFats.
     * 
    **/
    cursor?: TransFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransFats.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TransFats.
     * 
    **/
    distinct?: Enumerable<TransFatScalarFieldEnum>
  }


  /**
   * TransFat findMany
   */
  export type TransFatFindManyArgs = {
    /**
     * Select specific fields to fetch from the TransFat
     * 
    **/
    select?: TransFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransFatInclude | null
    /**
     * Filter, which TransFats to fetch.
     * 
    **/
    where?: TransFatWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TransFats to fetch.
     * 
    **/
    orderBy?: Enumerable<TransFatOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TransFats.
     * 
    **/
    cursor?: TransFatWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TransFats from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TransFats.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TransFatScalarFieldEnum>
  }


  /**
   * TransFat create
   */
  export type TransFatCreateArgs = {
    /**
     * Select specific fields to fetch from the TransFat
     * 
    **/
    select?: TransFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransFatInclude | null
    /**
     * The data needed to create a TransFat.
     * 
    **/
    data: XOR<TransFatCreateInput, TransFatUncheckedCreateInput>
  }


  /**
   * TransFat createMany
   */
  export type TransFatCreateManyArgs = {
    /**
     * The data used to create many TransFats.
     * 
    **/
    data: Enumerable<TransFatCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TransFat update
   */
  export type TransFatUpdateArgs = {
    /**
     * Select specific fields to fetch from the TransFat
     * 
    **/
    select?: TransFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransFatInclude | null
    /**
     * The data needed to update a TransFat.
     * 
    **/
    data: XOR<TransFatUpdateInput, TransFatUncheckedUpdateInput>
    /**
     * Choose, which TransFat to update.
     * 
    **/
    where: TransFatWhereUniqueInput
  }


  /**
   * TransFat updateMany
   */
  export type TransFatUpdateManyArgs = {
    /**
     * The data used to update TransFats.
     * 
    **/
    data: XOR<TransFatUpdateManyMutationInput, TransFatUncheckedUpdateManyInput>
    /**
     * Filter which TransFats to update
     * 
    **/
    where?: TransFatWhereInput
  }


  /**
   * TransFat upsert
   */
  export type TransFatUpsertArgs = {
    /**
     * Select specific fields to fetch from the TransFat
     * 
    **/
    select?: TransFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransFatInclude | null
    /**
     * The filter to search for the TransFat to update in case it exists.
     * 
    **/
    where: TransFatWhereUniqueInput
    /**
     * In case the TransFat found by the `where` argument doesn't exist, create a new TransFat with this data.
     * 
    **/
    create: XOR<TransFatCreateInput, TransFatUncheckedCreateInput>
    /**
     * In case the TransFat was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TransFatUpdateInput, TransFatUncheckedUpdateInput>
  }


  /**
   * TransFat delete
   */
  export type TransFatDeleteArgs = {
    /**
     * Select specific fields to fetch from the TransFat
     * 
    **/
    select?: TransFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransFatInclude | null
    /**
     * Filter which TransFat to delete.
     * 
    **/
    where: TransFatWhereUniqueInput
  }


  /**
   * TransFat deleteMany
   */
  export type TransFatDeleteManyArgs = {
    /**
     * Filter which TransFats to delete
     * 
    **/
    where?: TransFatWhereInput
  }


  /**
   * TransFat without action
   */
  export type TransFatArgs = {
    /**
     * Select specific fields to fetch from the TransFat
     * 
    **/
    select?: TransFatSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TransFatInclude | null
  }



  /**
   * Model Carbohydrate
   */


  export type AggregateCarbohydrate = {
    _count: CarbohydrateCountAggregateOutputType | null
    _avg: CarbohydrateAvgAggregateOutputType | null
    _sum: CarbohydrateSumAggregateOutputType | null
    _min: CarbohydrateMinAggregateOutputType | null
    _max: CarbohydrateMaxAggregateOutputType | null
  }

  export type CarbohydrateAvgAggregateOutputType = {
    id: number | null
    totalCarbohydrateId: number | null
    sugarCarbohydrateId: number | null
  }

  export type CarbohydrateSumAggregateOutputType = {
    id: number | null
    totalCarbohydrateId: number | null
    sugarCarbohydrateId: number | null
  }

  export type CarbohydrateMinAggregateOutputType = {
    id: number | null
    totalCarbohydrateId: number | null
    sugarCarbohydrateId: number | null
  }

  export type CarbohydrateMaxAggregateOutputType = {
    id: number | null
    totalCarbohydrateId: number | null
    sugarCarbohydrateId: number | null
  }

  export type CarbohydrateCountAggregateOutputType = {
    id: number
    totalCarbohydrateId: number
    sugarCarbohydrateId: number
    _all: number
  }


  export type CarbohydrateAvgAggregateInputType = {
    id?: true
    totalCarbohydrateId?: true
    sugarCarbohydrateId?: true
  }

  export type CarbohydrateSumAggregateInputType = {
    id?: true
    totalCarbohydrateId?: true
    sugarCarbohydrateId?: true
  }

  export type CarbohydrateMinAggregateInputType = {
    id?: true
    totalCarbohydrateId?: true
    sugarCarbohydrateId?: true
  }

  export type CarbohydrateMaxAggregateInputType = {
    id?: true
    totalCarbohydrateId?: true
    sugarCarbohydrateId?: true
  }

  export type CarbohydrateCountAggregateInputType = {
    id?: true
    totalCarbohydrateId?: true
    sugarCarbohydrateId?: true
    _all?: true
  }

  export type CarbohydrateAggregateArgs = {
    /**
     * Filter which Carbohydrate to aggregate.
     * 
    **/
    where?: CarbohydrateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carbohydrates to fetch.
     * 
    **/
    orderBy?: Enumerable<CarbohydrateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CarbohydrateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carbohydrates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carbohydrates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Carbohydrates
    **/
    _count?: true | CarbohydrateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CarbohydrateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CarbohydrateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CarbohydrateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CarbohydrateMaxAggregateInputType
  }

  export type GetCarbohydrateAggregateType<T extends CarbohydrateAggregateArgs> = {
        [P in keyof T & keyof AggregateCarbohydrate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCarbohydrate[P]>
      : GetScalarType<T[P], AggregateCarbohydrate[P]>
  }




  export type CarbohydrateGroupByArgs = {
    where?: CarbohydrateWhereInput
    orderBy?: Enumerable<CarbohydrateOrderByWithAggregationInput>
    by: Array<CarbohydrateScalarFieldEnum>
    having?: CarbohydrateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CarbohydrateCountAggregateInputType | true
    _avg?: CarbohydrateAvgAggregateInputType
    _sum?: CarbohydrateSumAggregateInputType
    _min?: CarbohydrateMinAggregateInputType
    _max?: CarbohydrateMaxAggregateInputType
  }


  export type CarbohydrateGroupByOutputType = {
    id: number
    totalCarbohydrateId: number | null
    sugarCarbohydrateId: number | null
    _count: CarbohydrateCountAggregateOutputType | null
    _avg: CarbohydrateAvgAggregateOutputType | null
    _sum: CarbohydrateSumAggregateOutputType | null
    _min: CarbohydrateMinAggregateOutputType | null
    _max: CarbohydrateMaxAggregateOutputType | null
  }

  type GetCarbohydrateGroupByPayload<T extends CarbohydrateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CarbohydrateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CarbohydrateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CarbohydrateGroupByOutputType[P]>
            : GetScalarType<T[P], CarbohydrateGroupByOutputType[P]>
        }
      >
    >


  export type CarbohydrateSelect = {
    id?: boolean
    total?: boolean | TotalCarbohydrateArgs
    totalCarbohydrateId?: boolean
    sugar?: boolean | SugarCarbohydrateArgs
    sugarCarbohydrateId?: boolean
    nutritionFacts?: boolean | NutritionFactFindManyArgs
    _count?: boolean | CarbohydrateCountOutputTypeArgs
  }

  export type CarbohydrateInclude = {
    total?: boolean | TotalCarbohydrateArgs
    sugar?: boolean | SugarCarbohydrateArgs
    nutritionFacts?: boolean | NutritionFactFindManyArgs
    _count?: boolean | CarbohydrateCountOutputTypeArgs
  }

  export type CarbohydrateGetPayload<
    S extends boolean | null | undefined | CarbohydrateArgs,
    U = keyof S
      > = S extends true
        ? Carbohydrate
    : S extends undefined
    ? never
    : S extends CarbohydrateArgs | CarbohydrateFindManyArgs
    ?'include' extends U
    ? Carbohydrate  & {
    [P in TrueKeys<S['include']>]:
        P extends 'total' ? TotalCarbohydrateGetPayload<S['include'][P]> | null :
        P extends 'sugar' ? SugarCarbohydrateGetPayload<S['include'][P]> | null :
        P extends 'nutritionFacts' ? Array < NutritionFactGetPayload<S['include'][P]>>  :
        P extends '_count' ? CarbohydrateCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'total' ? TotalCarbohydrateGetPayload<S['select'][P]> | null :
        P extends 'sugar' ? SugarCarbohydrateGetPayload<S['select'][P]> | null :
        P extends 'nutritionFacts' ? Array < NutritionFactGetPayload<S['select'][P]>>  :
        P extends '_count' ? CarbohydrateCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Carbohydrate ? Carbohydrate[P] : never
  } 
    : Carbohydrate
  : Carbohydrate


  type CarbohydrateCountArgs = Merge<
    Omit<CarbohydrateFindManyArgs, 'select' | 'include'> & {
      select?: CarbohydrateCountAggregateInputType | true
    }
  >

  export interface CarbohydrateDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Carbohydrate that matches the filter.
     * @param {CarbohydrateFindUniqueArgs} args - Arguments to find a Carbohydrate
     * @example
     * // Get one Carbohydrate
     * const carbohydrate = await prisma.carbohydrate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CarbohydrateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CarbohydrateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Carbohydrate'> extends True ? CheckSelect<T, Prisma__CarbohydrateClient<Carbohydrate>, Prisma__CarbohydrateClient<CarbohydrateGetPayload<T>>> : CheckSelect<T, Prisma__CarbohydrateClient<Carbohydrate | null >, Prisma__CarbohydrateClient<CarbohydrateGetPayload<T> | null >>

    /**
     * Find the first Carbohydrate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarbohydrateFindFirstArgs} args - Arguments to find a Carbohydrate
     * @example
     * // Get one Carbohydrate
     * const carbohydrate = await prisma.carbohydrate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CarbohydrateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CarbohydrateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Carbohydrate'> extends True ? CheckSelect<T, Prisma__CarbohydrateClient<Carbohydrate>, Prisma__CarbohydrateClient<CarbohydrateGetPayload<T>>> : CheckSelect<T, Prisma__CarbohydrateClient<Carbohydrate | null >, Prisma__CarbohydrateClient<CarbohydrateGetPayload<T> | null >>

    /**
     * Find zero or more Carbohydrates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarbohydrateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Carbohydrates
     * const carbohydrates = await prisma.carbohydrate.findMany()
     * 
     * // Get first 10 Carbohydrates
     * const carbohydrates = await prisma.carbohydrate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const carbohydrateWithIdOnly = await prisma.carbohydrate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CarbohydrateFindManyArgs>(
      args?: SelectSubset<T, CarbohydrateFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Carbohydrate>>, PrismaPromise<Array<CarbohydrateGetPayload<T>>>>

    /**
     * Create a Carbohydrate.
     * @param {CarbohydrateCreateArgs} args - Arguments to create a Carbohydrate.
     * @example
     * // Create one Carbohydrate
     * const Carbohydrate = await prisma.carbohydrate.create({
     *   data: {
     *     // ... data to create a Carbohydrate
     *   }
     * })
     * 
    **/
    create<T extends CarbohydrateCreateArgs>(
      args: SelectSubset<T, CarbohydrateCreateArgs>
    ): CheckSelect<T, Prisma__CarbohydrateClient<Carbohydrate>, Prisma__CarbohydrateClient<CarbohydrateGetPayload<T>>>

    /**
     * Create many Carbohydrates.
     *     @param {CarbohydrateCreateManyArgs} args - Arguments to create many Carbohydrates.
     *     @example
     *     // Create many Carbohydrates
     *     const carbohydrate = await prisma.carbohydrate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CarbohydrateCreateManyArgs>(
      args?: SelectSubset<T, CarbohydrateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Carbohydrate.
     * @param {CarbohydrateDeleteArgs} args - Arguments to delete one Carbohydrate.
     * @example
     * // Delete one Carbohydrate
     * const Carbohydrate = await prisma.carbohydrate.delete({
     *   where: {
     *     // ... filter to delete one Carbohydrate
     *   }
     * })
     * 
    **/
    delete<T extends CarbohydrateDeleteArgs>(
      args: SelectSubset<T, CarbohydrateDeleteArgs>
    ): CheckSelect<T, Prisma__CarbohydrateClient<Carbohydrate>, Prisma__CarbohydrateClient<CarbohydrateGetPayload<T>>>

    /**
     * Update one Carbohydrate.
     * @param {CarbohydrateUpdateArgs} args - Arguments to update one Carbohydrate.
     * @example
     * // Update one Carbohydrate
     * const carbohydrate = await prisma.carbohydrate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CarbohydrateUpdateArgs>(
      args: SelectSubset<T, CarbohydrateUpdateArgs>
    ): CheckSelect<T, Prisma__CarbohydrateClient<Carbohydrate>, Prisma__CarbohydrateClient<CarbohydrateGetPayload<T>>>

    /**
     * Delete zero or more Carbohydrates.
     * @param {CarbohydrateDeleteManyArgs} args - Arguments to filter Carbohydrates to delete.
     * @example
     * // Delete a few Carbohydrates
     * const { count } = await prisma.carbohydrate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CarbohydrateDeleteManyArgs>(
      args?: SelectSubset<T, CarbohydrateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Carbohydrates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarbohydrateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Carbohydrates
     * const carbohydrate = await prisma.carbohydrate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CarbohydrateUpdateManyArgs>(
      args: SelectSubset<T, CarbohydrateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Carbohydrate.
     * @param {CarbohydrateUpsertArgs} args - Arguments to update or create a Carbohydrate.
     * @example
     * // Update or create a Carbohydrate
     * const carbohydrate = await prisma.carbohydrate.upsert({
     *   create: {
     *     // ... data to create a Carbohydrate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Carbohydrate we want to update
     *   }
     * })
    **/
    upsert<T extends CarbohydrateUpsertArgs>(
      args: SelectSubset<T, CarbohydrateUpsertArgs>
    ): CheckSelect<T, Prisma__CarbohydrateClient<Carbohydrate>, Prisma__CarbohydrateClient<CarbohydrateGetPayload<T>>>

    /**
     * Count the number of Carbohydrates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarbohydrateCountArgs} args - Arguments to filter Carbohydrates to count.
     * @example
     * // Count the number of Carbohydrates
     * const count = await prisma.carbohydrate.count({
     *   where: {
     *     // ... the filter for the Carbohydrates we want to count
     *   }
     * })
    **/
    count<T extends CarbohydrateCountArgs>(
      args?: Subset<T, CarbohydrateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CarbohydrateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Carbohydrate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarbohydrateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CarbohydrateAggregateArgs>(args: Subset<T, CarbohydrateAggregateArgs>): PrismaPromise<GetCarbohydrateAggregateType<T>>

    /**
     * Group by Carbohydrate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CarbohydrateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CarbohydrateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CarbohydrateGroupByArgs['orderBy'] }
        : { orderBy?: CarbohydrateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CarbohydrateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCarbohydrateGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Carbohydrate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CarbohydrateClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    total<T extends TotalCarbohydrateArgs = {}>(args?: Subset<T, TotalCarbohydrateArgs>): CheckSelect<T, Prisma__TotalCarbohydrateClient<TotalCarbohydrate | null >, Prisma__TotalCarbohydrateClient<TotalCarbohydrateGetPayload<T> | null >>;

    sugar<T extends SugarCarbohydrateArgs = {}>(args?: Subset<T, SugarCarbohydrateArgs>): CheckSelect<T, Prisma__SugarCarbohydrateClient<SugarCarbohydrate | null >, Prisma__SugarCarbohydrateClient<SugarCarbohydrateGetPayload<T> | null >>;

    nutritionFacts<T extends NutritionFactFindManyArgs = {}>(args?: Subset<T, NutritionFactFindManyArgs>): CheckSelect<T, PrismaPromise<Array<NutritionFact>>, PrismaPromise<Array<NutritionFactGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Carbohydrate findUnique
   */
  export type CarbohydrateFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Carbohydrate
     * 
    **/
    select?: CarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarbohydrateInclude | null
    /**
     * Throw an Error if a Carbohydrate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Carbohydrate to fetch.
     * 
    **/
    where: CarbohydrateWhereUniqueInput
  }


  /**
   * Carbohydrate findFirst
   */
  export type CarbohydrateFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Carbohydrate
     * 
    **/
    select?: CarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarbohydrateInclude | null
    /**
     * Throw an Error if a Carbohydrate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Carbohydrate to fetch.
     * 
    **/
    where?: CarbohydrateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carbohydrates to fetch.
     * 
    **/
    orderBy?: Enumerable<CarbohydrateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Carbohydrates.
     * 
    **/
    cursor?: CarbohydrateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carbohydrates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carbohydrates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Carbohydrates.
     * 
    **/
    distinct?: Enumerable<CarbohydrateScalarFieldEnum>
  }


  /**
   * Carbohydrate findMany
   */
  export type CarbohydrateFindManyArgs = {
    /**
     * Select specific fields to fetch from the Carbohydrate
     * 
    **/
    select?: CarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarbohydrateInclude | null
    /**
     * Filter, which Carbohydrates to fetch.
     * 
    **/
    where?: CarbohydrateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Carbohydrates to fetch.
     * 
    **/
    orderBy?: Enumerable<CarbohydrateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Carbohydrates.
     * 
    **/
    cursor?: CarbohydrateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Carbohydrates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Carbohydrates.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CarbohydrateScalarFieldEnum>
  }


  /**
   * Carbohydrate create
   */
  export type CarbohydrateCreateArgs = {
    /**
     * Select specific fields to fetch from the Carbohydrate
     * 
    **/
    select?: CarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarbohydrateInclude | null
    /**
     * The data needed to create a Carbohydrate.
     * 
    **/
    data: XOR<CarbohydrateCreateInput, CarbohydrateUncheckedCreateInput>
  }


  /**
   * Carbohydrate createMany
   */
  export type CarbohydrateCreateManyArgs = {
    /**
     * The data used to create many Carbohydrates.
     * 
    **/
    data: Enumerable<CarbohydrateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Carbohydrate update
   */
  export type CarbohydrateUpdateArgs = {
    /**
     * Select specific fields to fetch from the Carbohydrate
     * 
    **/
    select?: CarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarbohydrateInclude | null
    /**
     * The data needed to update a Carbohydrate.
     * 
    **/
    data: XOR<CarbohydrateUpdateInput, CarbohydrateUncheckedUpdateInput>
    /**
     * Choose, which Carbohydrate to update.
     * 
    **/
    where: CarbohydrateWhereUniqueInput
  }


  /**
   * Carbohydrate updateMany
   */
  export type CarbohydrateUpdateManyArgs = {
    /**
     * The data used to update Carbohydrates.
     * 
    **/
    data: XOR<CarbohydrateUpdateManyMutationInput, CarbohydrateUncheckedUpdateManyInput>
    /**
     * Filter which Carbohydrates to update
     * 
    **/
    where?: CarbohydrateWhereInput
  }


  /**
   * Carbohydrate upsert
   */
  export type CarbohydrateUpsertArgs = {
    /**
     * Select specific fields to fetch from the Carbohydrate
     * 
    **/
    select?: CarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarbohydrateInclude | null
    /**
     * The filter to search for the Carbohydrate to update in case it exists.
     * 
    **/
    where: CarbohydrateWhereUniqueInput
    /**
     * In case the Carbohydrate found by the `where` argument doesn't exist, create a new Carbohydrate with this data.
     * 
    **/
    create: XOR<CarbohydrateCreateInput, CarbohydrateUncheckedCreateInput>
    /**
     * In case the Carbohydrate was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CarbohydrateUpdateInput, CarbohydrateUncheckedUpdateInput>
  }


  /**
   * Carbohydrate delete
   */
  export type CarbohydrateDeleteArgs = {
    /**
     * Select specific fields to fetch from the Carbohydrate
     * 
    **/
    select?: CarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarbohydrateInclude | null
    /**
     * Filter which Carbohydrate to delete.
     * 
    **/
    where: CarbohydrateWhereUniqueInput
  }


  /**
   * Carbohydrate deleteMany
   */
  export type CarbohydrateDeleteManyArgs = {
    /**
     * Filter which Carbohydrates to delete
     * 
    **/
    where?: CarbohydrateWhereInput
  }


  /**
   * Carbohydrate without action
   */
  export type CarbohydrateArgs = {
    /**
     * Select specific fields to fetch from the Carbohydrate
     * 
    **/
    select?: CarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CarbohydrateInclude | null
  }



  /**
   * Model TotalCarbohydrate
   */


  export type AggregateTotalCarbohydrate = {
    _count: TotalCarbohydrateCountAggregateOutputType | null
    _avg: TotalCarbohydrateAvgAggregateOutputType | null
    _sum: TotalCarbohydrateSumAggregateOutputType | null
    _min: TotalCarbohydrateMinAggregateOutputType | null
    _max: TotalCarbohydrateMaxAggregateOutputType | null
  }

  export type TotalCarbohydrateAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type TotalCarbohydrateSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type TotalCarbohydrateMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type TotalCarbohydrateMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type TotalCarbohydrateCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type TotalCarbohydrateAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type TotalCarbohydrateSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type TotalCarbohydrateMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type TotalCarbohydrateMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type TotalCarbohydrateCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type TotalCarbohydrateAggregateArgs = {
    /**
     * Filter which TotalCarbohydrate to aggregate.
     * 
    **/
    where?: TotalCarbohydrateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TotalCarbohydrates to fetch.
     * 
    **/
    orderBy?: Enumerable<TotalCarbohydrateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: TotalCarbohydrateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TotalCarbohydrates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TotalCarbohydrates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TotalCarbohydrates
    **/
    _count?: true | TotalCarbohydrateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TotalCarbohydrateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TotalCarbohydrateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TotalCarbohydrateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TotalCarbohydrateMaxAggregateInputType
  }

  export type GetTotalCarbohydrateAggregateType<T extends TotalCarbohydrateAggregateArgs> = {
        [P in keyof T & keyof AggregateTotalCarbohydrate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTotalCarbohydrate[P]>
      : GetScalarType<T[P], AggregateTotalCarbohydrate[P]>
  }




  export type TotalCarbohydrateGroupByArgs = {
    where?: TotalCarbohydrateWhereInput
    orderBy?: Enumerable<TotalCarbohydrateOrderByWithAggregationInput>
    by: Array<TotalCarbohydrateScalarFieldEnum>
    having?: TotalCarbohydrateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TotalCarbohydrateCountAggregateInputType | true
    _avg?: TotalCarbohydrateAvgAggregateInputType
    _sum?: TotalCarbohydrateSumAggregateInputType
    _min?: TotalCarbohydrateMinAggregateInputType
    _max?: TotalCarbohydrateMaxAggregateInputType
  }


  export type TotalCarbohydrateGroupByOutputType = {
    id: number
    measurementId: number
    _count: TotalCarbohydrateCountAggregateOutputType | null
    _avg: TotalCarbohydrateAvgAggregateOutputType | null
    _sum: TotalCarbohydrateSumAggregateOutputType | null
    _min: TotalCarbohydrateMinAggregateOutputType | null
    _max: TotalCarbohydrateMaxAggregateOutputType | null
  }

  type GetTotalCarbohydrateGroupByPayload<T extends TotalCarbohydrateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<TotalCarbohydrateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TotalCarbohydrateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TotalCarbohydrateGroupByOutputType[P]>
            : GetScalarType<T[P], TotalCarbohydrateGroupByOutputType[P]>
        }
      >
    >


  export type TotalCarbohydrateSelect = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    carbohydrate?: boolean | CarbohydrateArgs
    measurementId?: boolean
  }

  export type TotalCarbohydrateInclude = {
    measurement?: boolean | MeasurementArgs
    carbohydrate?: boolean | CarbohydrateArgs
  }

  export type TotalCarbohydrateGetPayload<
    S extends boolean | null | undefined | TotalCarbohydrateArgs,
    U = keyof S
      > = S extends true
        ? TotalCarbohydrate
    : S extends undefined
    ? never
    : S extends TotalCarbohydrateArgs | TotalCarbohydrateFindManyArgs
    ?'include' extends U
    ? TotalCarbohydrate  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'carbohydrate' ? CarbohydrateGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'carbohydrate' ? CarbohydrateGetPayload<S['select'][P]> | null :  P extends keyof TotalCarbohydrate ? TotalCarbohydrate[P] : never
  } 
    : TotalCarbohydrate
  : TotalCarbohydrate


  type TotalCarbohydrateCountArgs = Merge<
    Omit<TotalCarbohydrateFindManyArgs, 'select' | 'include'> & {
      select?: TotalCarbohydrateCountAggregateInputType | true
    }
  >

  export interface TotalCarbohydrateDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one TotalCarbohydrate that matches the filter.
     * @param {TotalCarbohydrateFindUniqueArgs} args - Arguments to find a TotalCarbohydrate
     * @example
     * // Get one TotalCarbohydrate
     * const totalCarbohydrate = await prisma.totalCarbohydrate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TotalCarbohydrateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, TotalCarbohydrateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'TotalCarbohydrate'> extends True ? CheckSelect<T, Prisma__TotalCarbohydrateClient<TotalCarbohydrate>, Prisma__TotalCarbohydrateClient<TotalCarbohydrateGetPayload<T>>> : CheckSelect<T, Prisma__TotalCarbohydrateClient<TotalCarbohydrate | null >, Prisma__TotalCarbohydrateClient<TotalCarbohydrateGetPayload<T> | null >>

    /**
     * Find the first TotalCarbohydrate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalCarbohydrateFindFirstArgs} args - Arguments to find a TotalCarbohydrate
     * @example
     * // Get one TotalCarbohydrate
     * const totalCarbohydrate = await prisma.totalCarbohydrate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TotalCarbohydrateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, TotalCarbohydrateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'TotalCarbohydrate'> extends True ? CheckSelect<T, Prisma__TotalCarbohydrateClient<TotalCarbohydrate>, Prisma__TotalCarbohydrateClient<TotalCarbohydrateGetPayload<T>>> : CheckSelect<T, Prisma__TotalCarbohydrateClient<TotalCarbohydrate | null >, Prisma__TotalCarbohydrateClient<TotalCarbohydrateGetPayload<T> | null >>

    /**
     * Find zero or more TotalCarbohydrates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalCarbohydrateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TotalCarbohydrates
     * const totalCarbohydrates = await prisma.totalCarbohydrate.findMany()
     * 
     * // Get first 10 TotalCarbohydrates
     * const totalCarbohydrates = await prisma.totalCarbohydrate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const totalCarbohydrateWithIdOnly = await prisma.totalCarbohydrate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends TotalCarbohydrateFindManyArgs>(
      args?: SelectSubset<T, TotalCarbohydrateFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<TotalCarbohydrate>>, PrismaPromise<Array<TotalCarbohydrateGetPayload<T>>>>

    /**
     * Create a TotalCarbohydrate.
     * @param {TotalCarbohydrateCreateArgs} args - Arguments to create a TotalCarbohydrate.
     * @example
     * // Create one TotalCarbohydrate
     * const TotalCarbohydrate = await prisma.totalCarbohydrate.create({
     *   data: {
     *     // ... data to create a TotalCarbohydrate
     *   }
     * })
     * 
    **/
    create<T extends TotalCarbohydrateCreateArgs>(
      args: SelectSubset<T, TotalCarbohydrateCreateArgs>
    ): CheckSelect<T, Prisma__TotalCarbohydrateClient<TotalCarbohydrate>, Prisma__TotalCarbohydrateClient<TotalCarbohydrateGetPayload<T>>>

    /**
     * Create many TotalCarbohydrates.
     *     @param {TotalCarbohydrateCreateManyArgs} args - Arguments to create many TotalCarbohydrates.
     *     @example
     *     // Create many TotalCarbohydrates
     *     const totalCarbohydrate = await prisma.totalCarbohydrate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends TotalCarbohydrateCreateManyArgs>(
      args?: SelectSubset<T, TotalCarbohydrateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a TotalCarbohydrate.
     * @param {TotalCarbohydrateDeleteArgs} args - Arguments to delete one TotalCarbohydrate.
     * @example
     * // Delete one TotalCarbohydrate
     * const TotalCarbohydrate = await prisma.totalCarbohydrate.delete({
     *   where: {
     *     // ... filter to delete one TotalCarbohydrate
     *   }
     * })
     * 
    **/
    delete<T extends TotalCarbohydrateDeleteArgs>(
      args: SelectSubset<T, TotalCarbohydrateDeleteArgs>
    ): CheckSelect<T, Prisma__TotalCarbohydrateClient<TotalCarbohydrate>, Prisma__TotalCarbohydrateClient<TotalCarbohydrateGetPayload<T>>>

    /**
     * Update one TotalCarbohydrate.
     * @param {TotalCarbohydrateUpdateArgs} args - Arguments to update one TotalCarbohydrate.
     * @example
     * // Update one TotalCarbohydrate
     * const totalCarbohydrate = await prisma.totalCarbohydrate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TotalCarbohydrateUpdateArgs>(
      args: SelectSubset<T, TotalCarbohydrateUpdateArgs>
    ): CheckSelect<T, Prisma__TotalCarbohydrateClient<TotalCarbohydrate>, Prisma__TotalCarbohydrateClient<TotalCarbohydrateGetPayload<T>>>

    /**
     * Delete zero or more TotalCarbohydrates.
     * @param {TotalCarbohydrateDeleteManyArgs} args - Arguments to filter TotalCarbohydrates to delete.
     * @example
     * // Delete a few TotalCarbohydrates
     * const { count } = await prisma.totalCarbohydrate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TotalCarbohydrateDeleteManyArgs>(
      args?: SelectSubset<T, TotalCarbohydrateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more TotalCarbohydrates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalCarbohydrateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TotalCarbohydrates
     * const totalCarbohydrate = await prisma.totalCarbohydrate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TotalCarbohydrateUpdateManyArgs>(
      args: SelectSubset<T, TotalCarbohydrateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one TotalCarbohydrate.
     * @param {TotalCarbohydrateUpsertArgs} args - Arguments to update or create a TotalCarbohydrate.
     * @example
     * // Update or create a TotalCarbohydrate
     * const totalCarbohydrate = await prisma.totalCarbohydrate.upsert({
     *   create: {
     *     // ... data to create a TotalCarbohydrate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TotalCarbohydrate we want to update
     *   }
     * })
    **/
    upsert<T extends TotalCarbohydrateUpsertArgs>(
      args: SelectSubset<T, TotalCarbohydrateUpsertArgs>
    ): CheckSelect<T, Prisma__TotalCarbohydrateClient<TotalCarbohydrate>, Prisma__TotalCarbohydrateClient<TotalCarbohydrateGetPayload<T>>>

    /**
     * Count the number of TotalCarbohydrates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalCarbohydrateCountArgs} args - Arguments to filter TotalCarbohydrates to count.
     * @example
     * // Count the number of TotalCarbohydrates
     * const count = await prisma.totalCarbohydrate.count({
     *   where: {
     *     // ... the filter for the TotalCarbohydrates we want to count
     *   }
     * })
    **/
    count<T extends TotalCarbohydrateCountArgs>(
      args?: Subset<T, TotalCarbohydrateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TotalCarbohydrateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TotalCarbohydrate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalCarbohydrateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TotalCarbohydrateAggregateArgs>(args: Subset<T, TotalCarbohydrateAggregateArgs>): PrismaPromise<GetTotalCarbohydrateAggregateType<T>>

    /**
     * Group by TotalCarbohydrate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TotalCarbohydrateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TotalCarbohydrateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TotalCarbohydrateGroupByArgs['orderBy'] }
        : { orderBy?: TotalCarbohydrateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TotalCarbohydrateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTotalCarbohydrateGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for TotalCarbohydrate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__TotalCarbohydrateClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    carbohydrate<T extends CarbohydrateArgs = {}>(args?: Subset<T, CarbohydrateArgs>): CheckSelect<T, Prisma__CarbohydrateClient<Carbohydrate | null >, Prisma__CarbohydrateClient<CarbohydrateGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * TotalCarbohydrate findUnique
   */
  export type TotalCarbohydrateFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the TotalCarbohydrate
     * 
    **/
    select?: TotalCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalCarbohydrateInclude | null
    /**
     * Throw an Error if a TotalCarbohydrate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TotalCarbohydrate to fetch.
     * 
    **/
    where: TotalCarbohydrateWhereUniqueInput
  }


  /**
   * TotalCarbohydrate findFirst
   */
  export type TotalCarbohydrateFindFirstArgs = {
    /**
     * Select specific fields to fetch from the TotalCarbohydrate
     * 
    **/
    select?: TotalCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalCarbohydrateInclude | null
    /**
     * Throw an Error if a TotalCarbohydrate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which TotalCarbohydrate to fetch.
     * 
    **/
    where?: TotalCarbohydrateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TotalCarbohydrates to fetch.
     * 
    **/
    orderBy?: Enumerable<TotalCarbohydrateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TotalCarbohydrates.
     * 
    **/
    cursor?: TotalCarbohydrateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TotalCarbohydrates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TotalCarbohydrates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TotalCarbohydrates.
     * 
    **/
    distinct?: Enumerable<TotalCarbohydrateScalarFieldEnum>
  }


  /**
   * TotalCarbohydrate findMany
   */
  export type TotalCarbohydrateFindManyArgs = {
    /**
     * Select specific fields to fetch from the TotalCarbohydrate
     * 
    **/
    select?: TotalCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalCarbohydrateInclude | null
    /**
     * Filter, which TotalCarbohydrates to fetch.
     * 
    **/
    where?: TotalCarbohydrateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TotalCarbohydrates to fetch.
     * 
    **/
    orderBy?: Enumerable<TotalCarbohydrateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TotalCarbohydrates.
     * 
    **/
    cursor?: TotalCarbohydrateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TotalCarbohydrates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TotalCarbohydrates.
     * 
    **/
    skip?: number
    distinct?: Enumerable<TotalCarbohydrateScalarFieldEnum>
  }


  /**
   * TotalCarbohydrate create
   */
  export type TotalCarbohydrateCreateArgs = {
    /**
     * Select specific fields to fetch from the TotalCarbohydrate
     * 
    **/
    select?: TotalCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalCarbohydrateInclude | null
    /**
     * The data needed to create a TotalCarbohydrate.
     * 
    **/
    data: XOR<TotalCarbohydrateCreateInput, TotalCarbohydrateUncheckedCreateInput>
  }


  /**
   * TotalCarbohydrate createMany
   */
  export type TotalCarbohydrateCreateManyArgs = {
    /**
     * The data used to create many TotalCarbohydrates.
     * 
    **/
    data: Enumerable<TotalCarbohydrateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * TotalCarbohydrate update
   */
  export type TotalCarbohydrateUpdateArgs = {
    /**
     * Select specific fields to fetch from the TotalCarbohydrate
     * 
    **/
    select?: TotalCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalCarbohydrateInclude | null
    /**
     * The data needed to update a TotalCarbohydrate.
     * 
    **/
    data: XOR<TotalCarbohydrateUpdateInput, TotalCarbohydrateUncheckedUpdateInput>
    /**
     * Choose, which TotalCarbohydrate to update.
     * 
    **/
    where: TotalCarbohydrateWhereUniqueInput
  }


  /**
   * TotalCarbohydrate updateMany
   */
  export type TotalCarbohydrateUpdateManyArgs = {
    /**
     * The data used to update TotalCarbohydrates.
     * 
    **/
    data: XOR<TotalCarbohydrateUpdateManyMutationInput, TotalCarbohydrateUncheckedUpdateManyInput>
    /**
     * Filter which TotalCarbohydrates to update
     * 
    **/
    where?: TotalCarbohydrateWhereInput
  }


  /**
   * TotalCarbohydrate upsert
   */
  export type TotalCarbohydrateUpsertArgs = {
    /**
     * Select specific fields to fetch from the TotalCarbohydrate
     * 
    **/
    select?: TotalCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalCarbohydrateInclude | null
    /**
     * The filter to search for the TotalCarbohydrate to update in case it exists.
     * 
    **/
    where: TotalCarbohydrateWhereUniqueInput
    /**
     * In case the TotalCarbohydrate found by the `where` argument doesn't exist, create a new TotalCarbohydrate with this data.
     * 
    **/
    create: XOR<TotalCarbohydrateCreateInput, TotalCarbohydrateUncheckedCreateInput>
    /**
     * In case the TotalCarbohydrate was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<TotalCarbohydrateUpdateInput, TotalCarbohydrateUncheckedUpdateInput>
  }


  /**
   * TotalCarbohydrate delete
   */
  export type TotalCarbohydrateDeleteArgs = {
    /**
     * Select specific fields to fetch from the TotalCarbohydrate
     * 
    **/
    select?: TotalCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalCarbohydrateInclude | null
    /**
     * Filter which TotalCarbohydrate to delete.
     * 
    **/
    where: TotalCarbohydrateWhereUniqueInput
  }


  /**
   * TotalCarbohydrate deleteMany
   */
  export type TotalCarbohydrateDeleteManyArgs = {
    /**
     * Filter which TotalCarbohydrates to delete
     * 
    **/
    where?: TotalCarbohydrateWhereInput
  }


  /**
   * TotalCarbohydrate without action
   */
  export type TotalCarbohydrateArgs = {
    /**
     * Select specific fields to fetch from the TotalCarbohydrate
     * 
    **/
    select?: TotalCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: TotalCarbohydrateInclude | null
  }



  /**
   * Model SugarCarbohydrate
   */


  export type AggregateSugarCarbohydrate = {
    _count: SugarCarbohydrateCountAggregateOutputType | null
    _avg: SugarCarbohydrateAvgAggregateOutputType | null
    _sum: SugarCarbohydrateSumAggregateOutputType | null
    _min: SugarCarbohydrateMinAggregateOutputType | null
    _max: SugarCarbohydrateMaxAggregateOutputType | null
  }

  export type SugarCarbohydrateAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SugarCarbohydrateSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SugarCarbohydrateMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SugarCarbohydrateMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SugarCarbohydrateCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type SugarCarbohydrateAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SugarCarbohydrateSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SugarCarbohydrateMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SugarCarbohydrateMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SugarCarbohydrateCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type SugarCarbohydrateAggregateArgs = {
    /**
     * Filter which SugarCarbohydrate to aggregate.
     * 
    **/
    where?: SugarCarbohydrateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SugarCarbohydrates to fetch.
     * 
    **/
    orderBy?: Enumerable<SugarCarbohydrateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SugarCarbohydrateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SugarCarbohydrates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SugarCarbohydrates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SugarCarbohydrates
    **/
    _count?: true | SugarCarbohydrateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SugarCarbohydrateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SugarCarbohydrateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SugarCarbohydrateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SugarCarbohydrateMaxAggregateInputType
  }

  export type GetSugarCarbohydrateAggregateType<T extends SugarCarbohydrateAggregateArgs> = {
        [P in keyof T & keyof AggregateSugarCarbohydrate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSugarCarbohydrate[P]>
      : GetScalarType<T[P], AggregateSugarCarbohydrate[P]>
  }




  export type SugarCarbohydrateGroupByArgs = {
    where?: SugarCarbohydrateWhereInput
    orderBy?: Enumerable<SugarCarbohydrateOrderByWithAggregationInput>
    by: Array<SugarCarbohydrateScalarFieldEnum>
    having?: SugarCarbohydrateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SugarCarbohydrateCountAggregateInputType | true
    _avg?: SugarCarbohydrateAvgAggregateInputType
    _sum?: SugarCarbohydrateSumAggregateInputType
    _min?: SugarCarbohydrateMinAggregateInputType
    _max?: SugarCarbohydrateMaxAggregateInputType
  }


  export type SugarCarbohydrateGroupByOutputType = {
    id: number
    measurementId: number
    _count: SugarCarbohydrateCountAggregateOutputType | null
    _avg: SugarCarbohydrateAvgAggregateOutputType | null
    _sum: SugarCarbohydrateSumAggregateOutputType | null
    _min: SugarCarbohydrateMinAggregateOutputType | null
    _max: SugarCarbohydrateMaxAggregateOutputType | null
  }

  type GetSugarCarbohydrateGroupByPayload<T extends SugarCarbohydrateGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SugarCarbohydrateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SugarCarbohydrateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SugarCarbohydrateGroupByOutputType[P]>
            : GetScalarType<T[P], SugarCarbohydrateGroupByOutputType[P]>
        }
      >
    >


  export type SugarCarbohydrateSelect = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    carbohydrate?: boolean | CarbohydrateArgs
    measurementId?: boolean
  }

  export type SugarCarbohydrateInclude = {
    measurement?: boolean | MeasurementArgs
    carbohydrate?: boolean | CarbohydrateArgs
  }

  export type SugarCarbohydrateGetPayload<
    S extends boolean | null | undefined | SugarCarbohydrateArgs,
    U = keyof S
      > = S extends true
        ? SugarCarbohydrate
    : S extends undefined
    ? never
    : S extends SugarCarbohydrateArgs | SugarCarbohydrateFindManyArgs
    ?'include' extends U
    ? SugarCarbohydrate  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'carbohydrate' ? CarbohydrateGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'carbohydrate' ? CarbohydrateGetPayload<S['select'][P]> | null :  P extends keyof SugarCarbohydrate ? SugarCarbohydrate[P] : never
  } 
    : SugarCarbohydrate
  : SugarCarbohydrate


  type SugarCarbohydrateCountArgs = Merge<
    Omit<SugarCarbohydrateFindManyArgs, 'select' | 'include'> & {
      select?: SugarCarbohydrateCountAggregateInputType | true
    }
  >

  export interface SugarCarbohydrateDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one SugarCarbohydrate that matches the filter.
     * @param {SugarCarbohydrateFindUniqueArgs} args - Arguments to find a SugarCarbohydrate
     * @example
     * // Get one SugarCarbohydrate
     * const sugarCarbohydrate = await prisma.sugarCarbohydrate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SugarCarbohydrateFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SugarCarbohydrateFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'SugarCarbohydrate'> extends True ? CheckSelect<T, Prisma__SugarCarbohydrateClient<SugarCarbohydrate>, Prisma__SugarCarbohydrateClient<SugarCarbohydrateGetPayload<T>>> : CheckSelect<T, Prisma__SugarCarbohydrateClient<SugarCarbohydrate | null >, Prisma__SugarCarbohydrateClient<SugarCarbohydrateGetPayload<T> | null >>

    /**
     * Find the first SugarCarbohydrate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SugarCarbohydrateFindFirstArgs} args - Arguments to find a SugarCarbohydrate
     * @example
     * // Get one SugarCarbohydrate
     * const sugarCarbohydrate = await prisma.sugarCarbohydrate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SugarCarbohydrateFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SugarCarbohydrateFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'SugarCarbohydrate'> extends True ? CheckSelect<T, Prisma__SugarCarbohydrateClient<SugarCarbohydrate>, Prisma__SugarCarbohydrateClient<SugarCarbohydrateGetPayload<T>>> : CheckSelect<T, Prisma__SugarCarbohydrateClient<SugarCarbohydrate | null >, Prisma__SugarCarbohydrateClient<SugarCarbohydrateGetPayload<T> | null >>

    /**
     * Find zero or more SugarCarbohydrates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SugarCarbohydrateFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SugarCarbohydrates
     * const sugarCarbohydrates = await prisma.sugarCarbohydrate.findMany()
     * 
     * // Get first 10 SugarCarbohydrates
     * const sugarCarbohydrates = await prisma.sugarCarbohydrate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sugarCarbohydrateWithIdOnly = await prisma.sugarCarbohydrate.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SugarCarbohydrateFindManyArgs>(
      args?: SelectSubset<T, SugarCarbohydrateFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<SugarCarbohydrate>>, PrismaPromise<Array<SugarCarbohydrateGetPayload<T>>>>

    /**
     * Create a SugarCarbohydrate.
     * @param {SugarCarbohydrateCreateArgs} args - Arguments to create a SugarCarbohydrate.
     * @example
     * // Create one SugarCarbohydrate
     * const SugarCarbohydrate = await prisma.sugarCarbohydrate.create({
     *   data: {
     *     // ... data to create a SugarCarbohydrate
     *   }
     * })
     * 
    **/
    create<T extends SugarCarbohydrateCreateArgs>(
      args: SelectSubset<T, SugarCarbohydrateCreateArgs>
    ): CheckSelect<T, Prisma__SugarCarbohydrateClient<SugarCarbohydrate>, Prisma__SugarCarbohydrateClient<SugarCarbohydrateGetPayload<T>>>

    /**
     * Create many SugarCarbohydrates.
     *     @param {SugarCarbohydrateCreateManyArgs} args - Arguments to create many SugarCarbohydrates.
     *     @example
     *     // Create many SugarCarbohydrates
     *     const sugarCarbohydrate = await prisma.sugarCarbohydrate.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SugarCarbohydrateCreateManyArgs>(
      args?: SelectSubset<T, SugarCarbohydrateCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a SugarCarbohydrate.
     * @param {SugarCarbohydrateDeleteArgs} args - Arguments to delete one SugarCarbohydrate.
     * @example
     * // Delete one SugarCarbohydrate
     * const SugarCarbohydrate = await prisma.sugarCarbohydrate.delete({
     *   where: {
     *     // ... filter to delete one SugarCarbohydrate
     *   }
     * })
     * 
    **/
    delete<T extends SugarCarbohydrateDeleteArgs>(
      args: SelectSubset<T, SugarCarbohydrateDeleteArgs>
    ): CheckSelect<T, Prisma__SugarCarbohydrateClient<SugarCarbohydrate>, Prisma__SugarCarbohydrateClient<SugarCarbohydrateGetPayload<T>>>

    /**
     * Update one SugarCarbohydrate.
     * @param {SugarCarbohydrateUpdateArgs} args - Arguments to update one SugarCarbohydrate.
     * @example
     * // Update one SugarCarbohydrate
     * const sugarCarbohydrate = await prisma.sugarCarbohydrate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SugarCarbohydrateUpdateArgs>(
      args: SelectSubset<T, SugarCarbohydrateUpdateArgs>
    ): CheckSelect<T, Prisma__SugarCarbohydrateClient<SugarCarbohydrate>, Prisma__SugarCarbohydrateClient<SugarCarbohydrateGetPayload<T>>>

    /**
     * Delete zero or more SugarCarbohydrates.
     * @param {SugarCarbohydrateDeleteManyArgs} args - Arguments to filter SugarCarbohydrates to delete.
     * @example
     * // Delete a few SugarCarbohydrates
     * const { count } = await prisma.sugarCarbohydrate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SugarCarbohydrateDeleteManyArgs>(
      args?: SelectSubset<T, SugarCarbohydrateDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more SugarCarbohydrates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SugarCarbohydrateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SugarCarbohydrates
     * const sugarCarbohydrate = await prisma.sugarCarbohydrate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SugarCarbohydrateUpdateManyArgs>(
      args: SelectSubset<T, SugarCarbohydrateUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one SugarCarbohydrate.
     * @param {SugarCarbohydrateUpsertArgs} args - Arguments to update or create a SugarCarbohydrate.
     * @example
     * // Update or create a SugarCarbohydrate
     * const sugarCarbohydrate = await prisma.sugarCarbohydrate.upsert({
     *   create: {
     *     // ... data to create a SugarCarbohydrate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SugarCarbohydrate we want to update
     *   }
     * })
    **/
    upsert<T extends SugarCarbohydrateUpsertArgs>(
      args: SelectSubset<T, SugarCarbohydrateUpsertArgs>
    ): CheckSelect<T, Prisma__SugarCarbohydrateClient<SugarCarbohydrate>, Prisma__SugarCarbohydrateClient<SugarCarbohydrateGetPayload<T>>>

    /**
     * Count the number of SugarCarbohydrates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SugarCarbohydrateCountArgs} args - Arguments to filter SugarCarbohydrates to count.
     * @example
     * // Count the number of SugarCarbohydrates
     * const count = await prisma.sugarCarbohydrate.count({
     *   where: {
     *     // ... the filter for the SugarCarbohydrates we want to count
     *   }
     * })
    **/
    count<T extends SugarCarbohydrateCountArgs>(
      args?: Subset<T, SugarCarbohydrateCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SugarCarbohydrateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SugarCarbohydrate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SugarCarbohydrateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SugarCarbohydrateAggregateArgs>(args: Subset<T, SugarCarbohydrateAggregateArgs>): PrismaPromise<GetSugarCarbohydrateAggregateType<T>>

    /**
     * Group by SugarCarbohydrate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SugarCarbohydrateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SugarCarbohydrateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SugarCarbohydrateGroupByArgs['orderBy'] }
        : { orderBy?: SugarCarbohydrateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SugarCarbohydrateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSugarCarbohydrateGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for SugarCarbohydrate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SugarCarbohydrateClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    carbohydrate<T extends CarbohydrateArgs = {}>(args?: Subset<T, CarbohydrateArgs>): CheckSelect<T, Prisma__CarbohydrateClient<Carbohydrate | null >, Prisma__CarbohydrateClient<CarbohydrateGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * SugarCarbohydrate findUnique
   */
  export type SugarCarbohydrateFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the SugarCarbohydrate
     * 
    **/
    select?: SugarCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SugarCarbohydrateInclude | null
    /**
     * Throw an Error if a SugarCarbohydrate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SugarCarbohydrate to fetch.
     * 
    **/
    where: SugarCarbohydrateWhereUniqueInput
  }


  /**
   * SugarCarbohydrate findFirst
   */
  export type SugarCarbohydrateFindFirstArgs = {
    /**
     * Select specific fields to fetch from the SugarCarbohydrate
     * 
    **/
    select?: SugarCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SugarCarbohydrateInclude | null
    /**
     * Throw an Error if a SugarCarbohydrate can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which SugarCarbohydrate to fetch.
     * 
    **/
    where?: SugarCarbohydrateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SugarCarbohydrates to fetch.
     * 
    **/
    orderBy?: Enumerable<SugarCarbohydrateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SugarCarbohydrates.
     * 
    **/
    cursor?: SugarCarbohydrateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SugarCarbohydrates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SugarCarbohydrates.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SugarCarbohydrates.
     * 
    **/
    distinct?: Enumerable<SugarCarbohydrateScalarFieldEnum>
  }


  /**
   * SugarCarbohydrate findMany
   */
  export type SugarCarbohydrateFindManyArgs = {
    /**
     * Select specific fields to fetch from the SugarCarbohydrate
     * 
    **/
    select?: SugarCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SugarCarbohydrateInclude | null
    /**
     * Filter, which SugarCarbohydrates to fetch.
     * 
    **/
    where?: SugarCarbohydrateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SugarCarbohydrates to fetch.
     * 
    **/
    orderBy?: Enumerable<SugarCarbohydrateOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SugarCarbohydrates.
     * 
    **/
    cursor?: SugarCarbohydrateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SugarCarbohydrates from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SugarCarbohydrates.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SugarCarbohydrateScalarFieldEnum>
  }


  /**
   * SugarCarbohydrate create
   */
  export type SugarCarbohydrateCreateArgs = {
    /**
     * Select specific fields to fetch from the SugarCarbohydrate
     * 
    **/
    select?: SugarCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SugarCarbohydrateInclude | null
    /**
     * The data needed to create a SugarCarbohydrate.
     * 
    **/
    data: XOR<SugarCarbohydrateCreateInput, SugarCarbohydrateUncheckedCreateInput>
  }


  /**
   * SugarCarbohydrate createMany
   */
  export type SugarCarbohydrateCreateManyArgs = {
    /**
     * The data used to create many SugarCarbohydrates.
     * 
    **/
    data: Enumerable<SugarCarbohydrateCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * SugarCarbohydrate update
   */
  export type SugarCarbohydrateUpdateArgs = {
    /**
     * Select specific fields to fetch from the SugarCarbohydrate
     * 
    **/
    select?: SugarCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SugarCarbohydrateInclude | null
    /**
     * The data needed to update a SugarCarbohydrate.
     * 
    **/
    data: XOR<SugarCarbohydrateUpdateInput, SugarCarbohydrateUncheckedUpdateInput>
    /**
     * Choose, which SugarCarbohydrate to update.
     * 
    **/
    where: SugarCarbohydrateWhereUniqueInput
  }


  /**
   * SugarCarbohydrate updateMany
   */
  export type SugarCarbohydrateUpdateManyArgs = {
    /**
     * The data used to update SugarCarbohydrates.
     * 
    **/
    data: XOR<SugarCarbohydrateUpdateManyMutationInput, SugarCarbohydrateUncheckedUpdateManyInput>
    /**
     * Filter which SugarCarbohydrates to update
     * 
    **/
    where?: SugarCarbohydrateWhereInput
  }


  /**
   * SugarCarbohydrate upsert
   */
  export type SugarCarbohydrateUpsertArgs = {
    /**
     * Select specific fields to fetch from the SugarCarbohydrate
     * 
    **/
    select?: SugarCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SugarCarbohydrateInclude | null
    /**
     * The filter to search for the SugarCarbohydrate to update in case it exists.
     * 
    **/
    where: SugarCarbohydrateWhereUniqueInput
    /**
     * In case the SugarCarbohydrate found by the `where` argument doesn't exist, create a new SugarCarbohydrate with this data.
     * 
    **/
    create: XOR<SugarCarbohydrateCreateInput, SugarCarbohydrateUncheckedCreateInput>
    /**
     * In case the SugarCarbohydrate was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SugarCarbohydrateUpdateInput, SugarCarbohydrateUncheckedUpdateInput>
  }


  /**
   * SugarCarbohydrate delete
   */
  export type SugarCarbohydrateDeleteArgs = {
    /**
     * Select specific fields to fetch from the SugarCarbohydrate
     * 
    **/
    select?: SugarCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SugarCarbohydrateInclude | null
    /**
     * Filter which SugarCarbohydrate to delete.
     * 
    **/
    where: SugarCarbohydrateWhereUniqueInput
  }


  /**
   * SugarCarbohydrate deleteMany
   */
  export type SugarCarbohydrateDeleteManyArgs = {
    /**
     * Filter which SugarCarbohydrates to delete
     * 
    **/
    where?: SugarCarbohydrateWhereInput
  }


  /**
   * SugarCarbohydrate without action
   */
  export type SugarCarbohydrateArgs = {
    /**
     * Select specific fields to fetch from the SugarCarbohydrate
     * 
    **/
    select?: SugarCarbohydrateSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SugarCarbohydrateInclude | null
  }



  /**
   * Model Vitamin
   */


  export type AggregateVitamin = {
    _count: VitaminCountAggregateOutputType | null
    _avg: VitaminAvgAggregateOutputType | null
    _sum: VitaminSumAggregateOutputType | null
    _min: VitaminMinAggregateOutputType | null
    _max: VitaminMaxAggregateOutputType | null
  }

  export type VitaminAvgAggregateOutputType = {
    id: number | null
    vitaminCId: number | null
    vitaminAId: number | null
    vitaminDId: number | null
    vitaminEId: number | null
    vitaminB1Id: number | null
    vitaminB2Id: number | null
    vitaminB6Id: number | null
    vitaminB12Id: number | null
  }

  export type VitaminSumAggregateOutputType = {
    id: number | null
    vitaminCId: number | null
    vitaminAId: number | null
    vitaminDId: number | null
    vitaminEId: number | null
    vitaminB1Id: number | null
    vitaminB2Id: number | null
    vitaminB6Id: number | null
    vitaminB12Id: number | null
  }

  export type VitaminMinAggregateOutputType = {
    id: number | null
    vitaminCId: number | null
    vitaminAId: number | null
    vitaminDId: number | null
    vitaminEId: number | null
    vitaminB1Id: number | null
    vitaminB2Id: number | null
    vitaminB6Id: number | null
    vitaminB12Id: number | null
  }

  export type VitaminMaxAggregateOutputType = {
    id: number | null
    vitaminCId: number | null
    vitaminAId: number | null
    vitaminDId: number | null
    vitaminEId: number | null
    vitaminB1Id: number | null
    vitaminB2Id: number | null
    vitaminB6Id: number | null
    vitaminB12Id: number | null
  }

  export type VitaminCountAggregateOutputType = {
    id: number
    vitaminCId: number
    vitaminAId: number
    vitaminDId: number
    vitaminEId: number
    vitaminB1Id: number
    vitaminB2Id: number
    vitaminB6Id: number
    vitaminB12Id: number
    _all: number
  }


  export type VitaminAvgAggregateInputType = {
    id?: true
    vitaminCId?: true
    vitaminAId?: true
    vitaminDId?: true
    vitaminEId?: true
    vitaminB1Id?: true
    vitaminB2Id?: true
    vitaminB6Id?: true
    vitaminB12Id?: true
  }

  export type VitaminSumAggregateInputType = {
    id?: true
    vitaminCId?: true
    vitaminAId?: true
    vitaminDId?: true
    vitaminEId?: true
    vitaminB1Id?: true
    vitaminB2Id?: true
    vitaminB6Id?: true
    vitaminB12Id?: true
  }

  export type VitaminMinAggregateInputType = {
    id?: true
    vitaminCId?: true
    vitaminAId?: true
    vitaminDId?: true
    vitaminEId?: true
    vitaminB1Id?: true
    vitaminB2Id?: true
    vitaminB6Id?: true
    vitaminB12Id?: true
  }

  export type VitaminMaxAggregateInputType = {
    id?: true
    vitaminCId?: true
    vitaminAId?: true
    vitaminDId?: true
    vitaminEId?: true
    vitaminB1Id?: true
    vitaminB2Id?: true
    vitaminB6Id?: true
    vitaminB12Id?: true
  }

  export type VitaminCountAggregateInputType = {
    id?: true
    vitaminCId?: true
    vitaminAId?: true
    vitaminDId?: true
    vitaminEId?: true
    vitaminB1Id?: true
    vitaminB2Id?: true
    vitaminB6Id?: true
    vitaminB12Id?: true
    _all?: true
  }

  export type VitaminAggregateArgs = {
    /**
     * Filter which Vitamin to aggregate.
     * 
    **/
    where?: VitaminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vitamins to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VitaminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vitamins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vitamins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vitamins
    **/
    _count?: true | VitaminCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitaminAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitaminSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitaminMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitaminMaxAggregateInputType
  }

  export type GetVitaminAggregateType<T extends VitaminAggregateArgs> = {
        [P in keyof T & keyof AggregateVitamin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitamin[P]>
      : GetScalarType<T[P], AggregateVitamin[P]>
  }




  export type VitaminGroupByArgs = {
    where?: VitaminWhereInput
    orderBy?: Enumerable<VitaminOrderByWithAggregationInput>
    by: Array<VitaminScalarFieldEnum>
    having?: VitaminScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitaminCountAggregateInputType | true
    _avg?: VitaminAvgAggregateInputType
    _sum?: VitaminSumAggregateInputType
    _min?: VitaminMinAggregateInputType
    _max?: VitaminMaxAggregateInputType
  }


  export type VitaminGroupByOutputType = {
    id: number
    vitaminCId: number | null
    vitaminAId: number | null
    vitaminDId: number | null
    vitaminEId: number | null
    vitaminB1Id: number | null
    vitaminB2Id: number | null
    vitaminB6Id: number | null
    vitaminB12Id: number | null
    _count: VitaminCountAggregateOutputType | null
    _avg: VitaminAvgAggregateOutputType | null
    _sum: VitaminSumAggregateOutputType | null
    _min: VitaminMinAggregateOutputType | null
    _max: VitaminMaxAggregateOutputType | null
  }

  type GetVitaminGroupByPayload<T extends VitaminGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VitaminGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitaminGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitaminGroupByOutputType[P]>
            : GetScalarType<T[P], VitaminGroupByOutputType[P]>
        }
      >
    >


  export type VitaminSelect = {
    id?: boolean
    C?: boolean | VitaminCArgs
    A?: boolean | VitaminAArgs
    D?: boolean | VitaminDArgs
    E?: boolean | VitaminEArgs
    B1?: boolean | VitaminB1Args
    B2?: boolean | VitaminB2Args
    B6?: boolean | VitaminB6Args
    B12?: boolean | VitaminB12Args
    nutritionFacts?: boolean | NutritionFactFindManyArgs
    vitaminCId?: boolean
    vitaminAId?: boolean
    vitaminDId?: boolean
    vitaminEId?: boolean
    vitaminB1Id?: boolean
    vitaminB2Id?: boolean
    vitaminB6Id?: boolean
    vitaminB12Id?: boolean
    measurements?: boolean | MeasurementFindManyArgs
    _count?: boolean | VitaminCountOutputTypeArgs
  }

  export type VitaminInclude = {
    C?: boolean | VitaminCArgs
    A?: boolean | VitaminAArgs
    D?: boolean | VitaminDArgs
    E?: boolean | VitaminEArgs
    B1?: boolean | VitaminB1Args
    B2?: boolean | VitaminB2Args
    B6?: boolean | VitaminB6Args
    B12?: boolean | VitaminB12Args
    nutritionFacts?: boolean | NutritionFactFindManyArgs
    measurements?: boolean | MeasurementFindManyArgs
    _count?: boolean | VitaminCountOutputTypeArgs
  }

  export type VitaminGetPayload<
    S extends boolean | null | undefined | VitaminArgs,
    U = keyof S
      > = S extends true
        ? Vitamin
    : S extends undefined
    ? never
    : S extends VitaminArgs | VitaminFindManyArgs
    ?'include' extends U
    ? Vitamin  & {
    [P in TrueKeys<S['include']>]:
        P extends 'C' ? VitaminCGetPayload<S['include'][P]> | null :
        P extends 'A' ? VitaminAGetPayload<S['include'][P]> | null :
        P extends 'D' ? VitaminDGetPayload<S['include'][P]> | null :
        P extends 'E' ? VitaminEGetPayload<S['include'][P]> | null :
        P extends 'B1' ? VitaminB1GetPayload<S['include'][P]> | null :
        P extends 'B2' ? VitaminB2GetPayload<S['include'][P]> | null :
        P extends 'B6' ? VitaminB6GetPayload<S['include'][P]> | null :
        P extends 'B12' ? VitaminB12GetPayload<S['include'][P]> | null :
        P extends 'nutritionFacts' ? Array < NutritionFactGetPayload<S['include'][P]>>  :
        P extends 'measurements' ? Array < MeasurementGetPayload<S['include'][P]>>  :
        P extends '_count' ? VitaminCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'C' ? VitaminCGetPayload<S['select'][P]> | null :
        P extends 'A' ? VitaminAGetPayload<S['select'][P]> | null :
        P extends 'D' ? VitaminDGetPayload<S['select'][P]> | null :
        P extends 'E' ? VitaminEGetPayload<S['select'][P]> | null :
        P extends 'B1' ? VitaminB1GetPayload<S['select'][P]> | null :
        P extends 'B2' ? VitaminB2GetPayload<S['select'][P]> | null :
        P extends 'B6' ? VitaminB6GetPayload<S['select'][P]> | null :
        P extends 'B12' ? VitaminB12GetPayload<S['select'][P]> | null :
        P extends 'nutritionFacts' ? Array < NutritionFactGetPayload<S['select'][P]>>  :
        P extends 'measurements' ? Array < MeasurementGetPayload<S['select'][P]>>  :
        P extends '_count' ? VitaminCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Vitamin ? Vitamin[P] : never
  } 
    : Vitamin
  : Vitamin


  type VitaminCountArgs = Merge<
    Omit<VitaminFindManyArgs, 'select' | 'include'> & {
      select?: VitaminCountAggregateInputType | true
    }
  >

  export interface VitaminDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Vitamin that matches the filter.
     * @param {VitaminFindUniqueArgs} args - Arguments to find a Vitamin
     * @example
     * // Get one Vitamin
     * const vitamin = await prisma.vitamin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VitaminFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VitaminFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Vitamin'> extends True ? CheckSelect<T, Prisma__VitaminClient<Vitamin>, Prisma__VitaminClient<VitaminGetPayload<T>>> : CheckSelect<T, Prisma__VitaminClient<Vitamin | null >, Prisma__VitaminClient<VitaminGetPayload<T> | null >>

    /**
     * Find the first Vitamin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminFindFirstArgs} args - Arguments to find a Vitamin
     * @example
     * // Get one Vitamin
     * const vitamin = await prisma.vitamin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VitaminFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VitaminFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Vitamin'> extends True ? CheckSelect<T, Prisma__VitaminClient<Vitamin>, Prisma__VitaminClient<VitaminGetPayload<T>>> : CheckSelect<T, Prisma__VitaminClient<Vitamin | null >, Prisma__VitaminClient<VitaminGetPayload<T> | null >>

    /**
     * Find zero or more Vitamins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vitamins
     * const vitamins = await prisma.vitamin.findMany()
     * 
     * // Get first 10 Vitamins
     * const vitamins = await prisma.vitamin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitaminWithIdOnly = await prisma.vitamin.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VitaminFindManyArgs>(
      args?: SelectSubset<T, VitaminFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Vitamin>>, PrismaPromise<Array<VitaminGetPayload<T>>>>

    /**
     * Create a Vitamin.
     * @param {VitaminCreateArgs} args - Arguments to create a Vitamin.
     * @example
     * // Create one Vitamin
     * const Vitamin = await prisma.vitamin.create({
     *   data: {
     *     // ... data to create a Vitamin
     *   }
     * })
     * 
    **/
    create<T extends VitaminCreateArgs>(
      args: SelectSubset<T, VitaminCreateArgs>
    ): CheckSelect<T, Prisma__VitaminClient<Vitamin>, Prisma__VitaminClient<VitaminGetPayload<T>>>

    /**
     * Create many Vitamins.
     *     @param {VitaminCreateManyArgs} args - Arguments to create many Vitamins.
     *     @example
     *     // Create many Vitamins
     *     const vitamin = await prisma.vitamin.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VitaminCreateManyArgs>(
      args?: SelectSubset<T, VitaminCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Vitamin.
     * @param {VitaminDeleteArgs} args - Arguments to delete one Vitamin.
     * @example
     * // Delete one Vitamin
     * const Vitamin = await prisma.vitamin.delete({
     *   where: {
     *     // ... filter to delete one Vitamin
     *   }
     * })
     * 
    **/
    delete<T extends VitaminDeleteArgs>(
      args: SelectSubset<T, VitaminDeleteArgs>
    ): CheckSelect<T, Prisma__VitaminClient<Vitamin>, Prisma__VitaminClient<VitaminGetPayload<T>>>

    /**
     * Update one Vitamin.
     * @param {VitaminUpdateArgs} args - Arguments to update one Vitamin.
     * @example
     * // Update one Vitamin
     * const vitamin = await prisma.vitamin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VitaminUpdateArgs>(
      args: SelectSubset<T, VitaminUpdateArgs>
    ): CheckSelect<T, Prisma__VitaminClient<Vitamin>, Prisma__VitaminClient<VitaminGetPayload<T>>>

    /**
     * Delete zero or more Vitamins.
     * @param {VitaminDeleteManyArgs} args - Arguments to filter Vitamins to delete.
     * @example
     * // Delete a few Vitamins
     * const { count } = await prisma.vitamin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VitaminDeleteManyArgs>(
      args?: SelectSubset<T, VitaminDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vitamins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vitamins
     * const vitamin = await prisma.vitamin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VitaminUpdateManyArgs>(
      args: SelectSubset<T, VitaminUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Vitamin.
     * @param {VitaminUpsertArgs} args - Arguments to update or create a Vitamin.
     * @example
     * // Update or create a Vitamin
     * const vitamin = await prisma.vitamin.upsert({
     *   create: {
     *     // ... data to create a Vitamin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vitamin we want to update
     *   }
     * })
    **/
    upsert<T extends VitaminUpsertArgs>(
      args: SelectSubset<T, VitaminUpsertArgs>
    ): CheckSelect<T, Prisma__VitaminClient<Vitamin>, Prisma__VitaminClient<VitaminGetPayload<T>>>

    /**
     * Count the number of Vitamins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminCountArgs} args - Arguments to filter Vitamins to count.
     * @example
     * // Count the number of Vitamins
     * const count = await prisma.vitamin.count({
     *   where: {
     *     // ... the filter for the Vitamins we want to count
     *   }
     * })
    **/
    count<T extends VitaminCountArgs>(
      args?: Subset<T, VitaminCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitaminCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vitamin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitaminAggregateArgs>(args: Subset<T, VitaminAggregateArgs>): PrismaPromise<GetVitaminAggregateType<T>>

    /**
     * Group by Vitamin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitaminGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitaminGroupByArgs['orderBy'] }
        : { orderBy?: VitaminGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitaminGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitaminGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vitamin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VitaminClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    C<T extends VitaminCArgs = {}>(args?: Subset<T, VitaminCArgs>): CheckSelect<T, Prisma__VitaminCClient<VitaminC | null >, Prisma__VitaminCClient<VitaminCGetPayload<T> | null >>;

    A<T extends VitaminAArgs = {}>(args?: Subset<T, VitaminAArgs>): CheckSelect<T, Prisma__VitaminAClient<VitaminA | null >, Prisma__VitaminAClient<VitaminAGetPayload<T> | null >>;

    D<T extends VitaminDArgs = {}>(args?: Subset<T, VitaminDArgs>): CheckSelect<T, Prisma__VitaminDClient<VitaminD | null >, Prisma__VitaminDClient<VitaminDGetPayload<T> | null >>;

    E<T extends VitaminEArgs = {}>(args?: Subset<T, VitaminEArgs>): CheckSelect<T, Prisma__VitaminEClient<VitaminE | null >, Prisma__VitaminEClient<VitaminEGetPayload<T> | null >>;

    B1<T extends VitaminB1Args = {}>(args?: Subset<T, VitaminB1Args>): CheckSelect<T, Prisma__VitaminB1Client<VitaminB1 | null >, Prisma__VitaminB1Client<VitaminB1GetPayload<T> | null >>;

    B2<T extends VitaminB2Args = {}>(args?: Subset<T, VitaminB2Args>): CheckSelect<T, Prisma__VitaminB2Client<VitaminB2 | null >, Prisma__VitaminB2Client<VitaminB2GetPayload<T> | null >>;

    B6<T extends VitaminB6Args = {}>(args?: Subset<T, VitaminB6Args>): CheckSelect<T, Prisma__VitaminB6Client<VitaminB6 | null >, Prisma__VitaminB6Client<VitaminB6GetPayload<T> | null >>;

    B12<T extends VitaminB12Args = {}>(args?: Subset<T, VitaminB12Args>): CheckSelect<T, Prisma__VitaminB12Client<VitaminB12 | null >, Prisma__VitaminB12Client<VitaminB12GetPayload<T> | null >>;

    nutritionFacts<T extends NutritionFactFindManyArgs = {}>(args?: Subset<T, NutritionFactFindManyArgs>): CheckSelect<T, PrismaPromise<Array<NutritionFact>>, PrismaPromise<Array<NutritionFactGetPayload<T>>>>;

    measurements<T extends MeasurementFindManyArgs = {}>(args?: Subset<T, MeasurementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Measurement>>, PrismaPromise<Array<MeasurementGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Vitamin findUnique
   */
  export type VitaminFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Vitamin
     * 
    **/
    select?: VitaminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminInclude | null
    /**
     * Throw an Error if a Vitamin can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Vitamin to fetch.
     * 
    **/
    where: VitaminWhereUniqueInput
  }


  /**
   * Vitamin findFirst
   */
  export type VitaminFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Vitamin
     * 
    **/
    select?: VitaminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminInclude | null
    /**
     * Throw an Error if a Vitamin can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Vitamin to fetch.
     * 
    **/
    where?: VitaminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vitamins to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vitamins.
     * 
    **/
    cursor?: VitaminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vitamins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vitamins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vitamins.
     * 
    **/
    distinct?: Enumerable<VitaminScalarFieldEnum>
  }


  /**
   * Vitamin findMany
   */
  export type VitaminFindManyArgs = {
    /**
     * Select specific fields to fetch from the Vitamin
     * 
    **/
    select?: VitaminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminInclude | null
    /**
     * Filter, which Vitamins to fetch.
     * 
    **/
    where?: VitaminWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vitamins to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vitamins.
     * 
    **/
    cursor?: VitaminWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vitamins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vitamins.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VitaminScalarFieldEnum>
  }


  /**
   * Vitamin create
   */
  export type VitaminCreateArgs = {
    /**
     * Select specific fields to fetch from the Vitamin
     * 
    **/
    select?: VitaminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminInclude | null
    /**
     * The data needed to create a Vitamin.
     * 
    **/
    data: XOR<VitaminCreateInput, VitaminUncheckedCreateInput>
  }


  /**
   * Vitamin createMany
   */
  export type VitaminCreateManyArgs = {
    /**
     * The data used to create many Vitamins.
     * 
    **/
    data: Enumerable<VitaminCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Vitamin update
   */
  export type VitaminUpdateArgs = {
    /**
     * Select specific fields to fetch from the Vitamin
     * 
    **/
    select?: VitaminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminInclude | null
    /**
     * The data needed to update a Vitamin.
     * 
    **/
    data: XOR<VitaminUpdateInput, VitaminUncheckedUpdateInput>
    /**
     * Choose, which Vitamin to update.
     * 
    **/
    where: VitaminWhereUniqueInput
  }


  /**
   * Vitamin updateMany
   */
  export type VitaminUpdateManyArgs = {
    /**
     * The data used to update Vitamins.
     * 
    **/
    data: XOR<VitaminUpdateManyMutationInput, VitaminUncheckedUpdateManyInput>
    /**
     * Filter which Vitamins to update
     * 
    **/
    where?: VitaminWhereInput
  }


  /**
   * Vitamin upsert
   */
  export type VitaminUpsertArgs = {
    /**
     * Select specific fields to fetch from the Vitamin
     * 
    **/
    select?: VitaminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminInclude | null
    /**
     * The filter to search for the Vitamin to update in case it exists.
     * 
    **/
    where: VitaminWhereUniqueInput
    /**
     * In case the Vitamin found by the `where` argument doesn't exist, create a new Vitamin with this data.
     * 
    **/
    create: XOR<VitaminCreateInput, VitaminUncheckedCreateInput>
    /**
     * In case the Vitamin was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VitaminUpdateInput, VitaminUncheckedUpdateInput>
  }


  /**
   * Vitamin delete
   */
  export type VitaminDeleteArgs = {
    /**
     * Select specific fields to fetch from the Vitamin
     * 
    **/
    select?: VitaminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminInclude | null
    /**
     * Filter which Vitamin to delete.
     * 
    **/
    where: VitaminWhereUniqueInput
  }


  /**
   * Vitamin deleteMany
   */
  export type VitaminDeleteManyArgs = {
    /**
     * Filter which Vitamins to delete
     * 
    **/
    where?: VitaminWhereInput
  }


  /**
   * Vitamin without action
   */
  export type VitaminArgs = {
    /**
     * Select specific fields to fetch from the Vitamin
     * 
    **/
    select?: VitaminSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminInclude | null
  }



  /**
   * Model VitaminC
   */


  export type AggregateVitaminC = {
    _count: VitaminCCountAggregateOutputType | null
    _avg: VitaminCAvgAggregateOutputType | null
    _sum: VitaminCSumAggregateOutputType | null
    _min: VitaminCMinAggregateOutputType | null
    _max: VitaminCMaxAggregateOutputType | null
  }

  export type VitaminCAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminCSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminCMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminCMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminCCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type VitaminCAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminCSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminCMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminCMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminCCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type VitaminCAggregateArgs = {
    /**
     * Filter which VitaminC to aggregate.
     * 
    **/
    where?: VitaminCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminCS to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminCOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VitaminCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminCS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminCS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VitaminCS
    **/
    _count?: true | VitaminCCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitaminCAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitaminCSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitaminCMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitaminCMaxAggregateInputType
  }

  export type GetVitaminCAggregateType<T extends VitaminCAggregateArgs> = {
        [P in keyof T & keyof AggregateVitaminC]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitaminC[P]>
      : GetScalarType<T[P], AggregateVitaminC[P]>
  }




  export type VitaminCGroupByArgs = {
    where?: VitaminCWhereInput
    orderBy?: Enumerable<VitaminCOrderByWithAggregationInput>
    by: Array<VitaminCScalarFieldEnum>
    having?: VitaminCScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitaminCCountAggregateInputType | true
    _avg?: VitaminCAvgAggregateInputType
    _sum?: VitaminCSumAggregateInputType
    _min?: VitaminCMinAggregateInputType
    _max?: VitaminCMaxAggregateInputType
  }


  export type VitaminCGroupByOutputType = {
    id: number
    measurementId: number
    _count: VitaminCCountAggregateOutputType | null
    _avg: VitaminCAvgAggregateOutputType | null
    _sum: VitaminCSumAggregateOutputType | null
    _min: VitaminCMinAggregateOutputType | null
    _max: VitaminCMaxAggregateOutputType | null
  }

  type GetVitaminCGroupByPayload<T extends VitaminCGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VitaminCGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitaminCGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitaminCGroupByOutputType[P]>
            : GetScalarType<T[P], VitaminCGroupByOutputType[P]>
        }
      >
    >


  export type VitaminCSelect = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
    measurementId?: boolean
  }

  export type VitaminCInclude = {
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
  }

  export type VitaminCGetPayload<
    S extends boolean | null | undefined | VitaminCArgs,
    U = keyof S
      > = S extends true
        ? VitaminC
    : S extends undefined
    ? never
    : S extends VitaminCArgs | VitaminCFindManyArgs
    ?'include' extends U
    ? VitaminC  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['select'][P]> | null :  P extends keyof VitaminC ? VitaminC[P] : never
  } 
    : VitaminC
  : VitaminC


  type VitaminCCountArgs = Merge<
    Omit<VitaminCFindManyArgs, 'select' | 'include'> & {
      select?: VitaminCCountAggregateInputType | true
    }
  >

  export interface VitaminCDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one VitaminC that matches the filter.
     * @param {VitaminCFindUniqueArgs} args - Arguments to find a VitaminC
     * @example
     * // Get one VitaminC
     * const vitaminC = await prisma.vitaminC.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VitaminCFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VitaminCFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VitaminC'> extends True ? CheckSelect<T, Prisma__VitaminCClient<VitaminC>, Prisma__VitaminCClient<VitaminCGetPayload<T>>> : CheckSelect<T, Prisma__VitaminCClient<VitaminC | null >, Prisma__VitaminCClient<VitaminCGetPayload<T> | null >>

    /**
     * Find the first VitaminC that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminCFindFirstArgs} args - Arguments to find a VitaminC
     * @example
     * // Get one VitaminC
     * const vitaminC = await prisma.vitaminC.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VitaminCFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VitaminCFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VitaminC'> extends True ? CheckSelect<T, Prisma__VitaminCClient<VitaminC>, Prisma__VitaminCClient<VitaminCGetPayload<T>>> : CheckSelect<T, Prisma__VitaminCClient<VitaminC | null >, Prisma__VitaminCClient<VitaminCGetPayload<T> | null >>

    /**
     * Find zero or more VitaminCS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminCFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VitaminCS
     * const vitaminCS = await prisma.vitaminC.findMany()
     * 
     * // Get first 10 VitaminCS
     * const vitaminCS = await prisma.vitaminC.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitaminCWithIdOnly = await prisma.vitaminC.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VitaminCFindManyArgs>(
      args?: SelectSubset<T, VitaminCFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VitaminC>>, PrismaPromise<Array<VitaminCGetPayload<T>>>>

    /**
     * Create a VitaminC.
     * @param {VitaminCCreateArgs} args - Arguments to create a VitaminC.
     * @example
     * // Create one VitaminC
     * const VitaminC = await prisma.vitaminC.create({
     *   data: {
     *     // ... data to create a VitaminC
     *   }
     * })
     * 
    **/
    create<T extends VitaminCCreateArgs>(
      args: SelectSubset<T, VitaminCCreateArgs>
    ): CheckSelect<T, Prisma__VitaminCClient<VitaminC>, Prisma__VitaminCClient<VitaminCGetPayload<T>>>

    /**
     * Create many VitaminCS.
     *     @param {VitaminCCreateManyArgs} args - Arguments to create many VitaminCS.
     *     @example
     *     // Create many VitaminCS
     *     const vitaminC = await prisma.vitaminC.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VitaminCCreateManyArgs>(
      args?: SelectSubset<T, VitaminCCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VitaminC.
     * @param {VitaminCDeleteArgs} args - Arguments to delete one VitaminC.
     * @example
     * // Delete one VitaminC
     * const VitaminC = await prisma.vitaminC.delete({
     *   where: {
     *     // ... filter to delete one VitaminC
     *   }
     * })
     * 
    **/
    delete<T extends VitaminCDeleteArgs>(
      args: SelectSubset<T, VitaminCDeleteArgs>
    ): CheckSelect<T, Prisma__VitaminCClient<VitaminC>, Prisma__VitaminCClient<VitaminCGetPayload<T>>>

    /**
     * Update one VitaminC.
     * @param {VitaminCUpdateArgs} args - Arguments to update one VitaminC.
     * @example
     * // Update one VitaminC
     * const vitaminC = await prisma.vitaminC.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VitaminCUpdateArgs>(
      args: SelectSubset<T, VitaminCUpdateArgs>
    ): CheckSelect<T, Prisma__VitaminCClient<VitaminC>, Prisma__VitaminCClient<VitaminCGetPayload<T>>>

    /**
     * Delete zero or more VitaminCS.
     * @param {VitaminCDeleteManyArgs} args - Arguments to filter VitaminCS to delete.
     * @example
     * // Delete a few VitaminCS
     * const { count } = await prisma.vitaminC.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VitaminCDeleteManyArgs>(
      args?: SelectSubset<T, VitaminCDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitaminCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminCUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VitaminCS
     * const vitaminC = await prisma.vitaminC.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VitaminCUpdateManyArgs>(
      args: SelectSubset<T, VitaminCUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VitaminC.
     * @param {VitaminCUpsertArgs} args - Arguments to update or create a VitaminC.
     * @example
     * // Update or create a VitaminC
     * const vitaminC = await prisma.vitaminC.upsert({
     *   create: {
     *     // ... data to create a VitaminC
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VitaminC we want to update
     *   }
     * })
    **/
    upsert<T extends VitaminCUpsertArgs>(
      args: SelectSubset<T, VitaminCUpsertArgs>
    ): CheckSelect<T, Prisma__VitaminCClient<VitaminC>, Prisma__VitaminCClient<VitaminCGetPayload<T>>>

    /**
     * Count the number of VitaminCS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminCCountArgs} args - Arguments to filter VitaminCS to count.
     * @example
     * // Count the number of VitaminCS
     * const count = await prisma.vitaminC.count({
     *   where: {
     *     // ... the filter for the VitaminCS we want to count
     *   }
     * })
    **/
    count<T extends VitaminCCountArgs>(
      args?: Subset<T, VitaminCCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitaminCCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VitaminC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminCAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitaminCAggregateArgs>(args: Subset<T, VitaminCAggregateArgs>): PrismaPromise<GetVitaminCAggregateType<T>>

    /**
     * Group by VitaminC.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminCGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitaminCGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitaminCGroupByArgs['orderBy'] }
        : { orderBy?: VitaminCGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitaminCGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitaminCGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VitaminC.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VitaminCClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    vitamin<T extends VitaminArgs = {}>(args?: Subset<T, VitaminArgs>): CheckSelect<T, Prisma__VitaminClient<Vitamin | null >, Prisma__VitaminClient<VitaminGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VitaminC findUnique
   */
  export type VitaminCFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VitaminC
     * 
    **/
    select?: VitaminCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminCInclude | null
    /**
     * Throw an Error if a VitaminC can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminC to fetch.
     * 
    **/
    where: VitaminCWhereUniqueInput
  }


  /**
   * VitaminC findFirst
   */
  export type VitaminCFindFirstArgs = {
    /**
     * Select specific fields to fetch from the VitaminC
     * 
    **/
    select?: VitaminCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminCInclude | null
    /**
     * Throw an Error if a VitaminC can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminC to fetch.
     * 
    **/
    where?: VitaminCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminCS to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminCOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitaminCS.
     * 
    **/
    cursor?: VitaminCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminCS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminCS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitaminCS.
     * 
    **/
    distinct?: Enumerable<VitaminCScalarFieldEnum>
  }


  /**
   * VitaminC findMany
   */
  export type VitaminCFindManyArgs = {
    /**
     * Select specific fields to fetch from the VitaminC
     * 
    **/
    select?: VitaminCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminCInclude | null
    /**
     * Filter, which VitaminCS to fetch.
     * 
    **/
    where?: VitaminCWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminCS to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminCOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VitaminCS.
     * 
    **/
    cursor?: VitaminCWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminCS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminCS.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VitaminCScalarFieldEnum>
  }


  /**
   * VitaminC create
   */
  export type VitaminCCreateArgs = {
    /**
     * Select specific fields to fetch from the VitaminC
     * 
    **/
    select?: VitaminCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminCInclude | null
    /**
     * The data needed to create a VitaminC.
     * 
    **/
    data: XOR<VitaminCCreateInput, VitaminCUncheckedCreateInput>
  }


  /**
   * VitaminC createMany
   */
  export type VitaminCCreateManyArgs = {
    /**
     * The data used to create many VitaminCS.
     * 
    **/
    data: Enumerable<VitaminCCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VitaminC update
   */
  export type VitaminCUpdateArgs = {
    /**
     * Select specific fields to fetch from the VitaminC
     * 
    **/
    select?: VitaminCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminCInclude | null
    /**
     * The data needed to update a VitaminC.
     * 
    **/
    data: XOR<VitaminCUpdateInput, VitaminCUncheckedUpdateInput>
    /**
     * Choose, which VitaminC to update.
     * 
    **/
    where: VitaminCWhereUniqueInput
  }


  /**
   * VitaminC updateMany
   */
  export type VitaminCUpdateManyArgs = {
    /**
     * The data used to update VitaminCS.
     * 
    **/
    data: XOR<VitaminCUpdateManyMutationInput, VitaminCUncheckedUpdateManyInput>
    /**
     * Filter which VitaminCS to update
     * 
    **/
    where?: VitaminCWhereInput
  }


  /**
   * VitaminC upsert
   */
  export type VitaminCUpsertArgs = {
    /**
     * Select specific fields to fetch from the VitaminC
     * 
    **/
    select?: VitaminCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminCInclude | null
    /**
     * The filter to search for the VitaminC to update in case it exists.
     * 
    **/
    where: VitaminCWhereUniqueInput
    /**
     * In case the VitaminC found by the `where` argument doesn't exist, create a new VitaminC with this data.
     * 
    **/
    create: XOR<VitaminCCreateInput, VitaminCUncheckedCreateInput>
    /**
     * In case the VitaminC was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VitaminCUpdateInput, VitaminCUncheckedUpdateInput>
  }


  /**
   * VitaminC delete
   */
  export type VitaminCDeleteArgs = {
    /**
     * Select specific fields to fetch from the VitaminC
     * 
    **/
    select?: VitaminCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminCInclude | null
    /**
     * Filter which VitaminC to delete.
     * 
    **/
    where: VitaminCWhereUniqueInput
  }


  /**
   * VitaminC deleteMany
   */
  export type VitaminCDeleteManyArgs = {
    /**
     * Filter which VitaminCS to delete
     * 
    **/
    where?: VitaminCWhereInput
  }


  /**
   * VitaminC without action
   */
  export type VitaminCArgs = {
    /**
     * Select specific fields to fetch from the VitaminC
     * 
    **/
    select?: VitaminCSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminCInclude | null
  }



  /**
   * Model VitaminA
   */


  export type AggregateVitaminA = {
    _count: VitaminACountAggregateOutputType | null
    _avg: VitaminAAvgAggregateOutputType | null
    _sum: VitaminASumAggregateOutputType | null
    _min: VitaminAMinAggregateOutputType | null
    _max: VitaminAMaxAggregateOutputType | null
  }

  export type VitaminAAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminASumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminAMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminAMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminACountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type VitaminAAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminASumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminAMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminAMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminACountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type VitaminAAggregateArgs = {
    /**
     * Filter which VitaminA to aggregate.
     * 
    **/
    where?: VitaminAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminAS to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminAOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VitaminAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminAS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminAS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VitaminAS
    **/
    _count?: true | VitaminACountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitaminAAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitaminASumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitaminAMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitaminAMaxAggregateInputType
  }

  export type GetVitaminAAggregateType<T extends VitaminAAggregateArgs> = {
        [P in keyof T & keyof AggregateVitaminA]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitaminA[P]>
      : GetScalarType<T[P], AggregateVitaminA[P]>
  }




  export type VitaminAGroupByArgs = {
    where?: VitaminAWhereInput
    orderBy?: Enumerable<VitaminAOrderByWithAggregationInput>
    by: Array<VitaminAScalarFieldEnum>
    having?: VitaminAScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitaminACountAggregateInputType | true
    _avg?: VitaminAAvgAggregateInputType
    _sum?: VitaminASumAggregateInputType
    _min?: VitaminAMinAggregateInputType
    _max?: VitaminAMaxAggregateInputType
  }


  export type VitaminAGroupByOutputType = {
    id: number
    measurementId: number
    _count: VitaminACountAggregateOutputType | null
    _avg: VitaminAAvgAggregateOutputType | null
    _sum: VitaminASumAggregateOutputType | null
    _min: VitaminAMinAggregateOutputType | null
    _max: VitaminAMaxAggregateOutputType | null
  }

  type GetVitaminAGroupByPayload<T extends VitaminAGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VitaminAGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitaminAGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitaminAGroupByOutputType[P]>
            : GetScalarType<T[P], VitaminAGroupByOutputType[P]>
        }
      >
    >


  export type VitaminASelect = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
    measurementId?: boolean
  }

  export type VitaminAInclude = {
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
  }

  export type VitaminAGetPayload<
    S extends boolean | null | undefined | VitaminAArgs,
    U = keyof S
      > = S extends true
        ? VitaminA
    : S extends undefined
    ? never
    : S extends VitaminAArgs | VitaminAFindManyArgs
    ?'include' extends U
    ? VitaminA  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['select'][P]> | null :  P extends keyof VitaminA ? VitaminA[P] : never
  } 
    : VitaminA
  : VitaminA


  type VitaminACountArgs = Merge<
    Omit<VitaminAFindManyArgs, 'select' | 'include'> & {
      select?: VitaminACountAggregateInputType | true
    }
  >

  export interface VitaminADelegate<GlobalRejectSettings> {
    /**
     * Find zero or one VitaminA that matches the filter.
     * @param {VitaminAFindUniqueArgs} args - Arguments to find a VitaminA
     * @example
     * // Get one VitaminA
     * const vitaminA = await prisma.vitaminA.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VitaminAFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VitaminAFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VitaminA'> extends True ? CheckSelect<T, Prisma__VitaminAClient<VitaminA>, Prisma__VitaminAClient<VitaminAGetPayload<T>>> : CheckSelect<T, Prisma__VitaminAClient<VitaminA | null >, Prisma__VitaminAClient<VitaminAGetPayload<T> | null >>

    /**
     * Find the first VitaminA that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminAFindFirstArgs} args - Arguments to find a VitaminA
     * @example
     * // Get one VitaminA
     * const vitaminA = await prisma.vitaminA.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VitaminAFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VitaminAFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VitaminA'> extends True ? CheckSelect<T, Prisma__VitaminAClient<VitaminA>, Prisma__VitaminAClient<VitaminAGetPayload<T>>> : CheckSelect<T, Prisma__VitaminAClient<VitaminA | null >, Prisma__VitaminAClient<VitaminAGetPayload<T> | null >>

    /**
     * Find zero or more VitaminAS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminAFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VitaminAS
     * const vitaminAS = await prisma.vitaminA.findMany()
     * 
     * // Get first 10 VitaminAS
     * const vitaminAS = await prisma.vitaminA.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitaminAWithIdOnly = await prisma.vitaminA.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VitaminAFindManyArgs>(
      args?: SelectSubset<T, VitaminAFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VitaminA>>, PrismaPromise<Array<VitaminAGetPayload<T>>>>

    /**
     * Create a VitaminA.
     * @param {VitaminACreateArgs} args - Arguments to create a VitaminA.
     * @example
     * // Create one VitaminA
     * const VitaminA = await prisma.vitaminA.create({
     *   data: {
     *     // ... data to create a VitaminA
     *   }
     * })
     * 
    **/
    create<T extends VitaminACreateArgs>(
      args: SelectSubset<T, VitaminACreateArgs>
    ): CheckSelect<T, Prisma__VitaminAClient<VitaminA>, Prisma__VitaminAClient<VitaminAGetPayload<T>>>

    /**
     * Create many VitaminAS.
     *     @param {VitaminACreateManyArgs} args - Arguments to create many VitaminAS.
     *     @example
     *     // Create many VitaminAS
     *     const vitaminA = await prisma.vitaminA.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VitaminACreateManyArgs>(
      args?: SelectSubset<T, VitaminACreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VitaminA.
     * @param {VitaminADeleteArgs} args - Arguments to delete one VitaminA.
     * @example
     * // Delete one VitaminA
     * const VitaminA = await prisma.vitaminA.delete({
     *   where: {
     *     // ... filter to delete one VitaminA
     *   }
     * })
     * 
    **/
    delete<T extends VitaminADeleteArgs>(
      args: SelectSubset<T, VitaminADeleteArgs>
    ): CheckSelect<T, Prisma__VitaminAClient<VitaminA>, Prisma__VitaminAClient<VitaminAGetPayload<T>>>

    /**
     * Update one VitaminA.
     * @param {VitaminAUpdateArgs} args - Arguments to update one VitaminA.
     * @example
     * // Update one VitaminA
     * const vitaminA = await prisma.vitaminA.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VitaminAUpdateArgs>(
      args: SelectSubset<T, VitaminAUpdateArgs>
    ): CheckSelect<T, Prisma__VitaminAClient<VitaminA>, Prisma__VitaminAClient<VitaminAGetPayload<T>>>

    /**
     * Delete zero or more VitaminAS.
     * @param {VitaminADeleteManyArgs} args - Arguments to filter VitaminAS to delete.
     * @example
     * // Delete a few VitaminAS
     * const { count } = await prisma.vitaminA.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VitaminADeleteManyArgs>(
      args?: SelectSubset<T, VitaminADeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitaminAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminAUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VitaminAS
     * const vitaminA = await prisma.vitaminA.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VitaminAUpdateManyArgs>(
      args: SelectSubset<T, VitaminAUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VitaminA.
     * @param {VitaminAUpsertArgs} args - Arguments to update or create a VitaminA.
     * @example
     * // Update or create a VitaminA
     * const vitaminA = await prisma.vitaminA.upsert({
     *   create: {
     *     // ... data to create a VitaminA
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VitaminA we want to update
     *   }
     * })
    **/
    upsert<T extends VitaminAUpsertArgs>(
      args: SelectSubset<T, VitaminAUpsertArgs>
    ): CheckSelect<T, Prisma__VitaminAClient<VitaminA>, Prisma__VitaminAClient<VitaminAGetPayload<T>>>

    /**
     * Count the number of VitaminAS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminACountArgs} args - Arguments to filter VitaminAS to count.
     * @example
     * // Count the number of VitaminAS
     * const count = await prisma.vitaminA.count({
     *   where: {
     *     // ... the filter for the VitaminAS we want to count
     *   }
     * })
    **/
    count<T extends VitaminACountArgs>(
      args?: Subset<T, VitaminACountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitaminACountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VitaminA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminAAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitaminAAggregateArgs>(args: Subset<T, VitaminAAggregateArgs>): PrismaPromise<GetVitaminAAggregateType<T>>

    /**
     * Group by VitaminA.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminAGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitaminAGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitaminAGroupByArgs['orderBy'] }
        : { orderBy?: VitaminAGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitaminAGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitaminAGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VitaminA.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VitaminAClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    vitamin<T extends VitaminArgs = {}>(args?: Subset<T, VitaminArgs>): CheckSelect<T, Prisma__VitaminClient<Vitamin | null >, Prisma__VitaminClient<VitaminGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VitaminA findUnique
   */
  export type VitaminAFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VitaminA
     * 
    **/
    select?: VitaminASelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminAInclude | null
    /**
     * Throw an Error if a VitaminA can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminA to fetch.
     * 
    **/
    where: VitaminAWhereUniqueInput
  }


  /**
   * VitaminA findFirst
   */
  export type VitaminAFindFirstArgs = {
    /**
     * Select specific fields to fetch from the VitaminA
     * 
    **/
    select?: VitaminASelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminAInclude | null
    /**
     * Throw an Error if a VitaminA can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminA to fetch.
     * 
    **/
    where?: VitaminAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminAS to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminAOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitaminAS.
     * 
    **/
    cursor?: VitaminAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminAS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminAS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitaminAS.
     * 
    **/
    distinct?: Enumerable<VitaminAScalarFieldEnum>
  }


  /**
   * VitaminA findMany
   */
  export type VitaminAFindManyArgs = {
    /**
     * Select specific fields to fetch from the VitaminA
     * 
    **/
    select?: VitaminASelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminAInclude | null
    /**
     * Filter, which VitaminAS to fetch.
     * 
    **/
    where?: VitaminAWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminAS to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminAOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VitaminAS.
     * 
    **/
    cursor?: VitaminAWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminAS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminAS.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VitaminAScalarFieldEnum>
  }


  /**
   * VitaminA create
   */
  export type VitaminACreateArgs = {
    /**
     * Select specific fields to fetch from the VitaminA
     * 
    **/
    select?: VitaminASelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminAInclude | null
    /**
     * The data needed to create a VitaminA.
     * 
    **/
    data: XOR<VitaminACreateInput, VitaminAUncheckedCreateInput>
  }


  /**
   * VitaminA createMany
   */
  export type VitaminACreateManyArgs = {
    /**
     * The data used to create many VitaminAS.
     * 
    **/
    data: Enumerable<VitaminACreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VitaminA update
   */
  export type VitaminAUpdateArgs = {
    /**
     * Select specific fields to fetch from the VitaminA
     * 
    **/
    select?: VitaminASelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminAInclude | null
    /**
     * The data needed to update a VitaminA.
     * 
    **/
    data: XOR<VitaminAUpdateInput, VitaminAUncheckedUpdateInput>
    /**
     * Choose, which VitaminA to update.
     * 
    **/
    where: VitaminAWhereUniqueInput
  }


  /**
   * VitaminA updateMany
   */
  export type VitaminAUpdateManyArgs = {
    /**
     * The data used to update VitaminAS.
     * 
    **/
    data: XOR<VitaminAUpdateManyMutationInput, VitaminAUncheckedUpdateManyInput>
    /**
     * Filter which VitaminAS to update
     * 
    **/
    where?: VitaminAWhereInput
  }


  /**
   * VitaminA upsert
   */
  export type VitaminAUpsertArgs = {
    /**
     * Select specific fields to fetch from the VitaminA
     * 
    **/
    select?: VitaminASelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminAInclude | null
    /**
     * The filter to search for the VitaminA to update in case it exists.
     * 
    **/
    where: VitaminAWhereUniqueInput
    /**
     * In case the VitaminA found by the `where` argument doesn't exist, create a new VitaminA with this data.
     * 
    **/
    create: XOR<VitaminACreateInput, VitaminAUncheckedCreateInput>
    /**
     * In case the VitaminA was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VitaminAUpdateInput, VitaminAUncheckedUpdateInput>
  }


  /**
   * VitaminA delete
   */
  export type VitaminADeleteArgs = {
    /**
     * Select specific fields to fetch from the VitaminA
     * 
    **/
    select?: VitaminASelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminAInclude | null
    /**
     * Filter which VitaminA to delete.
     * 
    **/
    where: VitaminAWhereUniqueInput
  }


  /**
   * VitaminA deleteMany
   */
  export type VitaminADeleteManyArgs = {
    /**
     * Filter which VitaminAS to delete
     * 
    **/
    where?: VitaminAWhereInput
  }


  /**
   * VitaminA without action
   */
  export type VitaminAArgs = {
    /**
     * Select specific fields to fetch from the VitaminA
     * 
    **/
    select?: VitaminASelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminAInclude | null
  }



  /**
   * Model VitaminD
   */


  export type AggregateVitaminD = {
    _count: VitaminDCountAggregateOutputType | null
    _avg: VitaminDAvgAggregateOutputType | null
    _sum: VitaminDSumAggregateOutputType | null
    _min: VitaminDMinAggregateOutputType | null
    _max: VitaminDMaxAggregateOutputType | null
  }

  export type VitaminDAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminDSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminDMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminDMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminDCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type VitaminDAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminDSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminDMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminDMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminDCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type VitaminDAggregateArgs = {
    /**
     * Filter which VitaminD to aggregate.
     * 
    **/
    where?: VitaminDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminDS to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminDOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VitaminDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminDS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminDS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VitaminDS
    **/
    _count?: true | VitaminDCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitaminDAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitaminDSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitaminDMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitaminDMaxAggregateInputType
  }

  export type GetVitaminDAggregateType<T extends VitaminDAggregateArgs> = {
        [P in keyof T & keyof AggregateVitaminD]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitaminD[P]>
      : GetScalarType<T[P], AggregateVitaminD[P]>
  }




  export type VitaminDGroupByArgs = {
    where?: VitaminDWhereInput
    orderBy?: Enumerable<VitaminDOrderByWithAggregationInput>
    by: Array<VitaminDScalarFieldEnum>
    having?: VitaminDScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitaminDCountAggregateInputType | true
    _avg?: VitaminDAvgAggregateInputType
    _sum?: VitaminDSumAggregateInputType
    _min?: VitaminDMinAggregateInputType
    _max?: VitaminDMaxAggregateInputType
  }


  export type VitaminDGroupByOutputType = {
    id: number
    measurementId: number
    _count: VitaminDCountAggregateOutputType | null
    _avg: VitaminDAvgAggregateOutputType | null
    _sum: VitaminDSumAggregateOutputType | null
    _min: VitaminDMinAggregateOutputType | null
    _max: VitaminDMaxAggregateOutputType | null
  }

  type GetVitaminDGroupByPayload<T extends VitaminDGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VitaminDGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitaminDGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitaminDGroupByOutputType[P]>
            : GetScalarType<T[P], VitaminDGroupByOutputType[P]>
        }
      >
    >


  export type VitaminDSelect = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
    measurementId?: boolean
  }

  export type VitaminDInclude = {
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
  }

  export type VitaminDGetPayload<
    S extends boolean | null | undefined | VitaminDArgs,
    U = keyof S
      > = S extends true
        ? VitaminD
    : S extends undefined
    ? never
    : S extends VitaminDArgs | VitaminDFindManyArgs
    ?'include' extends U
    ? VitaminD  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['select'][P]> | null :  P extends keyof VitaminD ? VitaminD[P] : never
  } 
    : VitaminD
  : VitaminD


  type VitaminDCountArgs = Merge<
    Omit<VitaminDFindManyArgs, 'select' | 'include'> & {
      select?: VitaminDCountAggregateInputType | true
    }
  >

  export interface VitaminDDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one VitaminD that matches the filter.
     * @param {VitaminDFindUniqueArgs} args - Arguments to find a VitaminD
     * @example
     * // Get one VitaminD
     * const vitaminD = await prisma.vitaminD.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VitaminDFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VitaminDFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VitaminD'> extends True ? CheckSelect<T, Prisma__VitaminDClient<VitaminD>, Prisma__VitaminDClient<VitaminDGetPayload<T>>> : CheckSelect<T, Prisma__VitaminDClient<VitaminD | null >, Prisma__VitaminDClient<VitaminDGetPayload<T> | null >>

    /**
     * Find the first VitaminD that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminDFindFirstArgs} args - Arguments to find a VitaminD
     * @example
     * // Get one VitaminD
     * const vitaminD = await prisma.vitaminD.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VitaminDFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VitaminDFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VitaminD'> extends True ? CheckSelect<T, Prisma__VitaminDClient<VitaminD>, Prisma__VitaminDClient<VitaminDGetPayload<T>>> : CheckSelect<T, Prisma__VitaminDClient<VitaminD | null >, Prisma__VitaminDClient<VitaminDGetPayload<T> | null >>

    /**
     * Find zero or more VitaminDS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminDFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VitaminDS
     * const vitaminDS = await prisma.vitaminD.findMany()
     * 
     * // Get first 10 VitaminDS
     * const vitaminDS = await prisma.vitaminD.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitaminDWithIdOnly = await prisma.vitaminD.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VitaminDFindManyArgs>(
      args?: SelectSubset<T, VitaminDFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VitaminD>>, PrismaPromise<Array<VitaminDGetPayload<T>>>>

    /**
     * Create a VitaminD.
     * @param {VitaminDCreateArgs} args - Arguments to create a VitaminD.
     * @example
     * // Create one VitaminD
     * const VitaminD = await prisma.vitaminD.create({
     *   data: {
     *     // ... data to create a VitaminD
     *   }
     * })
     * 
    **/
    create<T extends VitaminDCreateArgs>(
      args: SelectSubset<T, VitaminDCreateArgs>
    ): CheckSelect<T, Prisma__VitaminDClient<VitaminD>, Prisma__VitaminDClient<VitaminDGetPayload<T>>>

    /**
     * Create many VitaminDS.
     *     @param {VitaminDCreateManyArgs} args - Arguments to create many VitaminDS.
     *     @example
     *     // Create many VitaminDS
     *     const vitaminD = await prisma.vitaminD.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VitaminDCreateManyArgs>(
      args?: SelectSubset<T, VitaminDCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VitaminD.
     * @param {VitaminDDeleteArgs} args - Arguments to delete one VitaminD.
     * @example
     * // Delete one VitaminD
     * const VitaminD = await prisma.vitaminD.delete({
     *   where: {
     *     // ... filter to delete one VitaminD
     *   }
     * })
     * 
    **/
    delete<T extends VitaminDDeleteArgs>(
      args: SelectSubset<T, VitaminDDeleteArgs>
    ): CheckSelect<T, Prisma__VitaminDClient<VitaminD>, Prisma__VitaminDClient<VitaminDGetPayload<T>>>

    /**
     * Update one VitaminD.
     * @param {VitaminDUpdateArgs} args - Arguments to update one VitaminD.
     * @example
     * // Update one VitaminD
     * const vitaminD = await prisma.vitaminD.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VitaminDUpdateArgs>(
      args: SelectSubset<T, VitaminDUpdateArgs>
    ): CheckSelect<T, Prisma__VitaminDClient<VitaminD>, Prisma__VitaminDClient<VitaminDGetPayload<T>>>

    /**
     * Delete zero or more VitaminDS.
     * @param {VitaminDDeleteManyArgs} args - Arguments to filter VitaminDS to delete.
     * @example
     * // Delete a few VitaminDS
     * const { count } = await prisma.vitaminD.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VitaminDDeleteManyArgs>(
      args?: SelectSubset<T, VitaminDDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitaminDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminDUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VitaminDS
     * const vitaminD = await prisma.vitaminD.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VitaminDUpdateManyArgs>(
      args: SelectSubset<T, VitaminDUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VitaminD.
     * @param {VitaminDUpsertArgs} args - Arguments to update or create a VitaminD.
     * @example
     * // Update or create a VitaminD
     * const vitaminD = await prisma.vitaminD.upsert({
     *   create: {
     *     // ... data to create a VitaminD
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VitaminD we want to update
     *   }
     * })
    **/
    upsert<T extends VitaminDUpsertArgs>(
      args: SelectSubset<T, VitaminDUpsertArgs>
    ): CheckSelect<T, Prisma__VitaminDClient<VitaminD>, Prisma__VitaminDClient<VitaminDGetPayload<T>>>

    /**
     * Count the number of VitaminDS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminDCountArgs} args - Arguments to filter VitaminDS to count.
     * @example
     * // Count the number of VitaminDS
     * const count = await prisma.vitaminD.count({
     *   where: {
     *     // ... the filter for the VitaminDS we want to count
     *   }
     * })
    **/
    count<T extends VitaminDCountArgs>(
      args?: Subset<T, VitaminDCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitaminDCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VitaminD.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminDAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitaminDAggregateArgs>(args: Subset<T, VitaminDAggregateArgs>): PrismaPromise<GetVitaminDAggregateType<T>>

    /**
     * Group by VitaminD.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminDGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitaminDGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitaminDGroupByArgs['orderBy'] }
        : { orderBy?: VitaminDGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitaminDGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitaminDGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VitaminD.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VitaminDClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    vitamin<T extends VitaminArgs = {}>(args?: Subset<T, VitaminArgs>): CheckSelect<T, Prisma__VitaminClient<Vitamin | null >, Prisma__VitaminClient<VitaminGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VitaminD findUnique
   */
  export type VitaminDFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VitaminD
     * 
    **/
    select?: VitaminDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminDInclude | null
    /**
     * Throw an Error if a VitaminD can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminD to fetch.
     * 
    **/
    where: VitaminDWhereUniqueInput
  }


  /**
   * VitaminD findFirst
   */
  export type VitaminDFindFirstArgs = {
    /**
     * Select specific fields to fetch from the VitaminD
     * 
    **/
    select?: VitaminDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminDInclude | null
    /**
     * Throw an Error if a VitaminD can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminD to fetch.
     * 
    **/
    where?: VitaminDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminDS to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminDOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitaminDS.
     * 
    **/
    cursor?: VitaminDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminDS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminDS.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitaminDS.
     * 
    **/
    distinct?: Enumerable<VitaminDScalarFieldEnum>
  }


  /**
   * VitaminD findMany
   */
  export type VitaminDFindManyArgs = {
    /**
     * Select specific fields to fetch from the VitaminD
     * 
    **/
    select?: VitaminDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminDInclude | null
    /**
     * Filter, which VitaminDS to fetch.
     * 
    **/
    where?: VitaminDWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminDS to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminDOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VitaminDS.
     * 
    **/
    cursor?: VitaminDWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminDS from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminDS.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VitaminDScalarFieldEnum>
  }


  /**
   * VitaminD create
   */
  export type VitaminDCreateArgs = {
    /**
     * Select specific fields to fetch from the VitaminD
     * 
    **/
    select?: VitaminDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminDInclude | null
    /**
     * The data needed to create a VitaminD.
     * 
    **/
    data: XOR<VitaminDCreateInput, VitaminDUncheckedCreateInput>
  }


  /**
   * VitaminD createMany
   */
  export type VitaminDCreateManyArgs = {
    /**
     * The data used to create many VitaminDS.
     * 
    **/
    data: Enumerable<VitaminDCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VitaminD update
   */
  export type VitaminDUpdateArgs = {
    /**
     * Select specific fields to fetch from the VitaminD
     * 
    **/
    select?: VitaminDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminDInclude | null
    /**
     * The data needed to update a VitaminD.
     * 
    **/
    data: XOR<VitaminDUpdateInput, VitaminDUncheckedUpdateInput>
    /**
     * Choose, which VitaminD to update.
     * 
    **/
    where: VitaminDWhereUniqueInput
  }


  /**
   * VitaminD updateMany
   */
  export type VitaminDUpdateManyArgs = {
    /**
     * The data used to update VitaminDS.
     * 
    **/
    data: XOR<VitaminDUpdateManyMutationInput, VitaminDUncheckedUpdateManyInput>
    /**
     * Filter which VitaminDS to update
     * 
    **/
    where?: VitaminDWhereInput
  }


  /**
   * VitaminD upsert
   */
  export type VitaminDUpsertArgs = {
    /**
     * Select specific fields to fetch from the VitaminD
     * 
    **/
    select?: VitaminDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminDInclude | null
    /**
     * The filter to search for the VitaminD to update in case it exists.
     * 
    **/
    where: VitaminDWhereUniqueInput
    /**
     * In case the VitaminD found by the `where` argument doesn't exist, create a new VitaminD with this data.
     * 
    **/
    create: XOR<VitaminDCreateInput, VitaminDUncheckedCreateInput>
    /**
     * In case the VitaminD was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VitaminDUpdateInput, VitaminDUncheckedUpdateInput>
  }


  /**
   * VitaminD delete
   */
  export type VitaminDDeleteArgs = {
    /**
     * Select specific fields to fetch from the VitaminD
     * 
    **/
    select?: VitaminDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminDInclude | null
    /**
     * Filter which VitaminD to delete.
     * 
    **/
    where: VitaminDWhereUniqueInput
  }


  /**
   * VitaminD deleteMany
   */
  export type VitaminDDeleteManyArgs = {
    /**
     * Filter which VitaminDS to delete
     * 
    **/
    where?: VitaminDWhereInput
  }


  /**
   * VitaminD without action
   */
  export type VitaminDArgs = {
    /**
     * Select specific fields to fetch from the VitaminD
     * 
    **/
    select?: VitaminDSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminDInclude | null
  }



  /**
   * Model VitaminE
   */


  export type AggregateVitaminE = {
    _count: VitaminECountAggregateOutputType | null
    _avg: VitaminEAvgAggregateOutputType | null
    _sum: VitaminESumAggregateOutputType | null
    _min: VitaminEMinAggregateOutputType | null
    _max: VitaminEMaxAggregateOutputType | null
  }

  export type VitaminEAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminESumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminEMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminEMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminECountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type VitaminEAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminESumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminEMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminEMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminECountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type VitaminEAggregateArgs = {
    /**
     * Filter which VitaminE to aggregate.
     * 
    **/
    where?: VitaminEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminES to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminEOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VitaminEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminES from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminES.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VitaminES
    **/
    _count?: true | VitaminECountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitaminEAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitaminESumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitaminEMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitaminEMaxAggregateInputType
  }

  export type GetVitaminEAggregateType<T extends VitaminEAggregateArgs> = {
        [P in keyof T & keyof AggregateVitaminE]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitaminE[P]>
      : GetScalarType<T[P], AggregateVitaminE[P]>
  }




  export type VitaminEGroupByArgs = {
    where?: VitaminEWhereInput
    orderBy?: Enumerable<VitaminEOrderByWithAggregationInput>
    by: Array<VitaminEScalarFieldEnum>
    having?: VitaminEScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitaminECountAggregateInputType | true
    _avg?: VitaminEAvgAggregateInputType
    _sum?: VitaminESumAggregateInputType
    _min?: VitaminEMinAggregateInputType
    _max?: VitaminEMaxAggregateInputType
  }


  export type VitaminEGroupByOutputType = {
    id: number
    measurementId: number
    _count: VitaminECountAggregateOutputType | null
    _avg: VitaminEAvgAggregateOutputType | null
    _sum: VitaminESumAggregateOutputType | null
    _min: VitaminEMinAggregateOutputType | null
    _max: VitaminEMaxAggregateOutputType | null
  }

  type GetVitaminEGroupByPayload<T extends VitaminEGroupByArgs> = PrismaPromise<
    Array<
      PickArray<VitaminEGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitaminEGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitaminEGroupByOutputType[P]>
            : GetScalarType<T[P], VitaminEGroupByOutputType[P]>
        }
      >
    >


  export type VitaminESelect = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
    measurementId?: boolean
  }

  export type VitaminEInclude = {
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
  }

  export type VitaminEGetPayload<
    S extends boolean | null | undefined | VitaminEArgs,
    U = keyof S
      > = S extends true
        ? VitaminE
    : S extends undefined
    ? never
    : S extends VitaminEArgs | VitaminEFindManyArgs
    ?'include' extends U
    ? VitaminE  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['select'][P]> | null :  P extends keyof VitaminE ? VitaminE[P] : never
  } 
    : VitaminE
  : VitaminE


  type VitaminECountArgs = Merge<
    Omit<VitaminEFindManyArgs, 'select' | 'include'> & {
      select?: VitaminECountAggregateInputType | true
    }
  >

  export interface VitaminEDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one VitaminE that matches the filter.
     * @param {VitaminEFindUniqueArgs} args - Arguments to find a VitaminE
     * @example
     * // Get one VitaminE
     * const vitaminE = await prisma.vitaminE.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VitaminEFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VitaminEFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VitaminE'> extends True ? CheckSelect<T, Prisma__VitaminEClient<VitaminE>, Prisma__VitaminEClient<VitaminEGetPayload<T>>> : CheckSelect<T, Prisma__VitaminEClient<VitaminE | null >, Prisma__VitaminEClient<VitaminEGetPayload<T> | null >>

    /**
     * Find the first VitaminE that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminEFindFirstArgs} args - Arguments to find a VitaminE
     * @example
     * // Get one VitaminE
     * const vitaminE = await prisma.vitaminE.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VitaminEFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VitaminEFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VitaminE'> extends True ? CheckSelect<T, Prisma__VitaminEClient<VitaminE>, Prisma__VitaminEClient<VitaminEGetPayload<T>>> : CheckSelect<T, Prisma__VitaminEClient<VitaminE | null >, Prisma__VitaminEClient<VitaminEGetPayload<T> | null >>

    /**
     * Find zero or more VitaminES that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminEFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VitaminES
     * const vitaminES = await prisma.vitaminE.findMany()
     * 
     * // Get first 10 VitaminES
     * const vitaminES = await prisma.vitaminE.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitaminEWithIdOnly = await prisma.vitaminE.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VitaminEFindManyArgs>(
      args?: SelectSubset<T, VitaminEFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VitaminE>>, PrismaPromise<Array<VitaminEGetPayload<T>>>>

    /**
     * Create a VitaminE.
     * @param {VitaminECreateArgs} args - Arguments to create a VitaminE.
     * @example
     * // Create one VitaminE
     * const VitaminE = await prisma.vitaminE.create({
     *   data: {
     *     // ... data to create a VitaminE
     *   }
     * })
     * 
    **/
    create<T extends VitaminECreateArgs>(
      args: SelectSubset<T, VitaminECreateArgs>
    ): CheckSelect<T, Prisma__VitaminEClient<VitaminE>, Prisma__VitaminEClient<VitaminEGetPayload<T>>>

    /**
     * Create many VitaminES.
     *     @param {VitaminECreateManyArgs} args - Arguments to create many VitaminES.
     *     @example
     *     // Create many VitaminES
     *     const vitaminE = await prisma.vitaminE.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VitaminECreateManyArgs>(
      args?: SelectSubset<T, VitaminECreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VitaminE.
     * @param {VitaminEDeleteArgs} args - Arguments to delete one VitaminE.
     * @example
     * // Delete one VitaminE
     * const VitaminE = await prisma.vitaminE.delete({
     *   where: {
     *     // ... filter to delete one VitaminE
     *   }
     * })
     * 
    **/
    delete<T extends VitaminEDeleteArgs>(
      args: SelectSubset<T, VitaminEDeleteArgs>
    ): CheckSelect<T, Prisma__VitaminEClient<VitaminE>, Prisma__VitaminEClient<VitaminEGetPayload<T>>>

    /**
     * Update one VitaminE.
     * @param {VitaminEUpdateArgs} args - Arguments to update one VitaminE.
     * @example
     * // Update one VitaminE
     * const vitaminE = await prisma.vitaminE.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VitaminEUpdateArgs>(
      args: SelectSubset<T, VitaminEUpdateArgs>
    ): CheckSelect<T, Prisma__VitaminEClient<VitaminE>, Prisma__VitaminEClient<VitaminEGetPayload<T>>>

    /**
     * Delete zero or more VitaminES.
     * @param {VitaminEDeleteManyArgs} args - Arguments to filter VitaminES to delete.
     * @example
     * // Delete a few VitaminES
     * const { count } = await prisma.vitaminE.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VitaminEDeleteManyArgs>(
      args?: SelectSubset<T, VitaminEDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitaminES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminEUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VitaminES
     * const vitaminE = await prisma.vitaminE.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VitaminEUpdateManyArgs>(
      args: SelectSubset<T, VitaminEUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VitaminE.
     * @param {VitaminEUpsertArgs} args - Arguments to update or create a VitaminE.
     * @example
     * // Update or create a VitaminE
     * const vitaminE = await prisma.vitaminE.upsert({
     *   create: {
     *     // ... data to create a VitaminE
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VitaminE we want to update
     *   }
     * })
    **/
    upsert<T extends VitaminEUpsertArgs>(
      args: SelectSubset<T, VitaminEUpsertArgs>
    ): CheckSelect<T, Prisma__VitaminEClient<VitaminE>, Prisma__VitaminEClient<VitaminEGetPayload<T>>>

    /**
     * Count the number of VitaminES.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminECountArgs} args - Arguments to filter VitaminES to count.
     * @example
     * // Count the number of VitaminES
     * const count = await prisma.vitaminE.count({
     *   where: {
     *     // ... the filter for the VitaminES we want to count
     *   }
     * })
    **/
    count<T extends VitaminECountArgs>(
      args?: Subset<T, VitaminECountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitaminECountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VitaminE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminEAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitaminEAggregateArgs>(args: Subset<T, VitaminEAggregateArgs>): PrismaPromise<GetVitaminEAggregateType<T>>

    /**
     * Group by VitaminE.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminEGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitaminEGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitaminEGroupByArgs['orderBy'] }
        : { orderBy?: VitaminEGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitaminEGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitaminEGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VitaminE.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VitaminEClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    vitamin<T extends VitaminArgs = {}>(args?: Subset<T, VitaminArgs>): CheckSelect<T, Prisma__VitaminClient<Vitamin | null >, Prisma__VitaminClient<VitaminGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VitaminE findUnique
   */
  export type VitaminEFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VitaminE
     * 
    **/
    select?: VitaminESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminEInclude | null
    /**
     * Throw an Error if a VitaminE can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminE to fetch.
     * 
    **/
    where: VitaminEWhereUniqueInput
  }


  /**
   * VitaminE findFirst
   */
  export type VitaminEFindFirstArgs = {
    /**
     * Select specific fields to fetch from the VitaminE
     * 
    **/
    select?: VitaminESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminEInclude | null
    /**
     * Throw an Error if a VitaminE can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminE to fetch.
     * 
    **/
    where?: VitaminEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminES to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminEOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitaminES.
     * 
    **/
    cursor?: VitaminEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminES from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminES.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitaminES.
     * 
    **/
    distinct?: Enumerable<VitaminEScalarFieldEnum>
  }


  /**
   * VitaminE findMany
   */
  export type VitaminEFindManyArgs = {
    /**
     * Select specific fields to fetch from the VitaminE
     * 
    **/
    select?: VitaminESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminEInclude | null
    /**
     * Filter, which VitaminES to fetch.
     * 
    **/
    where?: VitaminEWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminES to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminEOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VitaminES.
     * 
    **/
    cursor?: VitaminEWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminES from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminES.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VitaminEScalarFieldEnum>
  }


  /**
   * VitaminE create
   */
  export type VitaminECreateArgs = {
    /**
     * Select specific fields to fetch from the VitaminE
     * 
    **/
    select?: VitaminESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminEInclude | null
    /**
     * The data needed to create a VitaminE.
     * 
    **/
    data: XOR<VitaminECreateInput, VitaminEUncheckedCreateInput>
  }


  /**
   * VitaminE createMany
   */
  export type VitaminECreateManyArgs = {
    /**
     * The data used to create many VitaminES.
     * 
    **/
    data: Enumerable<VitaminECreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VitaminE update
   */
  export type VitaminEUpdateArgs = {
    /**
     * Select specific fields to fetch from the VitaminE
     * 
    **/
    select?: VitaminESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminEInclude | null
    /**
     * The data needed to update a VitaminE.
     * 
    **/
    data: XOR<VitaminEUpdateInput, VitaminEUncheckedUpdateInput>
    /**
     * Choose, which VitaminE to update.
     * 
    **/
    where: VitaminEWhereUniqueInput
  }


  /**
   * VitaminE updateMany
   */
  export type VitaminEUpdateManyArgs = {
    /**
     * The data used to update VitaminES.
     * 
    **/
    data: XOR<VitaminEUpdateManyMutationInput, VitaminEUncheckedUpdateManyInput>
    /**
     * Filter which VitaminES to update
     * 
    **/
    where?: VitaminEWhereInput
  }


  /**
   * VitaminE upsert
   */
  export type VitaminEUpsertArgs = {
    /**
     * Select specific fields to fetch from the VitaminE
     * 
    **/
    select?: VitaminESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminEInclude | null
    /**
     * The filter to search for the VitaminE to update in case it exists.
     * 
    **/
    where: VitaminEWhereUniqueInput
    /**
     * In case the VitaminE found by the `where` argument doesn't exist, create a new VitaminE with this data.
     * 
    **/
    create: XOR<VitaminECreateInput, VitaminEUncheckedCreateInput>
    /**
     * In case the VitaminE was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VitaminEUpdateInput, VitaminEUncheckedUpdateInput>
  }


  /**
   * VitaminE delete
   */
  export type VitaminEDeleteArgs = {
    /**
     * Select specific fields to fetch from the VitaminE
     * 
    **/
    select?: VitaminESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminEInclude | null
    /**
     * Filter which VitaminE to delete.
     * 
    **/
    where: VitaminEWhereUniqueInput
  }


  /**
   * VitaminE deleteMany
   */
  export type VitaminEDeleteManyArgs = {
    /**
     * Filter which VitaminES to delete
     * 
    **/
    where?: VitaminEWhereInput
  }


  /**
   * VitaminE without action
   */
  export type VitaminEArgs = {
    /**
     * Select specific fields to fetch from the VitaminE
     * 
    **/
    select?: VitaminESelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminEInclude | null
  }



  /**
   * Model VitaminB1
   */


  export type AggregateVitaminB1 = {
    _count: VitaminB1CountAggregateOutputType | null
    _avg: VitaminB1AvgAggregateOutputType | null
    _sum: VitaminB1SumAggregateOutputType | null
    _min: VitaminB1MinAggregateOutputType | null
    _max: VitaminB1MaxAggregateOutputType | null
  }

  export type VitaminB1AvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB1SumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB1MinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB1MaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB1CountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type VitaminB1AvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB1SumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB1MinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB1MaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB1CountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type VitaminB1AggregateArgs = {
    /**
     * Filter which VitaminB1 to aggregate.
     * 
    **/
    where?: VitaminB1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminB1s to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminB1OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VitaminB1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminB1s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminB1s.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VitaminB1s
    **/
    _count?: true | VitaminB1CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitaminB1AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitaminB1SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitaminB1MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitaminB1MaxAggregateInputType
  }

  export type GetVitaminB1AggregateType<T extends VitaminB1AggregateArgs> = {
        [P in keyof T & keyof AggregateVitaminB1]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitaminB1[P]>
      : GetScalarType<T[P], AggregateVitaminB1[P]>
  }




  export type VitaminB1GroupByArgs = {
    where?: VitaminB1WhereInput
    orderBy?: Enumerable<VitaminB1OrderByWithAggregationInput>
    by: Array<VitaminB1ScalarFieldEnum>
    having?: VitaminB1ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitaminB1CountAggregateInputType | true
    _avg?: VitaminB1AvgAggregateInputType
    _sum?: VitaminB1SumAggregateInputType
    _min?: VitaminB1MinAggregateInputType
    _max?: VitaminB1MaxAggregateInputType
  }


  export type VitaminB1GroupByOutputType = {
    id: number
    measurementId: number
    _count: VitaminB1CountAggregateOutputType | null
    _avg: VitaminB1AvgAggregateOutputType | null
    _sum: VitaminB1SumAggregateOutputType | null
    _min: VitaminB1MinAggregateOutputType | null
    _max: VitaminB1MaxAggregateOutputType | null
  }

  type GetVitaminB1GroupByPayload<T extends VitaminB1GroupByArgs> = PrismaPromise<
    Array<
      PickArray<VitaminB1GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitaminB1GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitaminB1GroupByOutputType[P]>
            : GetScalarType<T[P], VitaminB1GroupByOutputType[P]>
        }
      >
    >


  export type VitaminB1Select = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
    measurementId?: boolean
  }

  export type VitaminB1Include = {
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
  }

  export type VitaminB1GetPayload<
    S extends boolean | null | undefined | VitaminB1Args,
    U = keyof S
      > = S extends true
        ? VitaminB1
    : S extends undefined
    ? never
    : S extends VitaminB1Args | VitaminB1FindManyArgs
    ?'include' extends U
    ? VitaminB1  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['select'][P]> | null :  P extends keyof VitaminB1 ? VitaminB1[P] : never
  } 
    : VitaminB1
  : VitaminB1


  type VitaminB1CountArgs = Merge<
    Omit<VitaminB1FindManyArgs, 'select' | 'include'> & {
      select?: VitaminB1CountAggregateInputType | true
    }
  >

  export interface VitaminB1Delegate<GlobalRejectSettings> {
    /**
     * Find zero or one VitaminB1 that matches the filter.
     * @param {VitaminB1FindUniqueArgs} args - Arguments to find a VitaminB1
     * @example
     * // Get one VitaminB1
     * const vitaminB1 = await prisma.vitaminB1.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VitaminB1FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VitaminB1FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VitaminB1'> extends True ? CheckSelect<T, Prisma__VitaminB1Client<VitaminB1>, Prisma__VitaminB1Client<VitaminB1GetPayload<T>>> : CheckSelect<T, Prisma__VitaminB1Client<VitaminB1 | null >, Prisma__VitaminB1Client<VitaminB1GetPayload<T> | null >>

    /**
     * Find the first VitaminB1 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB1FindFirstArgs} args - Arguments to find a VitaminB1
     * @example
     * // Get one VitaminB1
     * const vitaminB1 = await prisma.vitaminB1.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VitaminB1FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VitaminB1FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VitaminB1'> extends True ? CheckSelect<T, Prisma__VitaminB1Client<VitaminB1>, Prisma__VitaminB1Client<VitaminB1GetPayload<T>>> : CheckSelect<T, Prisma__VitaminB1Client<VitaminB1 | null >, Prisma__VitaminB1Client<VitaminB1GetPayload<T> | null >>

    /**
     * Find zero or more VitaminB1s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB1FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VitaminB1s
     * const vitaminB1s = await prisma.vitaminB1.findMany()
     * 
     * // Get first 10 VitaminB1s
     * const vitaminB1s = await prisma.vitaminB1.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitaminB1WithIdOnly = await prisma.vitaminB1.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VitaminB1FindManyArgs>(
      args?: SelectSubset<T, VitaminB1FindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VitaminB1>>, PrismaPromise<Array<VitaminB1GetPayload<T>>>>

    /**
     * Create a VitaminB1.
     * @param {VitaminB1CreateArgs} args - Arguments to create a VitaminB1.
     * @example
     * // Create one VitaminB1
     * const VitaminB1 = await prisma.vitaminB1.create({
     *   data: {
     *     // ... data to create a VitaminB1
     *   }
     * })
     * 
    **/
    create<T extends VitaminB1CreateArgs>(
      args: SelectSubset<T, VitaminB1CreateArgs>
    ): CheckSelect<T, Prisma__VitaminB1Client<VitaminB1>, Prisma__VitaminB1Client<VitaminB1GetPayload<T>>>

    /**
     * Create many VitaminB1s.
     *     @param {VitaminB1CreateManyArgs} args - Arguments to create many VitaminB1s.
     *     @example
     *     // Create many VitaminB1s
     *     const vitaminB1 = await prisma.vitaminB1.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VitaminB1CreateManyArgs>(
      args?: SelectSubset<T, VitaminB1CreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VitaminB1.
     * @param {VitaminB1DeleteArgs} args - Arguments to delete one VitaminB1.
     * @example
     * // Delete one VitaminB1
     * const VitaminB1 = await prisma.vitaminB1.delete({
     *   where: {
     *     // ... filter to delete one VitaminB1
     *   }
     * })
     * 
    **/
    delete<T extends VitaminB1DeleteArgs>(
      args: SelectSubset<T, VitaminB1DeleteArgs>
    ): CheckSelect<T, Prisma__VitaminB1Client<VitaminB1>, Prisma__VitaminB1Client<VitaminB1GetPayload<T>>>

    /**
     * Update one VitaminB1.
     * @param {VitaminB1UpdateArgs} args - Arguments to update one VitaminB1.
     * @example
     * // Update one VitaminB1
     * const vitaminB1 = await prisma.vitaminB1.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VitaminB1UpdateArgs>(
      args: SelectSubset<T, VitaminB1UpdateArgs>
    ): CheckSelect<T, Prisma__VitaminB1Client<VitaminB1>, Prisma__VitaminB1Client<VitaminB1GetPayload<T>>>

    /**
     * Delete zero or more VitaminB1s.
     * @param {VitaminB1DeleteManyArgs} args - Arguments to filter VitaminB1s to delete.
     * @example
     * // Delete a few VitaminB1s
     * const { count } = await prisma.vitaminB1.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VitaminB1DeleteManyArgs>(
      args?: SelectSubset<T, VitaminB1DeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitaminB1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB1UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VitaminB1s
     * const vitaminB1 = await prisma.vitaminB1.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VitaminB1UpdateManyArgs>(
      args: SelectSubset<T, VitaminB1UpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VitaminB1.
     * @param {VitaminB1UpsertArgs} args - Arguments to update or create a VitaminB1.
     * @example
     * // Update or create a VitaminB1
     * const vitaminB1 = await prisma.vitaminB1.upsert({
     *   create: {
     *     // ... data to create a VitaminB1
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VitaminB1 we want to update
     *   }
     * })
    **/
    upsert<T extends VitaminB1UpsertArgs>(
      args: SelectSubset<T, VitaminB1UpsertArgs>
    ): CheckSelect<T, Prisma__VitaminB1Client<VitaminB1>, Prisma__VitaminB1Client<VitaminB1GetPayload<T>>>

    /**
     * Count the number of VitaminB1s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB1CountArgs} args - Arguments to filter VitaminB1s to count.
     * @example
     * // Count the number of VitaminB1s
     * const count = await prisma.vitaminB1.count({
     *   where: {
     *     // ... the filter for the VitaminB1s we want to count
     *   }
     * })
    **/
    count<T extends VitaminB1CountArgs>(
      args?: Subset<T, VitaminB1CountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitaminB1CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VitaminB1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB1AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitaminB1AggregateArgs>(args: Subset<T, VitaminB1AggregateArgs>): PrismaPromise<GetVitaminB1AggregateType<T>>

    /**
     * Group by VitaminB1.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB1GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitaminB1GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitaminB1GroupByArgs['orderBy'] }
        : { orderBy?: VitaminB1GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitaminB1GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitaminB1GroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VitaminB1.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VitaminB1Client<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    vitamin<T extends VitaminArgs = {}>(args?: Subset<T, VitaminArgs>): CheckSelect<T, Prisma__VitaminClient<Vitamin | null >, Prisma__VitaminClient<VitaminGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VitaminB1 findUnique
   */
  export type VitaminB1FindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VitaminB1
     * 
    **/
    select?: VitaminB1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB1Include | null
    /**
     * Throw an Error if a VitaminB1 can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminB1 to fetch.
     * 
    **/
    where: VitaminB1WhereUniqueInput
  }


  /**
   * VitaminB1 findFirst
   */
  export type VitaminB1FindFirstArgs = {
    /**
     * Select specific fields to fetch from the VitaminB1
     * 
    **/
    select?: VitaminB1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB1Include | null
    /**
     * Throw an Error if a VitaminB1 can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminB1 to fetch.
     * 
    **/
    where?: VitaminB1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminB1s to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminB1OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitaminB1s.
     * 
    **/
    cursor?: VitaminB1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminB1s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminB1s.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitaminB1s.
     * 
    **/
    distinct?: Enumerable<VitaminB1ScalarFieldEnum>
  }


  /**
   * VitaminB1 findMany
   */
  export type VitaminB1FindManyArgs = {
    /**
     * Select specific fields to fetch from the VitaminB1
     * 
    **/
    select?: VitaminB1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB1Include | null
    /**
     * Filter, which VitaminB1s to fetch.
     * 
    **/
    where?: VitaminB1WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminB1s to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminB1OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VitaminB1s.
     * 
    **/
    cursor?: VitaminB1WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminB1s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminB1s.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VitaminB1ScalarFieldEnum>
  }


  /**
   * VitaminB1 create
   */
  export type VitaminB1CreateArgs = {
    /**
     * Select specific fields to fetch from the VitaminB1
     * 
    **/
    select?: VitaminB1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB1Include | null
    /**
     * The data needed to create a VitaminB1.
     * 
    **/
    data: XOR<VitaminB1CreateInput, VitaminB1UncheckedCreateInput>
  }


  /**
   * VitaminB1 createMany
   */
  export type VitaminB1CreateManyArgs = {
    /**
     * The data used to create many VitaminB1s.
     * 
    **/
    data: Enumerable<VitaminB1CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VitaminB1 update
   */
  export type VitaminB1UpdateArgs = {
    /**
     * Select specific fields to fetch from the VitaminB1
     * 
    **/
    select?: VitaminB1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB1Include | null
    /**
     * The data needed to update a VitaminB1.
     * 
    **/
    data: XOR<VitaminB1UpdateInput, VitaminB1UncheckedUpdateInput>
    /**
     * Choose, which VitaminB1 to update.
     * 
    **/
    where: VitaminB1WhereUniqueInput
  }


  /**
   * VitaminB1 updateMany
   */
  export type VitaminB1UpdateManyArgs = {
    /**
     * The data used to update VitaminB1s.
     * 
    **/
    data: XOR<VitaminB1UpdateManyMutationInput, VitaminB1UncheckedUpdateManyInput>
    /**
     * Filter which VitaminB1s to update
     * 
    **/
    where?: VitaminB1WhereInput
  }


  /**
   * VitaminB1 upsert
   */
  export type VitaminB1UpsertArgs = {
    /**
     * Select specific fields to fetch from the VitaminB1
     * 
    **/
    select?: VitaminB1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB1Include | null
    /**
     * The filter to search for the VitaminB1 to update in case it exists.
     * 
    **/
    where: VitaminB1WhereUniqueInput
    /**
     * In case the VitaminB1 found by the `where` argument doesn't exist, create a new VitaminB1 with this data.
     * 
    **/
    create: XOR<VitaminB1CreateInput, VitaminB1UncheckedCreateInput>
    /**
     * In case the VitaminB1 was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VitaminB1UpdateInput, VitaminB1UncheckedUpdateInput>
  }


  /**
   * VitaminB1 delete
   */
  export type VitaminB1DeleteArgs = {
    /**
     * Select specific fields to fetch from the VitaminB1
     * 
    **/
    select?: VitaminB1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB1Include | null
    /**
     * Filter which VitaminB1 to delete.
     * 
    **/
    where: VitaminB1WhereUniqueInput
  }


  /**
   * VitaminB1 deleteMany
   */
  export type VitaminB1DeleteManyArgs = {
    /**
     * Filter which VitaminB1s to delete
     * 
    **/
    where?: VitaminB1WhereInput
  }


  /**
   * VitaminB1 without action
   */
  export type VitaminB1Args = {
    /**
     * Select specific fields to fetch from the VitaminB1
     * 
    **/
    select?: VitaminB1Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB1Include | null
  }



  /**
   * Model VitaminB2
   */


  export type AggregateVitaminB2 = {
    _count: VitaminB2CountAggregateOutputType | null
    _avg: VitaminB2AvgAggregateOutputType | null
    _sum: VitaminB2SumAggregateOutputType | null
    _min: VitaminB2MinAggregateOutputType | null
    _max: VitaminB2MaxAggregateOutputType | null
  }

  export type VitaminB2AvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB2SumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB2MinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB2MaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB2CountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type VitaminB2AvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB2SumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB2MinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB2MaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB2CountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type VitaminB2AggregateArgs = {
    /**
     * Filter which VitaminB2 to aggregate.
     * 
    **/
    where?: VitaminB2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminB2s to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminB2OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VitaminB2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminB2s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminB2s.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VitaminB2s
    **/
    _count?: true | VitaminB2CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitaminB2AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitaminB2SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitaminB2MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitaminB2MaxAggregateInputType
  }

  export type GetVitaminB2AggregateType<T extends VitaminB2AggregateArgs> = {
        [P in keyof T & keyof AggregateVitaminB2]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitaminB2[P]>
      : GetScalarType<T[P], AggregateVitaminB2[P]>
  }




  export type VitaminB2GroupByArgs = {
    where?: VitaminB2WhereInput
    orderBy?: Enumerable<VitaminB2OrderByWithAggregationInput>
    by: Array<VitaminB2ScalarFieldEnum>
    having?: VitaminB2ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitaminB2CountAggregateInputType | true
    _avg?: VitaminB2AvgAggregateInputType
    _sum?: VitaminB2SumAggregateInputType
    _min?: VitaminB2MinAggregateInputType
    _max?: VitaminB2MaxAggregateInputType
  }


  export type VitaminB2GroupByOutputType = {
    id: number
    measurementId: number
    _count: VitaminB2CountAggregateOutputType | null
    _avg: VitaminB2AvgAggregateOutputType | null
    _sum: VitaminB2SumAggregateOutputType | null
    _min: VitaminB2MinAggregateOutputType | null
    _max: VitaminB2MaxAggregateOutputType | null
  }

  type GetVitaminB2GroupByPayload<T extends VitaminB2GroupByArgs> = PrismaPromise<
    Array<
      PickArray<VitaminB2GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitaminB2GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitaminB2GroupByOutputType[P]>
            : GetScalarType<T[P], VitaminB2GroupByOutputType[P]>
        }
      >
    >


  export type VitaminB2Select = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
    measurementId?: boolean
  }

  export type VitaminB2Include = {
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
  }

  export type VitaminB2GetPayload<
    S extends boolean | null | undefined | VitaminB2Args,
    U = keyof S
      > = S extends true
        ? VitaminB2
    : S extends undefined
    ? never
    : S extends VitaminB2Args | VitaminB2FindManyArgs
    ?'include' extends U
    ? VitaminB2  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['select'][P]> | null :  P extends keyof VitaminB2 ? VitaminB2[P] : never
  } 
    : VitaminB2
  : VitaminB2


  type VitaminB2CountArgs = Merge<
    Omit<VitaminB2FindManyArgs, 'select' | 'include'> & {
      select?: VitaminB2CountAggregateInputType | true
    }
  >

  export interface VitaminB2Delegate<GlobalRejectSettings> {
    /**
     * Find zero or one VitaminB2 that matches the filter.
     * @param {VitaminB2FindUniqueArgs} args - Arguments to find a VitaminB2
     * @example
     * // Get one VitaminB2
     * const vitaminB2 = await prisma.vitaminB2.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VitaminB2FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VitaminB2FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VitaminB2'> extends True ? CheckSelect<T, Prisma__VitaminB2Client<VitaminB2>, Prisma__VitaminB2Client<VitaminB2GetPayload<T>>> : CheckSelect<T, Prisma__VitaminB2Client<VitaminB2 | null >, Prisma__VitaminB2Client<VitaminB2GetPayload<T> | null >>

    /**
     * Find the first VitaminB2 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB2FindFirstArgs} args - Arguments to find a VitaminB2
     * @example
     * // Get one VitaminB2
     * const vitaminB2 = await prisma.vitaminB2.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VitaminB2FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VitaminB2FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VitaminB2'> extends True ? CheckSelect<T, Prisma__VitaminB2Client<VitaminB2>, Prisma__VitaminB2Client<VitaminB2GetPayload<T>>> : CheckSelect<T, Prisma__VitaminB2Client<VitaminB2 | null >, Prisma__VitaminB2Client<VitaminB2GetPayload<T> | null >>

    /**
     * Find zero or more VitaminB2s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB2FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VitaminB2s
     * const vitaminB2s = await prisma.vitaminB2.findMany()
     * 
     * // Get first 10 VitaminB2s
     * const vitaminB2s = await prisma.vitaminB2.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitaminB2WithIdOnly = await prisma.vitaminB2.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VitaminB2FindManyArgs>(
      args?: SelectSubset<T, VitaminB2FindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VitaminB2>>, PrismaPromise<Array<VitaminB2GetPayload<T>>>>

    /**
     * Create a VitaminB2.
     * @param {VitaminB2CreateArgs} args - Arguments to create a VitaminB2.
     * @example
     * // Create one VitaminB2
     * const VitaminB2 = await prisma.vitaminB2.create({
     *   data: {
     *     // ... data to create a VitaminB2
     *   }
     * })
     * 
    **/
    create<T extends VitaminB2CreateArgs>(
      args: SelectSubset<T, VitaminB2CreateArgs>
    ): CheckSelect<T, Prisma__VitaminB2Client<VitaminB2>, Prisma__VitaminB2Client<VitaminB2GetPayload<T>>>

    /**
     * Create many VitaminB2s.
     *     @param {VitaminB2CreateManyArgs} args - Arguments to create many VitaminB2s.
     *     @example
     *     // Create many VitaminB2s
     *     const vitaminB2 = await prisma.vitaminB2.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VitaminB2CreateManyArgs>(
      args?: SelectSubset<T, VitaminB2CreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VitaminB2.
     * @param {VitaminB2DeleteArgs} args - Arguments to delete one VitaminB2.
     * @example
     * // Delete one VitaminB2
     * const VitaminB2 = await prisma.vitaminB2.delete({
     *   where: {
     *     // ... filter to delete one VitaminB2
     *   }
     * })
     * 
    **/
    delete<T extends VitaminB2DeleteArgs>(
      args: SelectSubset<T, VitaminB2DeleteArgs>
    ): CheckSelect<T, Prisma__VitaminB2Client<VitaminB2>, Prisma__VitaminB2Client<VitaminB2GetPayload<T>>>

    /**
     * Update one VitaminB2.
     * @param {VitaminB2UpdateArgs} args - Arguments to update one VitaminB2.
     * @example
     * // Update one VitaminB2
     * const vitaminB2 = await prisma.vitaminB2.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VitaminB2UpdateArgs>(
      args: SelectSubset<T, VitaminB2UpdateArgs>
    ): CheckSelect<T, Prisma__VitaminB2Client<VitaminB2>, Prisma__VitaminB2Client<VitaminB2GetPayload<T>>>

    /**
     * Delete zero or more VitaminB2s.
     * @param {VitaminB2DeleteManyArgs} args - Arguments to filter VitaminB2s to delete.
     * @example
     * // Delete a few VitaminB2s
     * const { count } = await prisma.vitaminB2.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VitaminB2DeleteManyArgs>(
      args?: SelectSubset<T, VitaminB2DeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitaminB2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB2UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VitaminB2s
     * const vitaminB2 = await prisma.vitaminB2.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VitaminB2UpdateManyArgs>(
      args: SelectSubset<T, VitaminB2UpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VitaminB2.
     * @param {VitaminB2UpsertArgs} args - Arguments to update or create a VitaminB2.
     * @example
     * // Update or create a VitaminB2
     * const vitaminB2 = await prisma.vitaminB2.upsert({
     *   create: {
     *     // ... data to create a VitaminB2
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VitaminB2 we want to update
     *   }
     * })
    **/
    upsert<T extends VitaminB2UpsertArgs>(
      args: SelectSubset<T, VitaminB2UpsertArgs>
    ): CheckSelect<T, Prisma__VitaminB2Client<VitaminB2>, Prisma__VitaminB2Client<VitaminB2GetPayload<T>>>

    /**
     * Count the number of VitaminB2s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB2CountArgs} args - Arguments to filter VitaminB2s to count.
     * @example
     * // Count the number of VitaminB2s
     * const count = await prisma.vitaminB2.count({
     *   where: {
     *     // ... the filter for the VitaminB2s we want to count
     *   }
     * })
    **/
    count<T extends VitaminB2CountArgs>(
      args?: Subset<T, VitaminB2CountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitaminB2CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VitaminB2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB2AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitaminB2AggregateArgs>(args: Subset<T, VitaminB2AggregateArgs>): PrismaPromise<GetVitaminB2AggregateType<T>>

    /**
     * Group by VitaminB2.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB2GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitaminB2GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitaminB2GroupByArgs['orderBy'] }
        : { orderBy?: VitaminB2GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitaminB2GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitaminB2GroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VitaminB2.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VitaminB2Client<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    vitamin<T extends VitaminArgs = {}>(args?: Subset<T, VitaminArgs>): CheckSelect<T, Prisma__VitaminClient<Vitamin | null >, Prisma__VitaminClient<VitaminGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VitaminB2 findUnique
   */
  export type VitaminB2FindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VitaminB2
     * 
    **/
    select?: VitaminB2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB2Include | null
    /**
     * Throw an Error if a VitaminB2 can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminB2 to fetch.
     * 
    **/
    where: VitaminB2WhereUniqueInput
  }


  /**
   * VitaminB2 findFirst
   */
  export type VitaminB2FindFirstArgs = {
    /**
     * Select specific fields to fetch from the VitaminB2
     * 
    **/
    select?: VitaminB2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB2Include | null
    /**
     * Throw an Error if a VitaminB2 can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminB2 to fetch.
     * 
    **/
    where?: VitaminB2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminB2s to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminB2OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitaminB2s.
     * 
    **/
    cursor?: VitaminB2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminB2s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminB2s.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitaminB2s.
     * 
    **/
    distinct?: Enumerable<VitaminB2ScalarFieldEnum>
  }


  /**
   * VitaminB2 findMany
   */
  export type VitaminB2FindManyArgs = {
    /**
     * Select specific fields to fetch from the VitaminB2
     * 
    **/
    select?: VitaminB2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB2Include | null
    /**
     * Filter, which VitaminB2s to fetch.
     * 
    **/
    where?: VitaminB2WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminB2s to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminB2OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VitaminB2s.
     * 
    **/
    cursor?: VitaminB2WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminB2s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminB2s.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VitaminB2ScalarFieldEnum>
  }


  /**
   * VitaminB2 create
   */
  export type VitaminB2CreateArgs = {
    /**
     * Select specific fields to fetch from the VitaminB2
     * 
    **/
    select?: VitaminB2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB2Include | null
    /**
     * The data needed to create a VitaminB2.
     * 
    **/
    data: XOR<VitaminB2CreateInput, VitaminB2UncheckedCreateInput>
  }


  /**
   * VitaminB2 createMany
   */
  export type VitaminB2CreateManyArgs = {
    /**
     * The data used to create many VitaminB2s.
     * 
    **/
    data: Enumerable<VitaminB2CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VitaminB2 update
   */
  export type VitaminB2UpdateArgs = {
    /**
     * Select specific fields to fetch from the VitaminB2
     * 
    **/
    select?: VitaminB2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB2Include | null
    /**
     * The data needed to update a VitaminB2.
     * 
    **/
    data: XOR<VitaminB2UpdateInput, VitaminB2UncheckedUpdateInput>
    /**
     * Choose, which VitaminB2 to update.
     * 
    **/
    where: VitaminB2WhereUniqueInput
  }


  /**
   * VitaminB2 updateMany
   */
  export type VitaminB2UpdateManyArgs = {
    /**
     * The data used to update VitaminB2s.
     * 
    **/
    data: XOR<VitaminB2UpdateManyMutationInput, VitaminB2UncheckedUpdateManyInput>
    /**
     * Filter which VitaminB2s to update
     * 
    **/
    where?: VitaminB2WhereInput
  }


  /**
   * VitaminB2 upsert
   */
  export type VitaminB2UpsertArgs = {
    /**
     * Select specific fields to fetch from the VitaminB2
     * 
    **/
    select?: VitaminB2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB2Include | null
    /**
     * The filter to search for the VitaminB2 to update in case it exists.
     * 
    **/
    where: VitaminB2WhereUniqueInput
    /**
     * In case the VitaminB2 found by the `where` argument doesn't exist, create a new VitaminB2 with this data.
     * 
    **/
    create: XOR<VitaminB2CreateInput, VitaminB2UncheckedCreateInput>
    /**
     * In case the VitaminB2 was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VitaminB2UpdateInput, VitaminB2UncheckedUpdateInput>
  }


  /**
   * VitaminB2 delete
   */
  export type VitaminB2DeleteArgs = {
    /**
     * Select specific fields to fetch from the VitaminB2
     * 
    **/
    select?: VitaminB2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB2Include | null
    /**
     * Filter which VitaminB2 to delete.
     * 
    **/
    where: VitaminB2WhereUniqueInput
  }


  /**
   * VitaminB2 deleteMany
   */
  export type VitaminB2DeleteManyArgs = {
    /**
     * Filter which VitaminB2s to delete
     * 
    **/
    where?: VitaminB2WhereInput
  }


  /**
   * VitaminB2 without action
   */
  export type VitaminB2Args = {
    /**
     * Select specific fields to fetch from the VitaminB2
     * 
    **/
    select?: VitaminB2Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB2Include | null
  }



  /**
   * Model VitaminB6
   */


  export type AggregateVitaminB6 = {
    _count: VitaminB6CountAggregateOutputType | null
    _avg: VitaminB6AvgAggregateOutputType | null
    _sum: VitaminB6SumAggregateOutputType | null
    _min: VitaminB6MinAggregateOutputType | null
    _max: VitaminB6MaxAggregateOutputType | null
  }

  export type VitaminB6AvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB6SumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB6MinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB6MaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB6CountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type VitaminB6AvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB6SumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB6MinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB6MaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB6CountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type VitaminB6AggregateArgs = {
    /**
     * Filter which VitaminB6 to aggregate.
     * 
    **/
    where?: VitaminB6WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminB6s to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminB6OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VitaminB6WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminB6s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminB6s.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VitaminB6s
    **/
    _count?: true | VitaminB6CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitaminB6AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitaminB6SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitaminB6MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitaminB6MaxAggregateInputType
  }

  export type GetVitaminB6AggregateType<T extends VitaminB6AggregateArgs> = {
        [P in keyof T & keyof AggregateVitaminB6]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitaminB6[P]>
      : GetScalarType<T[P], AggregateVitaminB6[P]>
  }




  export type VitaminB6GroupByArgs = {
    where?: VitaminB6WhereInput
    orderBy?: Enumerable<VitaminB6OrderByWithAggregationInput>
    by: Array<VitaminB6ScalarFieldEnum>
    having?: VitaminB6ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitaminB6CountAggregateInputType | true
    _avg?: VitaminB6AvgAggregateInputType
    _sum?: VitaminB6SumAggregateInputType
    _min?: VitaminB6MinAggregateInputType
    _max?: VitaminB6MaxAggregateInputType
  }


  export type VitaminB6GroupByOutputType = {
    id: number
    measurementId: number
    _count: VitaminB6CountAggregateOutputType | null
    _avg: VitaminB6AvgAggregateOutputType | null
    _sum: VitaminB6SumAggregateOutputType | null
    _min: VitaminB6MinAggregateOutputType | null
    _max: VitaminB6MaxAggregateOutputType | null
  }

  type GetVitaminB6GroupByPayload<T extends VitaminB6GroupByArgs> = PrismaPromise<
    Array<
      PickArray<VitaminB6GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitaminB6GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitaminB6GroupByOutputType[P]>
            : GetScalarType<T[P], VitaminB6GroupByOutputType[P]>
        }
      >
    >


  export type VitaminB6Select = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
    measurementId?: boolean
  }

  export type VitaminB6Include = {
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
  }

  export type VitaminB6GetPayload<
    S extends boolean | null | undefined | VitaminB6Args,
    U = keyof S
      > = S extends true
        ? VitaminB6
    : S extends undefined
    ? never
    : S extends VitaminB6Args | VitaminB6FindManyArgs
    ?'include' extends U
    ? VitaminB6  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['select'][P]> | null :  P extends keyof VitaminB6 ? VitaminB6[P] : never
  } 
    : VitaminB6
  : VitaminB6


  type VitaminB6CountArgs = Merge<
    Omit<VitaminB6FindManyArgs, 'select' | 'include'> & {
      select?: VitaminB6CountAggregateInputType | true
    }
  >

  export interface VitaminB6Delegate<GlobalRejectSettings> {
    /**
     * Find zero or one VitaminB6 that matches the filter.
     * @param {VitaminB6FindUniqueArgs} args - Arguments to find a VitaminB6
     * @example
     * // Get one VitaminB6
     * const vitaminB6 = await prisma.vitaminB6.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VitaminB6FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VitaminB6FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VitaminB6'> extends True ? CheckSelect<T, Prisma__VitaminB6Client<VitaminB6>, Prisma__VitaminB6Client<VitaminB6GetPayload<T>>> : CheckSelect<T, Prisma__VitaminB6Client<VitaminB6 | null >, Prisma__VitaminB6Client<VitaminB6GetPayload<T> | null >>

    /**
     * Find the first VitaminB6 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB6FindFirstArgs} args - Arguments to find a VitaminB6
     * @example
     * // Get one VitaminB6
     * const vitaminB6 = await prisma.vitaminB6.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VitaminB6FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VitaminB6FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VitaminB6'> extends True ? CheckSelect<T, Prisma__VitaminB6Client<VitaminB6>, Prisma__VitaminB6Client<VitaminB6GetPayload<T>>> : CheckSelect<T, Prisma__VitaminB6Client<VitaminB6 | null >, Prisma__VitaminB6Client<VitaminB6GetPayload<T> | null >>

    /**
     * Find zero or more VitaminB6s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB6FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VitaminB6s
     * const vitaminB6s = await prisma.vitaminB6.findMany()
     * 
     * // Get first 10 VitaminB6s
     * const vitaminB6s = await prisma.vitaminB6.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitaminB6WithIdOnly = await prisma.vitaminB6.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VitaminB6FindManyArgs>(
      args?: SelectSubset<T, VitaminB6FindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VitaminB6>>, PrismaPromise<Array<VitaminB6GetPayload<T>>>>

    /**
     * Create a VitaminB6.
     * @param {VitaminB6CreateArgs} args - Arguments to create a VitaminB6.
     * @example
     * // Create one VitaminB6
     * const VitaminB6 = await prisma.vitaminB6.create({
     *   data: {
     *     // ... data to create a VitaminB6
     *   }
     * })
     * 
    **/
    create<T extends VitaminB6CreateArgs>(
      args: SelectSubset<T, VitaminB6CreateArgs>
    ): CheckSelect<T, Prisma__VitaminB6Client<VitaminB6>, Prisma__VitaminB6Client<VitaminB6GetPayload<T>>>

    /**
     * Create many VitaminB6s.
     *     @param {VitaminB6CreateManyArgs} args - Arguments to create many VitaminB6s.
     *     @example
     *     // Create many VitaminB6s
     *     const vitaminB6 = await prisma.vitaminB6.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VitaminB6CreateManyArgs>(
      args?: SelectSubset<T, VitaminB6CreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VitaminB6.
     * @param {VitaminB6DeleteArgs} args - Arguments to delete one VitaminB6.
     * @example
     * // Delete one VitaminB6
     * const VitaminB6 = await prisma.vitaminB6.delete({
     *   where: {
     *     // ... filter to delete one VitaminB6
     *   }
     * })
     * 
    **/
    delete<T extends VitaminB6DeleteArgs>(
      args: SelectSubset<T, VitaminB6DeleteArgs>
    ): CheckSelect<T, Prisma__VitaminB6Client<VitaminB6>, Prisma__VitaminB6Client<VitaminB6GetPayload<T>>>

    /**
     * Update one VitaminB6.
     * @param {VitaminB6UpdateArgs} args - Arguments to update one VitaminB6.
     * @example
     * // Update one VitaminB6
     * const vitaminB6 = await prisma.vitaminB6.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VitaminB6UpdateArgs>(
      args: SelectSubset<T, VitaminB6UpdateArgs>
    ): CheckSelect<T, Prisma__VitaminB6Client<VitaminB6>, Prisma__VitaminB6Client<VitaminB6GetPayload<T>>>

    /**
     * Delete zero or more VitaminB6s.
     * @param {VitaminB6DeleteManyArgs} args - Arguments to filter VitaminB6s to delete.
     * @example
     * // Delete a few VitaminB6s
     * const { count } = await prisma.vitaminB6.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VitaminB6DeleteManyArgs>(
      args?: SelectSubset<T, VitaminB6DeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitaminB6s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB6UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VitaminB6s
     * const vitaminB6 = await prisma.vitaminB6.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VitaminB6UpdateManyArgs>(
      args: SelectSubset<T, VitaminB6UpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VitaminB6.
     * @param {VitaminB6UpsertArgs} args - Arguments to update or create a VitaminB6.
     * @example
     * // Update or create a VitaminB6
     * const vitaminB6 = await prisma.vitaminB6.upsert({
     *   create: {
     *     // ... data to create a VitaminB6
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VitaminB6 we want to update
     *   }
     * })
    **/
    upsert<T extends VitaminB6UpsertArgs>(
      args: SelectSubset<T, VitaminB6UpsertArgs>
    ): CheckSelect<T, Prisma__VitaminB6Client<VitaminB6>, Prisma__VitaminB6Client<VitaminB6GetPayload<T>>>

    /**
     * Count the number of VitaminB6s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB6CountArgs} args - Arguments to filter VitaminB6s to count.
     * @example
     * // Count the number of VitaminB6s
     * const count = await prisma.vitaminB6.count({
     *   where: {
     *     // ... the filter for the VitaminB6s we want to count
     *   }
     * })
    **/
    count<T extends VitaminB6CountArgs>(
      args?: Subset<T, VitaminB6CountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitaminB6CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VitaminB6.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB6AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitaminB6AggregateArgs>(args: Subset<T, VitaminB6AggregateArgs>): PrismaPromise<GetVitaminB6AggregateType<T>>

    /**
     * Group by VitaminB6.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB6GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitaminB6GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitaminB6GroupByArgs['orderBy'] }
        : { orderBy?: VitaminB6GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitaminB6GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitaminB6GroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VitaminB6.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VitaminB6Client<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    vitamin<T extends VitaminArgs = {}>(args?: Subset<T, VitaminArgs>): CheckSelect<T, Prisma__VitaminClient<Vitamin | null >, Prisma__VitaminClient<VitaminGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VitaminB6 findUnique
   */
  export type VitaminB6FindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VitaminB6
     * 
    **/
    select?: VitaminB6Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB6Include | null
    /**
     * Throw an Error if a VitaminB6 can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminB6 to fetch.
     * 
    **/
    where: VitaminB6WhereUniqueInput
  }


  /**
   * VitaminB6 findFirst
   */
  export type VitaminB6FindFirstArgs = {
    /**
     * Select specific fields to fetch from the VitaminB6
     * 
    **/
    select?: VitaminB6Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB6Include | null
    /**
     * Throw an Error if a VitaminB6 can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminB6 to fetch.
     * 
    **/
    where?: VitaminB6WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminB6s to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminB6OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitaminB6s.
     * 
    **/
    cursor?: VitaminB6WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminB6s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminB6s.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitaminB6s.
     * 
    **/
    distinct?: Enumerable<VitaminB6ScalarFieldEnum>
  }


  /**
   * VitaminB6 findMany
   */
  export type VitaminB6FindManyArgs = {
    /**
     * Select specific fields to fetch from the VitaminB6
     * 
    **/
    select?: VitaminB6Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB6Include | null
    /**
     * Filter, which VitaminB6s to fetch.
     * 
    **/
    where?: VitaminB6WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminB6s to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminB6OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VitaminB6s.
     * 
    **/
    cursor?: VitaminB6WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminB6s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminB6s.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VitaminB6ScalarFieldEnum>
  }


  /**
   * VitaminB6 create
   */
  export type VitaminB6CreateArgs = {
    /**
     * Select specific fields to fetch from the VitaminB6
     * 
    **/
    select?: VitaminB6Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB6Include | null
    /**
     * The data needed to create a VitaminB6.
     * 
    **/
    data: XOR<VitaminB6CreateInput, VitaminB6UncheckedCreateInput>
  }


  /**
   * VitaminB6 createMany
   */
  export type VitaminB6CreateManyArgs = {
    /**
     * The data used to create many VitaminB6s.
     * 
    **/
    data: Enumerable<VitaminB6CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VitaminB6 update
   */
  export type VitaminB6UpdateArgs = {
    /**
     * Select specific fields to fetch from the VitaminB6
     * 
    **/
    select?: VitaminB6Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB6Include | null
    /**
     * The data needed to update a VitaminB6.
     * 
    **/
    data: XOR<VitaminB6UpdateInput, VitaminB6UncheckedUpdateInput>
    /**
     * Choose, which VitaminB6 to update.
     * 
    **/
    where: VitaminB6WhereUniqueInput
  }


  /**
   * VitaminB6 updateMany
   */
  export type VitaminB6UpdateManyArgs = {
    /**
     * The data used to update VitaminB6s.
     * 
    **/
    data: XOR<VitaminB6UpdateManyMutationInput, VitaminB6UncheckedUpdateManyInput>
    /**
     * Filter which VitaminB6s to update
     * 
    **/
    where?: VitaminB6WhereInput
  }


  /**
   * VitaminB6 upsert
   */
  export type VitaminB6UpsertArgs = {
    /**
     * Select specific fields to fetch from the VitaminB6
     * 
    **/
    select?: VitaminB6Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB6Include | null
    /**
     * The filter to search for the VitaminB6 to update in case it exists.
     * 
    **/
    where: VitaminB6WhereUniqueInput
    /**
     * In case the VitaminB6 found by the `where` argument doesn't exist, create a new VitaminB6 with this data.
     * 
    **/
    create: XOR<VitaminB6CreateInput, VitaminB6UncheckedCreateInput>
    /**
     * In case the VitaminB6 was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VitaminB6UpdateInput, VitaminB6UncheckedUpdateInput>
  }


  /**
   * VitaminB6 delete
   */
  export type VitaminB6DeleteArgs = {
    /**
     * Select specific fields to fetch from the VitaminB6
     * 
    **/
    select?: VitaminB6Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB6Include | null
    /**
     * Filter which VitaminB6 to delete.
     * 
    **/
    where: VitaminB6WhereUniqueInput
  }


  /**
   * VitaminB6 deleteMany
   */
  export type VitaminB6DeleteManyArgs = {
    /**
     * Filter which VitaminB6s to delete
     * 
    **/
    where?: VitaminB6WhereInput
  }


  /**
   * VitaminB6 without action
   */
  export type VitaminB6Args = {
    /**
     * Select specific fields to fetch from the VitaminB6
     * 
    **/
    select?: VitaminB6Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB6Include | null
  }



  /**
   * Model VitaminB12
   */


  export type AggregateVitaminB12 = {
    _count: VitaminB12CountAggregateOutputType | null
    _avg: VitaminB12AvgAggregateOutputType | null
    _sum: VitaminB12SumAggregateOutputType | null
    _min: VitaminB12MinAggregateOutputType | null
    _max: VitaminB12MaxAggregateOutputType | null
  }

  export type VitaminB12AvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB12SumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB12MinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB12MaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type VitaminB12CountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type VitaminB12AvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB12SumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB12MinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB12MaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type VitaminB12CountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type VitaminB12AggregateArgs = {
    /**
     * Filter which VitaminB12 to aggregate.
     * 
    **/
    where?: VitaminB12WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminB12s to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminB12OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: VitaminB12WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminB12s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminB12s.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VitaminB12s
    **/
    _count?: true | VitaminB12CountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VitaminB12AvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VitaminB12SumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VitaminB12MinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VitaminB12MaxAggregateInputType
  }

  export type GetVitaminB12AggregateType<T extends VitaminB12AggregateArgs> = {
        [P in keyof T & keyof AggregateVitaminB12]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVitaminB12[P]>
      : GetScalarType<T[P], AggregateVitaminB12[P]>
  }




  export type VitaminB12GroupByArgs = {
    where?: VitaminB12WhereInput
    orderBy?: Enumerable<VitaminB12OrderByWithAggregationInput>
    by: Array<VitaminB12ScalarFieldEnum>
    having?: VitaminB12ScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VitaminB12CountAggregateInputType | true
    _avg?: VitaminB12AvgAggregateInputType
    _sum?: VitaminB12SumAggregateInputType
    _min?: VitaminB12MinAggregateInputType
    _max?: VitaminB12MaxAggregateInputType
  }


  export type VitaminB12GroupByOutputType = {
    id: number
    measurementId: number
    _count: VitaminB12CountAggregateOutputType | null
    _avg: VitaminB12AvgAggregateOutputType | null
    _sum: VitaminB12SumAggregateOutputType | null
    _min: VitaminB12MinAggregateOutputType | null
    _max: VitaminB12MaxAggregateOutputType | null
  }

  type GetVitaminB12GroupByPayload<T extends VitaminB12GroupByArgs> = PrismaPromise<
    Array<
      PickArray<VitaminB12GroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VitaminB12GroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VitaminB12GroupByOutputType[P]>
            : GetScalarType<T[P], VitaminB12GroupByOutputType[P]>
        }
      >
    >


  export type VitaminB12Select = {
    id?: boolean
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
    measurementId?: boolean
  }

  export type VitaminB12Include = {
    measurement?: boolean | MeasurementArgs
    vitamin?: boolean | VitaminArgs
  }

  export type VitaminB12GetPayload<
    S extends boolean | null | undefined | VitaminB12Args,
    U = keyof S
      > = S extends true
        ? VitaminB12
    : S extends undefined
    ? never
    : S extends VitaminB12Args | VitaminB12FindManyArgs
    ?'include' extends U
    ? VitaminB12  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['include'][P]> | null :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'vitamin' ? VitaminGetPayload<S['select'][P]> | null :  P extends keyof VitaminB12 ? VitaminB12[P] : never
  } 
    : VitaminB12
  : VitaminB12


  type VitaminB12CountArgs = Merge<
    Omit<VitaminB12FindManyArgs, 'select' | 'include'> & {
      select?: VitaminB12CountAggregateInputType | true
    }
  >

  export interface VitaminB12Delegate<GlobalRejectSettings> {
    /**
     * Find zero or one VitaminB12 that matches the filter.
     * @param {VitaminB12FindUniqueArgs} args - Arguments to find a VitaminB12
     * @example
     * // Get one VitaminB12
     * const vitaminB12 = await prisma.vitaminB12.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends VitaminB12FindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, VitaminB12FindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'VitaminB12'> extends True ? CheckSelect<T, Prisma__VitaminB12Client<VitaminB12>, Prisma__VitaminB12Client<VitaminB12GetPayload<T>>> : CheckSelect<T, Prisma__VitaminB12Client<VitaminB12 | null >, Prisma__VitaminB12Client<VitaminB12GetPayload<T> | null >>

    /**
     * Find the first VitaminB12 that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB12FindFirstArgs} args - Arguments to find a VitaminB12
     * @example
     * // Get one VitaminB12
     * const vitaminB12 = await prisma.vitaminB12.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends VitaminB12FindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, VitaminB12FindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'VitaminB12'> extends True ? CheckSelect<T, Prisma__VitaminB12Client<VitaminB12>, Prisma__VitaminB12Client<VitaminB12GetPayload<T>>> : CheckSelect<T, Prisma__VitaminB12Client<VitaminB12 | null >, Prisma__VitaminB12Client<VitaminB12GetPayload<T> | null >>

    /**
     * Find zero or more VitaminB12s that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB12FindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VitaminB12s
     * const vitaminB12s = await prisma.vitaminB12.findMany()
     * 
     * // Get first 10 VitaminB12s
     * const vitaminB12s = await prisma.vitaminB12.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vitaminB12WithIdOnly = await prisma.vitaminB12.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends VitaminB12FindManyArgs>(
      args?: SelectSubset<T, VitaminB12FindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<VitaminB12>>, PrismaPromise<Array<VitaminB12GetPayload<T>>>>

    /**
     * Create a VitaminB12.
     * @param {VitaminB12CreateArgs} args - Arguments to create a VitaminB12.
     * @example
     * // Create one VitaminB12
     * const VitaminB12 = await prisma.vitaminB12.create({
     *   data: {
     *     // ... data to create a VitaminB12
     *   }
     * })
     * 
    **/
    create<T extends VitaminB12CreateArgs>(
      args: SelectSubset<T, VitaminB12CreateArgs>
    ): CheckSelect<T, Prisma__VitaminB12Client<VitaminB12>, Prisma__VitaminB12Client<VitaminB12GetPayload<T>>>

    /**
     * Create many VitaminB12s.
     *     @param {VitaminB12CreateManyArgs} args - Arguments to create many VitaminB12s.
     *     @example
     *     // Create many VitaminB12s
     *     const vitaminB12 = await prisma.vitaminB12.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends VitaminB12CreateManyArgs>(
      args?: SelectSubset<T, VitaminB12CreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a VitaminB12.
     * @param {VitaminB12DeleteArgs} args - Arguments to delete one VitaminB12.
     * @example
     * // Delete one VitaminB12
     * const VitaminB12 = await prisma.vitaminB12.delete({
     *   where: {
     *     // ... filter to delete one VitaminB12
     *   }
     * })
     * 
    **/
    delete<T extends VitaminB12DeleteArgs>(
      args: SelectSubset<T, VitaminB12DeleteArgs>
    ): CheckSelect<T, Prisma__VitaminB12Client<VitaminB12>, Prisma__VitaminB12Client<VitaminB12GetPayload<T>>>

    /**
     * Update one VitaminB12.
     * @param {VitaminB12UpdateArgs} args - Arguments to update one VitaminB12.
     * @example
     * // Update one VitaminB12
     * const vitaminB12 = await prisma.vitaminB12.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends VitaminB12UpdateArgs>(
      args: SelectSubset<T, VitaminB12UpdateArgs>
    ): CheckSelect<T, Prisma__VitaminB12Client<VitaminB12>, Prisma__VitaminB12Client<VitaminB12GetPayload<T>>>

    /**
     * Delete zero or more VitaminB12s.
     * @param {VitaminB12DeleteManyArgs} args - Arguments to filter VitaminB12s to delete.
     * @example
     * // Delete a few VitaminB12s
     * const { count } = await prisma.vitaminB12.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends VitaminB12DeleteManyArgs>(
      args?: SelectSubset<T, VitaminB12DeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more VitaminB12s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB12UpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VitaminB12s
     * const vitaminB12 = await prisma.vitaminB12.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends VitaminB12UpdateManyArgs>(
      args: SelectSubset<T, VitaminB12UpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one VitaminB12.
     * @param {VitaminB12UpsertArgs} args - Arguments to update or create a VitaminB12.
     * @example
     * // Update or create a VitaminB12
     * const vitaminB12 = await prisma.vitaminB12.upsert({
     *   create: {
     *     // ... data to create a VitaminB12
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VitaminB12 we want to update
     *   }
     * })
    **/
    upsert<T extends VitaminB12UpsertArgs>(
      args: SelectSubset<T, VitaminB12UpsertArgs>
    ): CheckSelect<T, Prisma__VitaminB12Client<VitaminB12>, Prisma__VitaminB12Client<VitaminB12GetPayload<T>>>

    /**
     * Count the number of VitaminB12s.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB12CountArgs} args - Arguments to filter VitaminB12s to count.
     * @example
     * // Count the number of VitaminB12s
     * const count = await prisma.vitaminB12.count({
     *   where: {
     *     // ... the filter for the VitaminB12s we want to count
     *   }
     * })
    **/
    count<T extends VitaminB12CountArgs>(
      args?: Subset<T, VitaminB12CountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VitaminB12CountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VitaminB12.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB12AggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VitaminB12AggregateArgs>(args: Subset<T, VitaminB12AggregateArgs>): PrismaPromise<GetVitaminB12AggregateType<T>>

    /**
     * Group by VitaminB12.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VitaminB12GroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VitaminB12GroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VitaminB12GroupByArgs['orderBy'] }
        : { orderBy?: VitaminB12GroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VitaminB12GroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVitaminB12GroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for VitaminB12.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__VitaminB12Client<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    vitamin<T extends VitaminArgs = {}>(args?: Subset<T, VitaminArgs>): CheckSelect<T, Prisma__VitaminClient<Vitamin | null >, Prisma__VitaminClient<VitaminGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * VitaminB12 findUnique
   */
  export type VitaminB12FindUniqueArgs = {
    /**
     * Select specific fields to fetch from the VitaminB12
     * 
    **/
    select?: VitaminB12Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB12Include | null
    /**
     * Throw an Error if a VitaminB12 can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminB12 to fetch.
     * 
    **/
    where: VitaminB12WhereUniqueInput
  }


  /**
   * VitaminB12 findFirst
   */
  export type VitaminB12FindFirstArgs = {
    /**
     * Select specific fields to fetch from the VitaminB12
     * 
    **/
    select?: VitaminB12Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB12Include | null
    /**
     * Throw an Error if a VitaminB12 can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which VitaminB12 to fetch.
     * 
    **/
    where?: VitaminB12WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminB12s to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminB12OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VitaminB12s.
     * 
    **/
    cursor?: VitaminB12WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminB12s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminB12s.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VitaminB12s.
     * 
    **/
    distinct?: Enumerable<VitaminB12ScalarFieldEnum>
  }


  /**
   * VitaminB12 findMany
   */
  export type VitaminB12FindManyArgs = {
    /**
     * Select specific fields to fetch from the VitaminB12
     * 
    **/
    select?: VitaminB12Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB12Include | null
    /**
     * Filter, which VitaminB12s to fetch.
     * 
    **/
    where?: VitaminB12WhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VitaminB12s to fetch.
     * 
    **/
    orderBy?: Enumerable<VitaminB12OrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VitaminB12s.
     * 
    **/
    cursor?: VitaminB12WhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VitaminB12s from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VitaminB12s.
     * 
    **/
    skip?: number
    distinct?: Enumerable<VitaminB12ScalarFieldEnum>
  }


  /**
   * VitaminB12 create
   */
  export type VitaminB12CreateArgs = {
    /**
     * Select specific fields to fetch from the VitaminB12
     * 
    **/
    select?: VitaminB12Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB12Include | null
    /**
     * The data needed to create a VitaminB12.
     * 
    **/
    data: XOR<VitaminB12CreateInput, VitaminB12UncheckedCreateInput>
  }


  /**
   * VitaminB12 createMany
   */
  export type VitaminB12CreateManyArgs = {
    /**
     * The data used to create many VitaminB12s.
     * 
    **/
    data: Enumerable<VitaminB12CreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * VitaminB12 update
   */
  export type VitaminB12UpdateArgs = {
    /**
     * Select specific fields to fetch from the VitaminB12
     * 
    **/
    select?: VitaminB12Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB12Include | null
    /**
     * The data needed to update a VitaminB12.
     * 
    **/
    data: XOR<VitaminB12UpdateInput, VitaminB12UncheckedUpdateInput>
    /**
     * Choose, which VitaminB12 to update.
     * 
    **/
    where: VitaminB12WhereUniqueInput
  }


  /**
   * VitaminB12 updateMany
   */
  export type VitaminB12UpdateManyArgs = {
    /**
     * The data used to update VitaminB12s.
     * 
    **/
    data: XOR<VitaminB12UpdateManyMutationInput, VitaminB12UncheckedUpdateManyInput>
    /**
     * Filter which VitaminB12s to update
     * 
    **/
    where?: VitaminB12WhereInput
  }


  /**
   * VitaminB12 upsert
   */
  export type VitaminB12UpsertArgs = {
    /**
     * Select specific fields to fetch from the VitaminB12
     * 
    **/
    select?: VitaminB12Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB12Include | null
    /**
     * The filter to search for the VitaminB12 to update in case it exists.
     * 
    **/
    where: VitaminB12WhereUniqueInput
    /**
     * In case the VitaminB12 found by the `where` argument doesn't exist, create a new VitaminB12 with this data.
     * 
    **/
    create: XOR<VitaminB12CreateInput, VitaminB12UncheckedCreateInput>
    /**
     * In case the VitaminB12 was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<VitaminB12UpdateInput, VitaminB12UncheckedUpdateInput>
  }


  /**
   * VitaminB12 delete
   */
  export type VitaminB12DeleteArgs = {
    /**
     * Select specific fields to fetch from the VitaminB12
     * 
    **/
    select?: VitaminB12Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB12Include | null
    /**
     * Filter which VitaminB12 to delete.
     * 
    **/
    where: VitaminB12WhereUniqueInput
  }


  /**
   * VitaminB12 deleteMany
   */
  export type VitaminB12DeleteManyArgs = {
    /**
     * Filter which VitaminB12s to delete
     * 
    **/
    where?: VitaminB12WhereInput
  }


  /**
   * VitaminB12 without action
   */
  export type VitaminB12Args = {
    /**
     * Select specific fields to fetch from the VitaminB12
     * 
    **/
    select?: VitaminB12Select | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: VitaminB12Include | null
  }



  /**
   * Model Salt
   */


  export type AggregateSalt = {
    _count: SaltCountAggregateOutputType | null
    _avg: SaltAvgAggregateOutputType | null
    _sum: SaltSumAggregateOutputType | null
    _min: SaltMinAggregateOutputType | null
    _max: SaltMaxAggregateOutputType | null
  }

  export type SaltAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SaltSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SaltMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SaltMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SaltCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type SaltAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SaltSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SaltMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SaltMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SaltCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type SaltAggregateArgs = {
    /**
     * Filter which Salt to aggregate.
     * 
    **/
    where?: SaltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salts to fetch.
     * 
    **/
    orderBy?: Enumerable<SaltOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SaltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Salts
    **/
    _count?: true | SaltCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SaltAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SaltSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SaltMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SaltMaxAggregateInputType
  }

  export type GetSaltAggregateType<T extends SaltAggregateArgs> = {
        [P in keyof T & keyof AggregateSalt]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSalt[P]>
      : GetScalarType<T[P], AggregateSalt[P]>
  }




  export type SaltGroupByArgs = {
    where?: SaltWhereInput
    orderBy?: Enumerable<SaltOrderByWithAggregationInput>
    by: Array<SaltScalarFieldEnum>
    having?: SaltScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SaltCountAggregateInputType | true
    _avg?: SaltAvgAggregateInputType
    _sum?: SaltSumAggregateInputType
    _min?: SaltMinAggregateInputType
    _max?: SaltMaxAggregateInputType
  }


  export type SaltGroupByOutputType = {
    id: number
    measurementId: number
    _count: SaltCountAggregateOutputType | null
    _avg: SaltAvgAggregateOutputType | null
    _sum: SaltSumAggregateOutputType | null
    _min: SaltMinAggregateOutputType | null
    _max: SaltMaxAggregateOutputType | null
  }

  type GetSaltGroupByPayload<T extends SaltGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SaltGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SaltGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SaltGroupByOutputType[P]>
            : GetScalarType<T[P], SaltGroupByOutputType[P]>
        }
      >
    >


  export type SaltSelect = {
    id?: boolean
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    measurementId?: boolean
    _count?: boolean | SaltCountOutputTypeArgs
  }

  export type SaltInclude = {
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    _count?: boolean | SaltCountOutputTypeArgs
  }

  export type SaltGetPayload<
    S extends boolean | null | undefined | SaltArgs,
    U = keyof S
      > = S extends true
        ? Salt
    : S extends undefined
    ? never
    : S extends SaltArgs | SaltFindManyArgs
    ?'include' extends U
    ? Salt  & {
    [P in TrueKeys<S['include']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['include'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends '_count' ? SaltCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['select'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends '_count' ? SaltCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Salt ? Salt[P] : never
  } 
    : Salt
  : Salt


  type SaltCountArgs = Merge<
    Omit<SaltFindManyArgs, 'select' | 'include'> & {
      select?: SaltCountAggregateInputType | true
    }
  >

  export interface SaltDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Salt that matches the filter.
     * @param {SaltFindUniqueArgs} args - Arguments to find a Salt
     * @example
     * // Get one Salt
     * const salt = await prisma.salt.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SaltFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SaltFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Salt'> extends True ? CheckSelect<T, Prisma__SaltClient<Salt>, Prisma__SaltClient<SaltGetPayload<T>>> : CheckSelect<T, Prisma__SaltClient<Salt | null >, Prisma__SaltClient<SaltGetPayload<T> | null >>

    /**
     * Find the first Salt that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaltFindFirstArgs} args - Arguments to find a Salt
     * @example
     * // Get one Salt
     * const salt = await prisma.salt.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SaltFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SaltFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Salt'> extends True ? CheckSelect<T, Prisma__SaltClient<Salt>, Prisma__SaltClient<SaltGetPayload<T>>> : CheckSelect<T, Prisma__SaltClient<Salt | null >, Prisma__SaltClient<SaltGetPayload<T> | null >>

    /**
     * Find zero or more Salts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaltFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Salts
     * const salts = await prisma.salt.findMany()
     * 
     * // Get first 10 Salts
     * const salts = await prisma.salt.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const saltWithIdOnly = await prisma.salt.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SaltFindManyArgs>(
      args?: SelectSubset<T, SaltFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Salt>>, PrismaPromise<Array<SaltGetPayload<T>>>>

    /**
     * Create a Salt.
     * @param {SaltCreateArgs} args - Arguments to create a Salt.
     * @example
     * // Create one Salt
     * const Salt = await prisma.salt.create({
     *   data: {
     *     // ... data to create a Salt
     *   }
     * })
     * 
    **/
    create<T extends SaltCreateArgs>(
      args: SelectSubset<T, SaltCreateArgs>
    ): CheckSelect<T, Prisma__SaltClient<Salt>, Prisma__SaltClient<SaltGetPayload<T>>>

    /**
     * Create many Salts.
     *     @param {SaltCreateManyArgs} args - Arguments to create many Salts.
     *     @example
     *     // Create many Salts
     *     const salt = await prisma.salt.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SaltCreateManyArgs>(
      args?: SelectSubset<T, SaltCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Salt.
     * @param {SaltDeleteArgs} args - Arguments to delete one Salt.
     * @example
     * // Delete one Salt
     * const Salt = await prisma.salt.delete({
     *   where: {
     *     // ... filter to delete one Salt
     *   }
     * })
     * 
    **/
    delete<T extends SaltDeleteArgs>(
      args: SelectSubset<T, SaltDeleteArgs>
    ): CheckSelect<T, Prisma__SaltClient<Salt>, Prisma__SaltClient<SaltGetPayload<T>>>

    /**
     * Update one Salt.
     * @param {SaltUpdateArgs} args - Arguments to update one Salt.
     * @example
     * // Update one Salt
     * const salt = await prisma.salt.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SaltUpdateArgs>(
      args: SelectSubset<T, SaltUpdateArgs>
    ): CheckSelect<T, Prisma__SaltClient<Salt>, Prisma__SaltClient<SaltGetPayload<T>>>

    /**
     * Delete zero or more Salts.
     * @param {SaltDeleteManyArgs} args - Arguments to filter Salts to delete.
     * @example
     * // Delete a few Salts
     * const { count } = await prisma.salt.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SaltDeleteManyArgs>(
      args?: SelectSubset<T, SaltDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Salts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaltUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Salts
     * const salt = await prisma.salt.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SaltUpdateManyArgs>(
      args: SelectSubset<T, SaltUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Salt.
     * @param {SaltUpsertArgs} args - Arguments to update or create a Salt.
     * @example
     * // Update or create a Salt
     * const salt = await prisma.salt.upsert({
     *   create: {
     *     // ... data to create a Salt
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Salt we want to update
     *   }
     * })
    **/
    upsert<T extends SaltUpsertArgs>(
      args: SelectSubset<T, SaltUpsertArgs>
    ): CheckSelect<T, Prisma__SaltClient<Salt>, Prisma__SaltClient<SaltGetPayload<T>>>

    /**
     * Count the number of Salts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaltCountArgs} args - Arguments to filter Salts to count.
     * @example
     * // Count the number of Salts
     * const count = await prisma.salt.count({
     *   where: {
     *     // ... the filter for the Salts we want to count
     *   }
     * })
    **/
    count<T extends SaltCountArgs>(
      args?: Subset<T, SaltCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SaltCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Salt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaltAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SaltAggregateArgs>(args: Subset<T, SaltAggregateArgs>): PrismaPromise<GetSaltAggregateType<T>>

    /**
     * Group by Salt.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SaltGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SaltGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SaltGroupByArgs['orderBy'] }
        : { orderBy?: SaltGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SaltGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSaltGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Salt.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SaltClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    minerals<T extends MineralFindManyArgs = {}>(args?: Subset<T, MineralFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mineral>>, PrismaPromise<Array<MineralGetPayload<T>>>>;

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Salt findUnique
   */
  export type SaltFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Salt
     * 
    **/
    select?: SaltSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaltInclude | null
    /**
     * Throw an Error if a Salt can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Salt to fetch.
     * 
    **/
    where: SaltWhereUniqueInput
  }


  /**
   * Salt findFirst
   */
  export type SaltFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Salt
     * 
    **/
    select?: SaltSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaltInclude | null
    /**
     * Throw an Error if a Salt can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Salt to fetch.
     * 
    **/
    where?: SaltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salts to fetch.
     * 
    **/
    orderBy?: Enumerable<SaltOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Salts.
     * 
    **/
    cursor?: SaltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Salts.
     * 
    **/
    distinct?: Enumerable<SaltScalarFieldEnum>
  }


  /**
   * Salt findMany
   */
  export type SaltFindManyArgs = {
    /**
     * Select specific fields to fetch from the Salt
     * 
    **/
    select?: SaltSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaltInclude | null
    /**
     * Filter, which Salts to fetch.
     * 
    **/
    where?: SaltWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Salts to fetch.
     * 
    **/
    orderBy?: Enumerable<SaltOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Salts.
     * 
    **/
    cursor?: SaltWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Salts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Salts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SaltScalarFieldEnum>
  }


  /**
   * Salt create
   */
  export type SaltCreateArgs = {
    /**
     * Select specific fields to fetch from the Salt
     * 
    **/
    select?: SaltSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaltInclude | null
    /**
     * The data needed to create a Salt.
     * 
    **/
    data: XOR<SaltCreateInput, SaltUncheckedCreateInput>
  }


  /**
   * Salt createMany
   */
  export type SaltCreateManyArgs = {
    /**
     * The data used to create many Salts.
     * 
    **/
    data: Enumerable<SaltCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Salt update
   */
  export type SaltUpdateArgs = {
    /**
     * Select specific fields to fetch from the Salt
     * 
    **/
    select?: SaltSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaltInclude | null
    /**
     * The data needed to update a Salt.
     * 
    **/
    data: XOR<SaltUpdateInput, SaltUncheckedUpdateInput>
    /**
     * Choose, which Salt to update.
     * 
    **/
    where: SaltWhereUniqueInput
  }


  /**
   * Salt updateMany
   */
  export type SaltUpdateManyArgs = {
    /**
     * The data used to update Salts.
     * 
    **/
    data: XOR<SaltUpdateManyMutationInput, SaltUncheckedUpdateManyInput>
    /**
     * Filter which Salts to update
     * 
    **/
    where?: SaltWhereInput
  }


  /**
   * Salt upsert
   */
  export type SaltUpsertArgs = {
    /**
     * Select specific fields to fetch from the Salt
     * 
    **/
    select?: SaltSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaltInclude | null
    /**
     * The filter to search for the Salt to update in case it exists.
     * 
    **/
    where: SaltWhereUniqueInput
    /**
     * In case the Salt found by the `where` argument doesn't exist, create a new Salt with this data.
     * 
    **/
    create: XOR<SaltCreateInput, SaltUncheckedCreateInput>
    /**
     * In case the Salt was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SaltUpdateInput, SaltUncheckedUpdateInput>
  }


  /**
   * Salt delete
   */
  export type SaltDeleteArgs = {
    /**
     * Select specific fields to fetch from the Salt
     * 
    **/
    select?: SaltSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaltInclude | null
    /**
     * Filter which Salt to delete.
     * 
    **/
    where: SaltWhereUniqueInput
  }


  /**
   * Salt deleteMany
   */
  export type SaltDeleteManyArgs = {
    /**
     * Filter which Salts to delete
     * 
    **/
    where?: SaltWhereInput
  }


  /**
   * Salt without action
   */
  export type SaltArgs = {
    /**
     * Select specific fields to fetch from the Salt
     * 
    **/
    select?: SaltSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SaltInclude | null
  }



  /**
   * Model Zinc
   */


  export type AggregateZinc = {
    _count: ZincCountAggregateOutputType | null
    _avg: ZincAvgAggregateOutputType | null
    _sum: ZincSumAggregateOutputType | null
    _min: ZincMinAggregateOutputType | null
    _max: ZincMaxAggregateOutputType | null
  }

  export type ZincAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type ZincSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type ZincMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type ZincMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type ZincCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type ZincAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type ZincSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type ZincMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type ZincMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type ZincCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type ZincAggregateArgs = {
    /**
     * Filter which Zinc to aggregate.
     * 
    **/
    where?: ZincWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zincs to fetch.
     * 
    **/
    orderBy?: Enumerable<ZincOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ZincWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zincs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zincs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Zincs
    **/
    _count?: true | ZincCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ZincAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ZincSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZincMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZincMaxAggregateInputType
  }

  export type GetZincAggregateType<T extends ZincAggregateArgs> = {
        [P in keyof T & keyof AggregateZinc]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZinc[P]>
      : GetScalarType<T[P], AggregateZinc[P]>
  }




  export type ZincGroupByArgs = {
    where?: ZincWhereInput
    orderBy?: Enumerable<ZincOrderByWithAggregationInput>
    by: Array<ZincScalarFieldEnum>
    having?: ZincScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZincCountAggregateInputType | true
    _avg?: ZincAvgAggregateInputType
    _sum?: ZincSumAggregateInputType
    _min?: ZincMinAggregateInputType
    _max?: ZincMaxAggregateInputType
  }


  export type ZincGroupByOutputType = {
    id: number
    measurementId: number
    _count: ZincCountAggregateOutputType | null
    _avg: ZincAvgAggregateOutputType | null
    _sum: ZincSumAggregateOutputType | null
    _min: ZincMinAggregateOutputType | null
    _max: ZincMaxAggregateOutputType | null
  }

  type GetZincGroupByPayload<T extends ZincGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ZincGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZincGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZincGroupByOutputType[P]>
            : GetScalarType<T[P], ZincGroupByOutputType[P]>
        }
      >
    >


  export type ZincSelect = {
    id?: boolean
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    measurementId?: boolean
    _count?: boolean | ZincCountOutputTypeArgs
  }

  export type ZincInclude = {
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    _count?: boolean | ZincCountOutputTypeArgs
  }

  export type ZincGetPayload<
    S extends boolean | null | undefined | ZincArgs,
    U = keyof S
      > = S extends true
        ? Zinc
    : S extends undefined
    ? never
    : S extends ZincArgs | ZincFindManyArgs
    ?'include' extends U
    ? Zinc  & {
    [P in TrueKeys<S['include']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['include'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends '_count' ? ZincCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['select'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends '_count' ? ZincCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Zinc ? Zinc[P] : never
  } 
    : Zinc
  : Zinc


  type ZincCountArgs = Merge<
    Omit<ZincFindManyArgs, 'select' | 'include'> & {
      select?: ZincCountAggregateInputType | true
    }
  >

  export interface ZincDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Zinc that matches the filter.
     * @param {ZincFindUniqueArgs} args - Arguments to find a Zinc
     * @example
     * // Get one Zinc
     * const zinc = await prisma.zinc.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ZincFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ZincFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Zinc'> extends True ? CheckSelect<T, Prisma__ZincClient<Zinc>, Prisma__ZincClient<ZincGetPayload<T>>> : CheckSelect<T, Prisma__ZincClient<Zinc | null >, Prisma__ZincClient<ZincGetPayload<T> | null >>

    /**
     * Find the first Zinc that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZincFindFirstArgs} args - Arguments to find a Zinc
     * @example
     * // Get one Zinc
     * const zinc = await prisma.zinc.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ZincFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ZincFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Zinc'> extends True ? CheckSelect<T, Prisma__ZincClient<Zinc>, Prisma__ZincClient<ZincGetPayload<T>>> : CheckSelect<T, Prisma__ZincClient<Zinc | null >, Prisma__ZincClient<ZincGetPayload<T> | null >>

    /**
     * Find zero or more Zincs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZincFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Zincs
     * const zincs = await prisma.zinc.findMany()
     * 
     * // Get first 10 Zincs
     * const zincs = await prisma.zinc.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zincWithIdOnly = await prisma.zinc.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ZincFindManyArgs>(
      args?: SelectSubset<T, ZincFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Zinc>>, PrismaPromise<Array<ZincGetPayload<T>>>>

    /**
     * Create a Zinc.
     * @param {ZincCreateArgs} args - Arguments to create a Zinc.
     * @example
     * // Create one Zinc
     * const Zinc = await prisma.zinc.create({
     *   data: {
     *     // ... data to create a Zinc
     *   }
     * })
     * 
    **/
    create<T extends ZincCreateArgs>(
      args: SelectSubset<T, ZincCreateArgs>
    ): CheckSelect<T, Prisma__ZincClient<Zinc>, Prisma__ZincClient<ZincGetPayload<T>>>

    /**
     * Create many Zincs.
     *     @param {ZincCreateManyArgs} args - Arguments to create many Zincs.
     *     @example
     *     // Create many Zincs
     *     const zinc = await prisma.zinc.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ZincCreateManyArgs>(
      args?: SelectSubset<T, ZincCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Zinc.
     * @param {ZincDeleteArgs} args - Arguments to delete one Zinc.
     * @example
     * // Delete one Zinc
     * const Zinc = await prisma.zinc.delete({
     *   where: {
     *     // ... filter to delete one Zinc
     *   }
     * })
     * 
    **/
    delete<T extends ZincDeleteArgs>(
      args: SelectSubset<T, ZincDeleteArgs>
    ): CheckSelect<T, Prisma__ZincClient<Zinc>, Prisma__ZincClient<ZincGetPayload<T>>>

    /**
     * Update one Zinc.
     * @param {ZincUpdateArgs} args - Arguments to update one Zinc.
     * @example
     * // Update one Zinc
     * const zinc = await prisma.zinc.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ZincUpdateArgs>(
      args: SelectSubset<T, ZincUpdateArgs>
    ): CheckSelect<T, Prisma__ZincClient<Zinc>, Prisma__ZincClient<ZincGetPayload<T>>>

    /**
     * Delete zero or more Zincs.
     * @param {ZincDeleteManyArgs} args - Arguments to filter Zincs to delete.
     * @example
     * // Delete a few Zincs
     * const { count } = await prisma.zinc.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ZincDeleteManyArgs>(
      args?: SelectSubset<T, ZincDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Zincs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZincUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Zincs
     * const zinc = await prisma.zinc.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ZincUpdateManyArgs>(
      args: SelectSubset<T, ZincUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Zinc.
     * @param {ZincUpsertArgs} args - Arguments to update or create a Zinc.
     * @example
     * // Update or create a Zinc
     * const zinc = await prisma.zinc.upsert({
     *   create: {
     *     // ... data to create a Zinc
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Zinc we want to update
     *   }
     * })
    **/
    upsert<T extends ZincUpsertArgs>(
      args: SelectSubset<T, ZincUpsertArgs>
    ): CheckSelect<T, Prisma__ZincClient<Zinc>, Prisma__ZincClient<ZincGetPayload<T>>>

    /**
     * Count the number of Zincs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZincCountArgs} args - Arguments to filter Zincs to count.
     * @example
     * // Count the number of Zincs
     * const count = await prisma.zinc.count({
     *   where: {
     *     // ... the filter for the Zincs we want to count
     *   }
     * })
    **/
    count<T extends ZincCountArgs>(
      args?: Subset<T, ZincCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZincCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Zinc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZincAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZincAggregateArgs>(args: Subset<T, ZincAggregateArgs>): PrismaPromise<GetZincAggregateType<T>>

    /**
     * Group by Zinc.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZincGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZincGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZincGroupByArgs['orderBy'] }
        : { orderBy?: ZincGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZincGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZincGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Zinc.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ZincClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    minerals<T extends MineralFindManyArgs = {}>(args?: Subset<T, MineralFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mineral>>, PrismaPromise<Array<MineralGetPayload<T>>>>;

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Zinc findUnique
   */
  export type ZincFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Zinc
     * 
    **/
    select?: ZincSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ZincInclude | null
    /**
     * Throw an Error if a Zinc can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Zinc to fetch.
     * 
    **/
    where: ZincWhereUniqueInput
  }


  /**
   * Zinc findFirst
   */
  export type ZincFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Zinc
     * 
    **/
    select?: ZincSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ZincInclude | null
    /**
     * Throw an Error if a Zinc can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Zinc to fetch.
     * 
    **/
    where?: ZincWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zincs to fetch.
     * 
    **/
    orderBy?: Enumerable<ZincOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Zincs.
     * 
    **/
    cursor?: ZincWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zincs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zincs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Zincs.
     * 
    **/
    distinct?: Enumerable<ZincScalarFieldEnum>
  }


  /**
   * Zinc findMany
   */
  export type ZincFindManyArgs = {
    /**
     * Select specific fields to fetch from the Zinc
     * 
    **/
    select?: ZincSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ZincInclude | null
    /**
     * Filter, which Zincs to fetch.
     * 
    **/
    where?: ZincWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Zincs to fetch.
     * 
    **/
    orderBy?: Enumerable<ZincOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Zincs.
     * 
    **/
    cursor?: ZincWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Zincs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Zincs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ZincScalarFieldEnum>
  }


  /**
   * Zinc create
   */
  export type ZincCreateArgs = {
    /**
     * Select specific fields to fetch from the Zinc
     * 
    **/
    select?: ZincSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ZincInclude | null
    /**
     * The data needed to create a Zinc.
     * 
    **/
    data: XOR<ZincCreateInput, ZincUncheckedCreateInput>
  }


  /**
   * Zinc createMany
   */
  export type ZincCreateManyArgs = {
    /**
     * The data used to create many Zincs.
     * 
    **/
    data: Enumerable<ZincCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Zinc update
   */
  export type ZincUpdateArgs = {
    /**
     * Select specific fields to fetch from the Zinc
     * 
    **/
    select?: ZincSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ZincInclude | null
    /**
     * The data needed to update a Zinc.
     * 
    **/
    data: XOR<ZincUpdateInput, ZincUncheckedUpdateInput>
    /**
     * Choose, which Zinc to update.
     * 
    **/
    where: ZincWhereUniqueInput
  }


  /**
   * Zinc updateMany
   */
  export type ZincUpdateManyArgs = {
    /**
     * The data used to update Zincs.
     * 
    **/
    data: XOR<ZincUpdateManyMutationInput, ZincUncheckedUpdateManyInput>
    /**
     * Filter which Zincs to update
     * 
    **/
    where?: ZincWhereInput
  }


  /**
   * Zinc upsert
   */
  export type ZincUpsertArgs = {
    /**
     * Select specific fields to fetch from the Zinc
     * 
    **/
    select?: ZincSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ZincInclude | null
    /**
     * The filter to search for the Zinc to update in case it exists.
     * 
    **/
    where: ZincWhereUniqueInput
    /**
     * In case the Zinc found by the `where` argument doesn't exist, create a new Zinc with this data.
     * 
    **/
    create: XOR<ZincCreateInput, ZincUncheckedCreateInput>
    /**
     * In case the Zinc was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ZincUpdateInput, ZincUncheckedUpdateInput>
  }


  /**
   * Zinc delete
   */
  export type ZincDeleteArgs = {
    /**
     * Select specific fields to fetch from the Zinc
     * 
    **/
    select?: ZincSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ZincInclude | null
    /**
     * Filter which Zinc to delete.
     * 
    **/
    where: ZincWhereUniqueInput
  }


  /**
   * Zinc deleteMany
   */
  export type ZincDeleteManyArgs = {
    /**
     * Filter which Zincs to delete
     * 
    **/
    where?: ZincWhereInput
  }


  /**
   * Zinc without action
   */
  export type ZincArgs = {
    /**
     * Select specific fields to fetch from the Zinc
     * 
    **/
    select?: ZincSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ZincInclude | null
  }



  /**
   * Model Iron
   */


  export type AggregateIron = {
    _count: IronCountAggregateOutputType | null
    _avg: IronAvgAggregateOutputType | null
    _sum: IronSumAggregateOutputType | null
    _min: IronMinAggregateOutputType | null
    _max: IronMaxAggregateOutputType | null
  }

  export type IronAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type IronSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type IronMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type IronMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type IronCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type IronAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type IronSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type IronMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type IronMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type IronCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type IronAggregateArgs = {
    /**
     * Filter which Iron to aggregate.
     * 
    **/
    where?: IronWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Irons to fetch.
     * 
    **/
    orderBy?: Enumerable<IronOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IronWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Irons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Irons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Irons
    **/
    _count?: true | IronCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IronAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IronSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IronMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IronMaxAggregateInputType
  }

  export type GetIronAggregateType<T extends IronAggregateArgs> = {
        [P in keyof T & keyof AggregateIron]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIron[P]>
      : GetScalarType<T[P], AggregateIron[P]>
  }




  export type IronGroupByArgs = {
    where?: IronWhereInput
    orderBy?: Enumerable<IronOrderByWithAggregationInput>
    by: Array<IronScalarFieldEnum>
    having?: IronScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IronCountAggregateInputType | true
    _avg?: IronAvgAggregateInputType
    _sum?: IronSumAggregateInputType
    _min?: IronMinAggregateInputType
    _max?: IronMaxAggregateInputType
  }


  export type IronGroupByOutputType = {
    id: number
    measurementId: number
    _count: IronCountAggregateOutputType | null
    _avg: IronAvgAggregateOutputType | null
    _sum: IronSumAggregateOutputType | null
    _min: IronMinAggregateOutputType | null
    _max: IronMaxAggregateOutputType | null
  }

  type GetIronGroupByPayload<T extends IronGroupByArgs> = PrismaPromise<
    Array<
      PickArray<IronGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IronGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IronGroupByOutputType[P]>
            : GetScalarType<T[P], IronGroupByOutputType[P]>
        }
      >
    >


  export type IronSelect = {
    id?: boolean
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    measurementId?: boolean
    _count?: boolean | IronCountOutputTypeArgs
  }

  export type IronInclude = {
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    _count?: boolean | IronCountOutputTypeArgs
  }

  export type IronGetPayload<
    S extends boolean | null | undefined | IronArgs,
    U = keyof S
      > = S extends true
        ? Iron
    : S extends undefined
    ? never
    : S extends IronArgs | IronFindManyArgs
    ?'include' extends U
    ? Iron  & {
    [P in TrueKeys<S['include']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['include'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends '_count' ? IronCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['select'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends '_count' ? IronCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Iron ? Iron[P] : never
  } 
    : Iron
  : Iron


  type IronCountArgs = Merge<
    Omit<IronFindManyArgs, 'select' | 'include'> & {
      select?: IronCountAggregateInputType | true
    }
  >

  export interface IronDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Iron that matches the filter.
     * @param {IronFindUniqueArgs} args - Arguments to find a Iron
     * @example
     * // Get one Iron
     * const iron = await prisma.iron.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IronFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IronFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Iron'> extends True ? CheckSelect<T, Prisma__IronClient<Iron>, Prisma__IronClient<IronGetPayload<T>>> : CheckSelect<T, Prisma__IronClient<Iron | null >, Prisma__IronClient<IronGetPayload<T> | null >>

    /**
     * Find the first Iron that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IronFindFirstArgs} args - Arguments to find a Iron
     * @example
     * // Get one Iron
     * const iron = await prisma.iron.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IronFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IronFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Iron'> extends True ? CheckSelect<T, Prisma__IronClient<Iron>, Prisma__IronClient<IronGetPayload<T>>> : CheckSelect<T, Prisma__IronClient<Iron | null >, Prisma__IronClient<IronGetPayload<T> | null >>

    /**
     * Find zero or more Irons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IronFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Irons
     * const irons = await prisma.iron.findMany()
     * 
     * // Get first 10 Irons
     * const irons = await prisma.iron.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const ironWithIdOnly = await prisma.iron.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IronFindManyArgs>(
      args?: SelectSubset<T, IronFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Iron>>, PrismaPromise<Array<IronGetPayload<T>>>>

    /**
     * Create a Iron.
     * @param {IronCreateArgs} args - Arguments to create a Iron.
     * @example
     * // Create one Iron
     * const Iron = await prisma.iron.create({
     *   data: {
     *     // ... data to create a Iron
     *   }
     * })
     * 
    **/
    create<T extends IronCreateArgs>(
      args: SelectSubset<T, IronCreateArgs>
    ): CheckSelect<T, Prisma__IronClient<Iron>, Prisma__IronClient<IronGetPayload<T>>>

    /**
     * Create many Irons.
     *     @param {IronCreateManyArgs} args - Arguments to create many Irons.
     *     @example
     *     // Create many Irons
     *     const iron = await prisma.iron.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IronCreateManyArgs>(
      args?: SelectSubset<T, IronCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Iron.
     * @param {IronDeleteArgs} args - Arguments to delete one Iron.
     * @example
     * // Delete one Iron
     * const Iron = await prisma.iron.delete({
     *   where: {
     *     // ... filter to delete one Iron
     *   }
     * })
     * 
    **/
    delete<T extends IronDeleteArgs>(
      args: SelectSubset<T, IronDeleteArgs>
    ): CheckSelect<T, Prisma__IronClient<Iron>, Prisma__IronClient<IronGetPayload<T>>>

    /**
     * Update one Iron.
     * @param {IronUpdateArgs} args - Arguments to update one Iron.
     * @example
     * // Update one Iron
     * const iron = await prisma.iron.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IronUpdateArgs>(
      args: SelectSubset<T, IronUpdateArgs>
    ): CheckSelect<T, Prisma__IronClient<Iron>, Prisma__IronClient<IronGetPayload<T>>>

    /**
     * Delete zero or more Irons.
     * @param {IronDeleteManyArgs} args - Arguments to filter Irons to delete.
     * @example
     * // Delete a few Irons
     * const { count } = await prisma.iron.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IronDeleteManyArgs>(
      args?: SelectSubset<T, IronDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Irons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IronUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Irons
     * const iron = await prisma.iron.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IronUpdateManyArgs>(
      args: SelectSubset<T, IronUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Iron.
     * @param {IronUpsertArgs} args - Arguments to update or create a Iron.
     * @example
     * // Update or create a Iron
     * const iron = await prisma.iron.upsert({
     *   create: {
     *     // ... data to create a Iron
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Iron we want to update
     *   }
     * })
    **/
    upsert<T extends IronUpsertArgs>(
      args: SelectSubset<T, IronUpsertArgs>
    ): CheckSelect<T, Prisma__IronClient<Iron>, Prisma__IronClient<IronGetPayload<T>>>

    /**
     * Count the number of Irons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IronCountArgs} args - Arguments to filter Irons to count.
     * @example
     * // Count the number of Irons
     * const count = await prisma.iron.count({
     *   where: {
     *     // ... the filter for the Irons we want to count
     *   }
     * })
    **/
    count<T extends IronCountArgs>(
      args?: Subset<T, IronCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IronCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Iron.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IronAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IronAggregateArgs>(args: Subset<T, IronAggregateArgs>): PrismaPromise<GetIronAggregateType<T>>

    /**
     * Group by Iron.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IronGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IronGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IronGroupByArgs['orderBy'] }
        : { orderBy?: IronGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IronGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIronGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Iron.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IronClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    minerals<T extends MineralFindManyArgs = {}>(args?: Subset<T, MineralFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mineral>>, PrismaPromise<Array<MineralGetPayload<T>>>>;

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Iron findUnique
   */
  export type IronFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Iron
     * 
    **/
    select?: IronSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IronInclude | null
    /**
     * Throw an Error if a Iron can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Iron to fetch.
     * 
    **/
    where: IronWhereUniqueInput
  }


  /**
   * Iron findFirst
   */
  export type IronFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Iron
     * 
    **/
    select?: IronSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IronInclude | null
    /**
     * Throw an Error if a Iron can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Iron to fetch.
     * 
    **/
    where?: IronWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Irons to fetch.
     * 
    **/
    orderBy?: Enumerable<IronOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Irons.
     * 
    **/
    cursor?: IronWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Irons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Irons.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Irons.
     * 
    **/
    distinct?: Enumerable<IronScalarFieldEnum>
  }


  /**
   * Iron findMany
   */
  export type IronFindManyArgs = {
    /**
     * Select specific fields to fetch from the Iron
     * 
    **/
    select?: IronSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IronInclude | null
    /**
     * Filter, which Irons to fetch.
     * 
    **/
    where?: IronWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Irons to fetch.
     * 
    **/
    orderBy?: Enumerable<IronOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Irons.
     * 
    **/
    cursor?: IronWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Irons from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Irons.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IronScalarFieldEnum>
  }


  /**
   * Iron create
   */
  export type IronCreateArgs = {
    /**
     * Select specific fields to fetch from the Iron
     * 
    **/
    select?: IronSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IronInclude | null
    /**
     * The data needed to create a Iron.
     * 
    **/
    data: XOR<IronCreateInput, IronUncheckedCreateInput>
  }


  /**
   * Iron createMany
   */
  export type IronCreateManyArgs = {
    /**
     * The data used to create many Irons.
     * 
    **/
    data: Enumerable<IronCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Iron update
   */
  export type IronUpdateArgs = {
    /**
     * Select specific fields to fetch from the Iron
     * 
    **/
    select?: IronSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IronInclude | null
    /**
     * The data needed to update a Iron.
     * 
    **/
    data: XOR<IronUpdateInput, IronUncheckedUpdateInput>
    /**
     * Choose, which Iron to update.
     * 
    **/
    where: IronWhereUniqueInput
  }


  /**
   * Iron updateMany
   */
  export type IronUpdateManyArgs = {
    /**
     * The data used to update Irons.
     * 
    **/
    data: XOR<IronUpdateManyMutationInput, IronUncheckedUpdateManyInput>
    /**
     * Filter which Irons to update
     * 
    **/
    where?: IronWhereInput
  }


  /**
   * Iron upsert
   */
  export type IronUpsertArgs = {
    /**
     * Select specific fields to fetch from the Iron
     * 
    **/
    select?: IronSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IronInclude | null
    /**
     * The filter to search for the Iron to update in case it exists.
     * 
    **/
    where: IronWhereUniqueInput
    /**
     * In case the Iron found by the `where` argument doesn't exist, create a new Iron with this data.
     * 
    **/
    create: XOR<IronCreateInput, IronUncheckedCreateInput>
    /**
     * In case the Iron was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IronUpdateInput, IronUncheckedUpdateInput>
  }


  /**
   * Iron delete
   */
  export type IronDeleteArgs = {
    /**
     * Select specific fields to fetch from the Iron
     * 
    **/
    select?: IronSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IronInclude | null
    /**
     * Filter which Iron to delete.
     * 
    **/
    where: IronWhereUniqueInput
  }


  /**
   * Iron deleteMany
   */
  export type IronDeleteManyArgs = {
    /**
     * Filter which Irons to delete
     * 
    **/
    where?: IronWhereInput
  }


  /**
   * Iron without action
   */
  export type IronArgs = {
    /**
     * Select specific fields to fetch from the Iron
     * 
    **/
    select?: IronSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IronInclude | null
  }



  /**
   * Model Magnesium
   */


  export type AggregateMagnesium = {
    _count: MagnesiumCountAggregateOutputType | null
    _avg: MagnesiumAvgAggregateOutputType | null
    _sum: MagnesiumSumAggregateOutputType | null
    _min: MagnesiumMinAggregateOutputType | null
    _max: MagnesiumMaxAggregateOutputType | null
  }

  export type MagnesiumAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type MagnesiumSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type MagnesiumMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type MagnesiumMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type MagnesiumCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type MagnesiumAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type MagnesiumSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type MagnesiumMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type MagnesiumMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type MagnesiumCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type MagnesiumAggregateArgs = {
    /**
     * Filter which Magnesium to aggregate.
     * 
    **/
    where?: MagnesiumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Magnesiums to fetch.
     * 
    **/
    orderBy?: Enumerable<MagnesiumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MagnesiumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Magnesiums from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Magnesiums.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Magnesiums
    **/
    _count?: true | MagnesiumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MagnesiumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MagnesiumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MagnesiumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MagnesiumMaxAggregateInputType
  }

  export type GetMagnesiumAggregateType<T extends MagnesiumAggregateArgs> = {
        [P in keyof T & keyof AggregateMagnesium]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMagnesium[P]>
      : GetScalarType<T[P], AggregateMagnesium[P]>
  }




  export type MagnesiumGroupByArgs = {
    where?: MagnesiumWhereInput
    orderBy?: Enumerable<MagnesiumOrderByWithAggregationInput>
    by: Array<MagnesiumScalarFieldEnum>
    having?: MagnesiumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MagnesiumCountAggregateInputType | true
    _avg?: MagnesiumAvgAggregateInputType
    _sum?: MagnesiumSumAggregateInputType
    _min?: MagnesiumMinAggregateInputType
    _max?: MagnesiumMaxAggregateInputType
  }


  export type MagnesiumGroupByOutputType = {
    id: number
    measurementId: number
    _count: MagnesiumCountAggregateOutputType | null
    _avg: MagnesiumAvgAggregateOutputType | null
    _sum: MagnesiumSumAggregateOutputType | null
    _min: MagnesiumMinAggregateOutputType | null
    _max: MagnesiumMaxAggregateOutputType | null
  }

  type GetMagnesiumGroupByPayload<T extends MagnesiumGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MagnesiumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MagnesiumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MagnesiumGroupByOutputType[P]>
            : GetScalarType<T[P], MagnesiumGroupByOutputType[P]>
        }
      >
    >


  export type MagnesiumSelect = {
    id?: boolean
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    measurementId?: boolean
    _count?: boolean | MagnesiumCountOutputTypeArgs
  }

  export type MagnesiumInclude = {
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    _count?: boolean | MagnesiumCountOutputTypeArgs
  }

  export type MagnesiumGetPayload<
    S extends boolean | null | undefined | MagnesiumArgs,
    U = keyof S
      > = S extends true
        ? Magnesium
    : S extends undefined
    ? never
    : S extends MagnesiumArgs | MagnesiumFindManyArgs
    ?'include' extends U
    ? Magnesium  & {
    [P in TrueKeys<S['include']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['include'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends '_count' ? MagnesiumCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['select'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends '_count' ? MagnesiumCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Magnesium ? Magnesium[P] : never
  } 
    : Magnesium
  : Magnesium


  type MagnesiumCountArgs = Merge<
    Omit<MagnesiumFindManyArgs, 'select' | 'include'> & {
      select?: MagnesiumCountAggregateInputType | true
    }
  >

  export interface MagnesiumDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Magnesium that matches the filter.
     * @param {MagnesiumFindUniqueArgs} args - Arguments to find a Magnesium
     * @example
     * // Get one Magnesium
     * const magnesium = await prisma.magnesium.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MagnesiumFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MagnesiumFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Magnesium'> extends True ? CheckSelect<T, Prisma__MagnesiumClient<Magnesium>, Prisma__MagnesiumClient<MagnesiumGetPayload<T>>> : CheckSelect<T, Prisma__MagnesiumClient<Magnesium | null >, Prisma__MagnesiumClient<MagnesiumGetPayload<T> | null >>

    /**
     * Find the first Magnesium that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagnesiumFindFirstArgs} args - Arguments to find a Magnesium
     * @example
     * // Get one Magnesium
     * const magnesium = await prisma.magnesium.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MagnesiumFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MagnesiumFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Magnesium'> extends True ? CheckSelect<T, Prisma__MagnesiumClient<Magnesium>, Prisma__MagnesiumClient<MagnesiumGetPayload<T>>> : CheckSelect<T, Prisma__MagnesiumClient<Magnesium | null >, Prisma__MagnesiumClient<MagnesiumGetPayload<T> | null >>

    /**
     * Find zero or more Magnesiums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagnesiumFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Magnesiums
     * const magnesiums = await prisma.magnesium.findMany()
     * 
     * // Get first 10 Magnesiums
     * const magnesiums = await prisma.magnesium.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const magnesiumWithIdOnly = await prisma.magnesium.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MagnesiumFindManyArgs>(
      args?: SelectSubset<T, MagnesiumFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Magnesium>>, PrismaPromise<Array<MagnesiumGetPayload<T>>>>

    /**
     * Create a Magnesium.
     * @param {MagnesiumCreateArgs} args - Arguments to create a Magnesium.
     * @example
     * // Create one Magnesium
     * const Magnesium = await prisma.magnesium.create({
     *   data: {
     *     // ... data to create a Magnesium
     *   }
     * })
     * 
    **/
    create<T extends MagnesiumCreateArgs>(
      args: SelectSubset<T, MagnesiumCreateArgs>
    ): CheckSelect<T, Prisma__MagnesiumClient<Magnesium>, Prisma__MagnesiumClient<MagnesiumGetPayload<T>>>

    /**
     * Create many Magnesiums.
     *     @param {MagnesiumCreateManyArgs} args - Arguments to create many Magnesiums.
     *     @example
     *     // Create many Magnesiums
     *     const magnesium = await prisma.magnesium.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MagnesiumCreateManyArgs>(
      args?: SelectSubset<T, MagnesiumCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Magnesium.
     * @param {MagnesiumDeleteArgs} args - Arguments to delete one Magnesium.
     * @example
     * // Delete one Magnesium
     * const Magnesium = await prisma.magnesium.delete({
     *   where: {
     *     // ... filter to delete one Magnesium
     *   }
     * })
     * 
    **/
    delete<T extends MagnesiumDeleteArgs>(
      args: SelectSubset<T, MagnesiumDeleteArgs>
    ): CheckSelect<T, Prisma__MagnesiumClient<Magnesium>, Prisma__MagnesiumClient<MagnesiumGetPayload<T>>>

    /**
     * Update one Magnesium.
     * @param {MagnesiumUpdateArgs} args - Arguments to update one Magnesium.
     * @example
     * // Update one Magnesium
     * const magnesium = await prisma.magnesium.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MagnesiumUpdateArgs>(
      args: SelectSubset<T, MagnesiumUpdateArgs>
    ): CheckSelect<T, Prisma__MagnesiumClient<Magnesium>, Prisma__MagnesiumClient<MagnesiumGetPayload<T>>>

    /**
     * Delete zero or more Magnesiums.
     * @param {MagnesiumDeleteManyArgs} args - Arguments to filter Magnesiums to delete.
     * @example
     * // Delete a few Magnesiums
     * const { count } = await prisma.magnesium.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MagnesiumDeleteManyArgs>(
      args?: SelectSubset<T, MagnesiumDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Magnesiums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagnesiumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Magnesiums
     * const magnesium = await prisma.magnesium.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MagnesiumUpdateManyArgs>(
      args: SelectSubset<T, MagnesiumUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Magnesium.
     * @param {MagnesiumUpsertArgs} args - Arguments to update or create a Magnesium.
     * @example
     * // Update or create a Magnesium
     * const magnesium = await prisma.magnesium.upsert({
     *   create: {
     *     // ... data to create a Magnesium
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Magnesium we want to update
     *   }
     * })
    **/
    upsert<T extends MagnesiumUpsertArgs>(
      args: SelectSubset<T, MagnesiumUpsertArgs>
    ): CheckSelect<T, Prisma__MagnesiumClient<Magnesium>, Prisma__MagnesiumClient<MagnesiumGetPayload<T>>>

    /**
     * Count the number of Magnesiums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagnesiumCountArgs} args - Arguments to filter Magnesiums to count.
     * @example
     * // Count the number of Magnesiums
     * const count = await prisma.magnesium.count({
     *   where: {
     *     // ... the filter for the Magnesiums we want to count
     *   }
     * })
    **/
    count<T extends MagnesiumCountArgs>(
      args?: Subset<T, MagnesiumCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MagnesiumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Magnesium.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagnesiumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MagnesiumAggregateArgs>(args: Subset<T, MagnesiumAggregateArgs>): PrismaPromise<GetMagnesiumAggregateType<T>>

    /**
     * Group by Magnesium.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MagnesiumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MagnesiumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MagnesiumGroupByArgs['orderBy'] }
        : { orderBy?: MagnesiumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MagnesiumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMagnesiumGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Magnesium.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MagnesiumClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    minerals<T extends MineralFindManyArgs = {}>(args?: Subset<T, MineralFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mineral>>, PrismaPromise<Array<MineralGetPayload<T>>>>;

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Magnesium findUnique
   */
  export type MagnesiumFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Magnesium
     * 
    **/
    select?: MagnesiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MagnesiumInclude | null
    /**
     * Throw an Error if a Magnesium can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Magnesium to fetch.
     * 
    **/
    where: MagnesiumWhereUniqueInput
  }


  /**
   * Magnesium findFirst
   */
  export type MagnesiumFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Magnesium
     * 
    **/
    select?: MagnesiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MagnesiumInclude | null
    /**
     * Throw an Error if a Magnesium can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Magnesium to fetch.
     * 
    **/
    where?: MagnesiumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Magnesiums to fetch.
     * 
    **/
    orderBy?: Enumerable<MagnesiumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Magnesiums.
     * 
    **/
    cursor?: MagnesiumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Magnesiums from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Magnesiums.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Magnesiums.
     * 
    **/
    distinct?: Enumerable<MagnesiumScalarFieldEnum>
  }


  /**
   * Magnesium findMany
   */
  export type MagnesiumFindManyArgs = {
    /**
     * Select specific fields to fetch from the Magnesium
     * 
    **/
    select?: MagnesiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MagnesiumInclude | null
    /**
     * Filter, which Magnesiums to fetch.
     * 
    **/
    where?: MagnesiumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Magnesiums to fetch.
     * 
    **/
    orderBy?: Enumerable<MagnesiumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Magnesiums.
     * 
    **/
    cursor?: MagnesiumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Magnesiums from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Magnesiums.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MagnesiumScalarFieldEnum>
  }


  /**
   * Magnesium create
   */
  export type MagnesiumCreateArgs = {
    /**
     * Select specific fields to fetch from the Magnesium
     * 
    **/
    select?: MagnesiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MagnesiumInclude | null
    /**
     * The data needed to create a Magnesium.
     * 
    **/
    data: XOR<MagnesiumCreateInput, MagnesiumUncheckedCreateInput>
  }


  /**
   * Magnesium createMany
   */
  export type MagnesiumCreateManyArgs = {
    /**
     * The data used to create many Magnesiums.
     * 
    **/
    data: Enumerable<MagnesiumCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Magnesium update
   */
  export type MagnesiumUpdateArgs = {
    /**
     * Select specific fields to fetch from the Magnesium
     * 
    **/
    select?: MagnesiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MagnesiumInclude | null
    /**
     * The data needed to update a Magnesium.
     * 
    **/
    data: XOR<MagnesiumUpdateInput, MagnesiumUncheckedUpdateInput>
    /**
     * Choose, which Magnesium to update.
     * 
    **/
    where: MagnesiumWhereUniqueInput
  }


  /**
   * Magnesium updateMany
   */
  export type MagnesiumUpdateManyArgs = {
    /**
     * The data used to update Magnesiums.
     * 
    **/
    data: XOR<MagnesiumUpdateManyMutationInput, MagnesiumUncheckedUpdateManyInput>
    /**
     * Filter which Magnesiums to update
     * 
    **/
    where?: MagnesiumWhereInput
  }


  /**
   * Magnesium upsert
   */
  export type MagnesiumUpsertArgs = {
    /**
     * Select specific fields to fetch from the Magnesium
     * 
    **/
    select?: MagnesiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MagnesiumInclude | null
    /**
     * The filter to search for the Magnesium to update in case it exists.
     * 
    **/
    where: MagnesiumWhereUniqueInput
    /**
     * In case the Magnesium found by the `where` argument doesn't exist, create a new Magnesium with this data.
     * 
    **/
    create: XOR<MagnesiumCreateInput, MagnesiumUncheckedCreateInput>
    /**
     * In case the Magnesium was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MagnesiumUpdateInput, MagnesiumUncheckedUpdateInput>
  }


  /**
   * Magnesium delete
   */
  export type MagnesiumDeleteArgs = {
    /**
     * Select specific fields to fetch from the Magnesium
     * 
    **/
    select?: MagnesiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MagnesiumInclude | null
    /**
     * Filter which Magnesium to delete.
     * 
    **/
    where: MagnesiumWhereUniqueInput
  }


  /**
   * Magnesium deleteMany
   */
  export type MagnesiumDeleteManyArgs = {
    /**
     * Filter which Magnesiums to delete
     * 
    **/
    where?: MagnesiumWhereInput
  }


  /**
   * Magnesium without action
   */
  export type MagnesiumArgs = {
    /**
     * Select specific fields to fetch from the Magnesium
     * 
    **/
    select?: MagnesiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MagnesiumInclude | null
  }



  /**
   * Model Chloride
   */


  export type AggregateChloride = {
    _count: ChlorideCountAggregateOutputType | null
    _avg: ChlorideAvgAggregateOutputType | null
    _sum: ChlorideSumAggregateOutputType | null
    _min: ChlorideMinAggregateOutputType | null
    _max: ChlorideMaxAggregateOutputType | null
  }

  export type ChlorideAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type ChlorideSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type ChlorideMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type ChlorideMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type ChlorideCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type ChlorideAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type ChlorideSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type ChlorideMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type ChlorideMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type ChlorideCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type ChlorideAggregateArgs = {
    /**
     * Filter which Chloride to aggregate.
     * 
    **/
    where?: ChlorideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chlorides to fetch.
     * 
    **/
    orderBy?: Enumerable<ChlorideOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ChlorideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chlorides from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chlorides.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Chlorides
    **/
    _count?: true | ChlorideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChlorideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChlorideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChlorideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChlorideMaxAggregateInputType
  }

  export type GetChlorideAggregateType<T extends ChlorideAggregateArgs> = {
        [P in keyof T & keyof AggregateChloride]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChloride[P]>
      : GetScalarType<T[P], AggregateChloride[P]>
  }




  export type ChlorideGroupByArgs = {
    where?: ChlorideWhereInput
    orderBy?: Enumerable<ChlorideOrderByWithAggregationInput>
    by: Array<ChlorideScalarFieldEnum>
    having?: ChlorideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChlorideCountAggregateInputType | true
    _avg?: ChlorideAvgAggregateInputType
    _sum?: ChlorideSumAggregateInputType
    _min?: ChlorideMinAggregateInputType
    _max?: ChlorideMaxAggregateInputType
  }


  export type ChlorideGroupByOutputType = {
    id: number
    measurementId: number
    _count: ChlorideCountAggregateOutputType | null
    _avg: ChlorideAvgAggregateOutputType | null
    _sum: ChlorideSumAggregateOutputType | null
    _min: ChlorideMinAggregateOutputType | null
    _max: ChlorideMaxAggregateOutputType | null
  }

  type GetChlorideGroupByPayload<T extends ChlorideGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ChlorideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChlorideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChlorideGroupByOutputType[P]>
            : GetScalarType<T[P], ChlorideGroupByOutputType[P]>
        }
      >
    >


  export type ChlorideSelect = {
    id?: boolean
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    measurementId?: boolean
    _count?: boolean | ChlorideCountOutputTypeArgs
  }

  export type ChlorideInclude = {
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    _count?: boolean | ChlorideCountOutputTypeArgs
  }

  export type ChlorideGetPayload<
    S extends boolean | null | undefined | ChlorideArgs,
    U = keyof S
      > = S extends true
        ? Chloride
    : S extends undefined
    ? never
    : S extends ChlorideArgs | ChlorideFindManyArgs
    ?'include' extends U
    ? Chloride  & {
    [P in TrueKeys<S['include']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['include'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends '_count' ? ChlorideCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['select'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends '_count' ? ChlorideCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Chloride ? Chloride[P] : never
  } 
    : Chloride
  : Chloride


  type ChlorideCountArgs = Merge<
    Omit<ChlorideFindManyArgs, 'select' | 'include'> & {
      select?: ChlorideCountAggregateInputType | true
    }
  >

  export interface ChlorideDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Chloride that matches the filter.
     * @param {ChlorideFindUniqueArgs} args - Arguments to find a Chloride
     * @example
     * // Get one Chloride
     * const chloride = await prisma.chloride.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ChlorideFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ChlorideFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Chloride'> extends True ? CheckSelect<T, Prisma__ChlorideClient<Chloride>, Prisma__ChlorideClient<ChlorideGetPayload<T>>> : CheckSelect<T, Prisma__ChlorideClient<Chloride | null >, Prisma__ChlorideClient<ChlorideGetPayload<T> | null >>

    /**
     * Find the first Chloride that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChlorideFindFirstArgs} args - Arguments to find a Chloride
     * @example
     * // Get one Chloride
     * const chloride = await prisma.chloride.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ChlorideFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ChlorideFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Chloride'> extends True ? CheckSelect<T, Prisma__ChlorideClient<Chloride>, Prisma__ChlorideClient<ChlorideGetPayload<T>>> : CheckSelect<T, Prisma__ChlorideClient<Chloride | null >, Prisma__ChlorideClient<ChlorideGetPayload<T> | null >>

    /**
     * Find zero or more Chlorides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChlorideFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Chlorides
     * const chlorides = await prisma.chloride.findMany()
     * 
     * // Get first 10 Chlorides
     * const chlorides = await prisma.chloride.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const chlorideWithIdOnly = await prisma.chloride.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ChlorideFindManyArgs>(
      args?: SelectSubset<T, ChlorideFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Chloride>>, PrismaPromise<Array<ChlorideGetPayload<T>>>>

    /**
     * Create a Chloride.
     * @param {ChlorideCreateArgs} args - Arguments to create a Chloride.
     * @example
     * // Create one Chloride
     * const Chloride = await prisma.chloride.create({
     *   data: {
     *     // ... data to create a Chloride
     *   }
     * })
     * 
    **/
    create<T extends ChlorideCreateArgs>(
      args: SelectSubset<T, ChlorideCreateArgs>
    ): CheckSelect<T, Prisma__ChlorideClient<Chloride>, Prisma__ChlorideClient<ChlorideGetPayload<T>>>

    /**
     * Create many Chlorides.
     *     @param {ChlorideCreateManyArgs} args - Arguments to create many Chlorides.
     *     @example
     *     // Create many Chlorides
     *     const chloride = await prisma.chloride.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ChlorideCreateManyArgs>(
      args?: SelectSubset<T, ChlorideCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Chloride.
     * @param {ChlorideDeleteArgs} args - Arguments to delete one Chloride.
     * @example
     * // Delete one Chloride
     * const Chloride = await prisma.chloride.delete({
     *   where: {
     *     // ... filter to delete one Chloride
     *   }
     * })
     * 
    **/
    delete<T extends ChlorideDeleteArgs>(
      args: SelectSubset<T, ChlorideDeleteArgs>
    ): CheckSelect<T, Prisma__ChlorideClient<Chloride>, Prisma__ChlorideClient<ChlorideGetPayload<T>>>

    /**
     * Update one Chloride.
     * @param {ChlorideUpdateArgs} args - Arguments to update one Chloride.
     * @example
     * // Update one Chloride
     * const chloride = await prisma.chloride.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ChlorideUpdateArgs>(
      args: SelectSubset<T, ChlorideUpdateArgs>
    ): CheckSelect<T, Prisma__ChlorideClient<Chloride>, Prisma__ChlorideClient<ChlorideGetPayload<T>>>

    /**
     * Delete zero or more Chlorides.
     * @param {ChlorideDeleteManyArgs} args - Arguments to filter Chlorides to delete.
     * @example
     * // Delete a few Chlorides
     * const { count } = await prisma.chloride.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ChlorideDeleteManyArgs>(
      args?: SelectSubset<T, ChlorideDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Chlorides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChlorideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Chlorides
     * const chloride = await prisma.chloride.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ChlorideUpdateManyArgs>(
      args: SelectSubset<T, ChlorideUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Chloride.
     * @param {ChlorideUpsertArgs} args - Arguments to update or create a Chloride.
     * @example
     * // Update or create a Chloride
     * const chloride = await prisma.chloride.upsert({
     *   create: {
     *     // ... data to create a Chloride
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Chloride we want to update
     *   }
     * })
    **/
    upsert<T extends ChlorideUpsertArgs>(
      args: SelectSubset<T, ChlorideUpsertArgs>
    ): CheckSelect<T, Prisma__ChlorideClient<Chloride>, Prisma__ChlorideClient<ChlorideGetPayload<T>>>

    /**
     * Count the number of Chlorides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChlorideCountArgs} args - Arguments to filter Chlorides to count.
     * @example
     * // Count the number of Chlorides
     * const count = await prisma.chloride.count({
     *   where: {
     *     // ... the filter for the Chlorides we want to count
     *   }
     * })
    **/
    count<T extends ChlorideCountArgs>(
      args?: Subset<T, ChlorideCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChlorideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Chloride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChlorideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChlorideAggregateArgs>(args: Subset<T, ChlorideAggregateArgs>): PrismaPromise<GetChlorideAggregateType<T>>

    /**
     * Group by Chloride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChlorideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChlorideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChlorideGroupByArgs['orderBy'] }
        : { orderBy?: ChlorideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChlorideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChlorideGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Chloride.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ChlorideClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    minerals<T extends MineralFindManyArgs = {}>(args?: Subset<T, MineralFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mineral>>, PrismaPromise<Array<MineralGetPayload<T>>>>;

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Chloride findUnique
   */
  export type ChlorideFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Chloride
     * 
    **/
    select?: ChlorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChlorideInclude | null
    /**
     * Throw an Error if a Chloride can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Chloride to fetch.
     * 
    **/
    where: ChlorideWhereUniqueInput
  }


  /**
   * Chloride findFirst
   */
  export type ChlorideFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Chloride
     * 
    **/
    select?: ChlorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChlorideInclude | null
    /**
     * Throw an Error if a Chloride can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Chloride to fetch.
     * 
    **/
    where?: ChlorideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chlorides to fetch.
     * 
    **/
    orderBy?: Enumerable<ChlorideOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Chlorides.
     * 
    **/
    cursor?: ChlorideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chlorides from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chlorides.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Chlorides.
     * 
    **/
    distinct?: Enumerable<ChlorideScalarFieldEnum>
  }


  /**
   * Chloride findMany
   */
  export type ChlorideFindManyArgs = {
    /**
     * Select specific fields to fetch from the Chloride
     * 
    **/
    select?: ChlorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChlorideInclude | null
    /**
     * Filter, which Chlorides to fetch.
     * 
    **/
    where?: ChlorideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Chlorides to fetch.
     * 
    **/
    orderBy?: Enumerable<ChlorideOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Chlorides.
     * 
    **/
    cursor?: ChlorideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Chlorides from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Chlorides.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ChlorideScalarFieldEnum>
  }


  /**
   * Chloride create
   */
  export type ChlorideCreateArgs = {
    /**
     * Select specific fields to fetch from the Chloride
     * 
    **/
    select?: ChlorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChlorideInclude | null
    /**
     * The data needed to create a Chloride.
     * 
    **/
    data: XOR<ChlorideCreateInput, ChlorideUncheckedCreateInput>
  }


  /**
   * Chloride createMany
   */
  export type ChlorideCreateManyArgs = {
    /**
     * The data used to create many Chlorides.
     * 
    **/
    data: Enumerable<ChlorideCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Chloride update
   */
  export type ChlorideUpdateArgs = {
    /**
     * Select specific fields to fetch from the Chloride
     * 
    **/
    select?: ChlorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChlorideInclude | null
    /**
     * The data needed to update a Chloride.
     * 
    **/
    data: XOR<ChlorideUpdateInput, ChlorideUncheckedUpdateInput>
    /**
     * Choose, which Chloride to update.
     * 
    **/
    where: ChlorideWhereUniqueInput
  }


  /**
   * Chloride updateMany
   */
  export type ChlorideUpdateManyArgs = {
    /**
     * The data used to update Chlorides.
     * 
    **/
    data: XOR<ChlorideUpdateManyMutationInput, ChlorideUncheckedUpdateManyInput>
    /**
     * Filter which Chlorides to update
     * 
    **/
    where?: ChlorideWhereInput
  }


  /**
   * Chloride upsert
   */
  export type ChlorideUpsertArgs = {
    /**
     * Select specific fields to fetch from the Chloride
     * 
    **/
    select?: ChlorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChlorideInclude | null
    /**
     * The filter to search for the Chloride to update in case it exists.
     * 
    **/
    where: ChlorideWhereUniqueInput
    /**
     * In case the Chloride found by the `where` argument doesn't exist, create a new Chloride with this data.
     * 
    **/
    create: XOR<ChlorideCreateInput, ChlorideUncheckedCreateInput>
    /**
     * In case the Chloride was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ChlorideUpdateInput, ChlorideUncheckedUpdateInput>
  }


  /**
   * Chloride delete
   */
  export type ChlorideDeleteArgs = {
    /**
     * Select specific fields to fetch from the Chloride
     * 
    **/
    select?: ChlorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChlorideInclude | null
    /**
     * Filter which Chloride to delete.
     * 
    **/
    where: ChlorideWhereUniqueInput
  }


  /**
   * Chloride deleteMany
   */
  export type ChlorideDeleteManyArgs = {
    /**
     * Filter which Chlorides to delete
     * 
    **/
    where?: ChlorideWhereInput
  }


  /**
   * Chloride without action
   */
  export type ChlorideArgs = {
    /**
     * Select specific fields to fetch from the Chloride
     * 
    **/
    select?: ChlorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ChlorideInclude | null
  }



  /**
   * Model Manganese
   */


  export type AggregateManganese = {
    _count: ManganeseCountAggregateOutputType | null
    _avg: ManganeseAvgAggregateOutputType | null
    _sum: ManganeseSumAggregateOutputType | null
    _min: ManganeseMinAggregateOutputType | null
    _max: ManganeseMaxAggregateOutputType | null
  }

  export type ManganeseAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type ManganeseSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type ManganeseMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type ManganeseMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type ManganeseCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type ManganeseAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type ManganeseSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type ManganeseMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type ManganeseMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type ManganeseCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type ManganeseAggregateArgs = {
    /**
     * Filter which Manganese to aggregate.
     * 
    **/
    where?: ManganeseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manganese to fetch.
     * 
    **/
    orderBy?: Enumerable<ManganeseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ManganeseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manganese from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manganese.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Manganese
    **/
    _count?: true | ManganeseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ManganeseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ManganeseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ManganeseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ManganeseMaxAggregateInputType
  }

  export type GetManganeseAggregateType<T extends ManganeseAggregateArgs> = {
        [P in keyof T & keyof AggregateManganese]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateManganese[P]>
      : GetScalarType<T[P], AggregateManganese[P]>
  }




  export type ManganeseGroupByArgs = {
    where?: ManganeseWhereInput
    orderBy?: Enumerable<ManganeseOrderByWithAggregationInput>
    by: Array<ManganeseScalarFieldEnum>
    having?: ManganeseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ManganeseCountAggregateInputType | true
    _avg?: ManganeseAvgAggregateInputType
    _sum?: ManganeseSumAggregateInputType
    _min?: ManganeseMinAggregateInputType
    _max?: ManganeseMaxAggregateInputType
  }


  export type ManganeseGroupByOutputType = {
    id: number
    measurementId: number
    _count: ManganeseCountAggregateOutputType | null
    _avg: ManganeseAvgAggregateOutputType | null
    _sum: ManganeseSumAggregateOutputType | null
    _min: ManganeseMinAggregateOutputType | null
    _max: ManganeseMaxAggregateOutputType | null
  }

  type GetManganeseGroupByPayload<T extends ManganeseGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ManganeseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ManganeseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ManganeseGroupByOutputType[P]>
            : GetScalarType<T[P], ManganeseGroupByOutputType[P]>
        }
      >
    >


  export type ManganeseSelect = {
    id?: boolean
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    measurementId?: boolean
    _count?: boolean | ManganeseCountOutputTypeArgs
  }

  export type ManganeseInclude = {
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    _count?: boolean | ManganeseCountOutputTypeArgs
  }

  export type ManganeseGetPayload<
    S extends boolean | null | undefined | ManganeseArgs,
    U = keyof S
      > = S extends true
        ? Manganese
    : S extends undefined
    ? never
    : S extends ManganeseArgs | ManganeseFindManyArgs
    ?'include' extends U
    ? Manganese  & {
    [P in TrueKeys<S['include']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['include'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends '_count' ? ManganeseCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['select'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends '_count' ? ManganeseCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Manganese ? Manganese[P] : never
  } 
    : Manganese
  : Manganese


  type ManganeseCountArgs = Merge<
    Omit<ManganeseFindManyArgs, 'select' | 'include'> & {
      select?: ManganeseCountAggregateInputType | true
    }
  >

  export interface ManganeseDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Manganese that matches the filter.
     * @param {ManganeseFindUniqueArgs} args - Arguments to find a Manganese
     * @example
     * // Get one Manganese
     * const manganese = await prisma.manganese.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ManganeseFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ManganeseFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Manganese'> extends True ? CheckSelect<T, Prisma__ManganeseClient<Manganese>, Prisma__ManganeseClient<ManganeseGetPayload<T>>> : CheckSelect<T, Prisma__ManganeseClient<Manganese | null >, Prisma__ManganeseClient<ManganeseGetPayload<T> | null >>

    /**
     * Find the first Manganese that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManganeseFindFirstArgs} args - Arguments to find a Manganese
     * @example
     * // Get one Manganese
     * const manganese = await prisma.manganese.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ManganeseFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ManganeseFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Manganese'> extends True ? CheckSelect<T, Prisma__ManganeseClient<Manganese>, Prisma__ManganeseClient<ManganeseGetPayload<T>>> : CheckSelect<T, Prisma__ManganeseClient<Manganese | null >, Prisma__ManganeseClient<ManganeseGetPayload<T> | null >>

    /**
     * Find zero or more Manganese that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManganeseFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Manganese
     * const manganese = await prisma.manganese.findMany()
     * 
     * // Get first 10 Manganese
     * const manganese = await prisma.manganese.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const manganeseWithIdOnly = await prisma.manganese.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ManganeseFindManyArgs>(
      args?: SelectSubset<T, ManganeseFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Manganese>>, PrismaPromise<Array<ManganeseGetPayload<T>>>>

    /**
     * Create a Manganese.
     * @param {ManganeseCreateArgs} args - Arguments to create a Manganese.
     * @example
     * // Create one Manganese
     * const Manganese = await prisma.manganese.create({
     *   data: {
     *     // ... data to create a Manganese
     *   }
     * })
     * 
    **/
    create<T extends ManganeseCreateArgs>(
      args: SelectSubset<T, ManganeseCreateArgs>
    ): CheckSelect<T, Prisma__ManganeseClient<Manganese>, Prisma__ManganeseClient<ManganeseGetPayload<T>>>

    /**
     * Create many Manganese.
     *     @param {ManganeseCreateManyArgs} args - Arguments to create many Manganese.
     *     @example
     *     // Create many Manganese
     *     const manganese = await prisma.manganese.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ManganeseCreateManyArgs>(
      args?: SelectSubset<T, ManganeseCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Manganese.
     * @param {ManganeseDeleteArgs} args - Arguments to delete one Manganese.
     * @example
     * // Delete one Manganese
     * const Manganese = await prisma.manganese.delete({
     *   where: {
     *     // ... filter to delete one Manganese
     *   }
     * })
     * 
    **/
    delete<T extends ManganeseDeleteArgs>(
      args: SelectSubset<T, ManganeseDeleteArgs>
    ): CheckSelect<T, Prisma__ManganeseClient<Manganese>, Prisma__ManganeseClient<ManganeseGetPayload<T>>>

    /**
     * Update one Manganese.
     * @param {ManganeseUpdateArgs} args - Arguments to update one Manganese.
     * @example
     * // Update one Manganese
     * const manganese = await prisma.manganese.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ManganeseUpdateArgs>(
      args: SelectSubset<T, ManganeseUpdateArgs>
    ): CheckSelect<T, Prisma__ManganeseClient<Manganese>, Prisma__ManganeseClient<ManganeseGetPayload<T>>>

    /**
     * Delete zero or more Manganese.
     * @param {ManganeseDeleteManyArgs} args - Arguments to filter Manganese to delete.
     * @example
     * // Delete a few Manganese
     * const { count } = await prisma.manganese.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ManganeseDeleteManyArgs>(
      args?: SelectSubset<T, ManganeseDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Manganese.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManganeseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Manganese
     * const manganese = await prisma.manganese.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ManganeseUpdateManyArgs>(
      args: SelectSubset<T, ManganeseUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Manganese.
     * @param {ManganeseUpsertArgs} args - Arguments to update or create a Manganese.
     * @example
     * // Update or create a Manganese
     * const manganese = await prisma.manganese.upsert({
     *   create: {
     *     // ... data to create a Manganese
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Manganese we want to update
     *   }
     * })
    **/
    upsert<T extends ManganeseUpsertArgs>(
      args: SelectSubset<T, ManganeseUpsertArgs>
    ): CheckSelect<T, Prisma__ManganeseClient<Manganese>, Prisma__ManganeseClient<ManganeseGetPayload<T>>>

    /**
     * Count the number of Manganese.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManganeseCountArgs} args - Arguments to filter Manganese to count.
     * @example
     * // Count the number of Manganese
     * const count = await prisma.manganese.count({
     *   where: {
     *     // ... the filter for the Manganese we want to count
     *   }
     * })
    **/
    count<T extends ManganeseCountArgs>(
      args?: Subset<T, ManganeseCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ManganeseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Manganese.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManganeseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ManganeseAggregateArgs>(args: Subset<T, ManganeseAggregateArgs>): PrismaPromise<GetManganeseAggregateType<T>>

    /**
     * Group by Manganese.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ManganeseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ManganeseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ManganeseGroupByArgs['orderBy'] }
        : { orderBy?: ManganeseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ManganeseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetManganeseGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Manganese.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ManganeseClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    minerals<T extends MineralFindManyArgs = {}>(args?: Subset<T, MineralFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mineral>>, PrismaPromise<Array<MineralGetPayload<T>>>>;

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Manganese findUnique
   */
  export type ManganeseFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Manganese
     * 
    **/
    select?: ManganeseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ManganeseInclude | null
    /**
     * Throw an Error if a Manganese can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Manganese to fetch.
     * 
    **/
    where: ManganeseWhereUniqueInput
  }


  /**
   * Manganese findFirst
   */
  export type ManganeseFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Manganese
     * 
    **/
    select?: ManganeseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ManganeseInclude | null
    /**
     * Throw an Error if a Manganese can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Manganese to fetch.
     * 
    **/
    where?: ManganeseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manganese to fetch.
     * 
    **/
    orderBy?: Enumerable<ManganeseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Manganese.
     * 
    **/
    cursor?: ManganeseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manganese from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manganese.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Manganese.
     * 
    **/
    distinct?: Enumerable<ManganeseScalarFieldEnum>
  }


  /**
   * Manganese findMany
   */
  export type ManganeseFindManyArgs = {
    /**
     * Select specific fields to fetch from the Manganese
     * 
    **/
    select?: ManganeseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ManganeseInclude | null
    /**
     * Filter, which Manganese to fetch.
     * 
    **/
    where?: ManganeseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Manganese to fetch.
     * 
    **/
    orderBy?: Enumerable<ManganeseOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Manganese.
     * 
    **/
    cursor?: ManganeseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Manganese from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Manganese.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ManganeseScalarFieldEnum>
  }


  /**
   * Manganese create
   */
  export type ManganeseCreateArgs = {
    /**
     * Select specific fields to fetch from the Manganese
     * 
    **/
    select?: ManganeseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ManganeseInclude | null
    /**
     * The data needed to create a Manganese.
     * 
    **/
    data: XOR<ManganeseCreateInput, ManganeseUncheckedCreateInput>
  }


  /**
   * Manganese createMany
   */
  export type ManganeseCreateManyArgs = {
    /**
     * The data used to create many Manganese.
     * 
    **/
    data: Enumerable<ManganeseCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Manganese update
   */
  export type ManganeseUpdateArgs = {
    /**
     * Select specific fields to fetch from the Manganese
     * 
    **/
    select?: ManganeseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ManganeseInclude | null
    /**
     * The data needed to update a Manganese.
     * 
    **/
    data: XOR<ManganeseUpdateInput, ManganeseUncheckedUpdateInput>
    /**
     * Choose, which Manganese to update.
     * 
    **/
    where: ManganeseWhereUniqueInput
  }


  /**
   * Manganese updateMany
   */
  export type ManganeseUpdateManyArgs = {
    /**
     * The data used to update Manganese.
     * 
    **/
    data: XOR<ManganeseUpdateManyMutationInput, ManganeseUncheckedUpdateManyInput>
    /**
     * Filter which Manganese to update
     * 
    **/
    where?: ManganeseWhereInput
  }


  /**
   * Manganese upsert
   */
  export type ManganeseUpsertArgs = {
    /**
     * Select specific fields to fetch from the Manganese
     * 
    **/
    select?: ManganeseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ManganeseInclude | null
    /**
     * The filter to search for the Manganese to update in case it exists.
     * 
    **/
    where: ManganeseWhereUniqueInput
    /**
     * In case the Manganese found by the `where` argument doesn't exist, create a new Manganese with this data.
     * 
    **/
    create: XOR<ManganeseCreateInput, ManganeseUncheckedCreateInput>
    /**
     * In case the Manganese was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ManganeseUpdateInput, ManganeseUncheckedUpdateInput>
  }


  /**
   * Manganese delete
   */
  export type ManganeseDeleteArgs = {
    /**
     * Select specific fields to fetch from the Manganese
     * 
    **/
    select?: ManganeseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ManganeseInclude | null
    /**
     * Filter which Manganese to delete.
     * 
    **/
    where: ManganeseWhereUniqueInput
  }


  /**
   * Manganese deleteMany
   */
  export type ManganeseDeleteManyArgs = {
    /**
     * Filter which Manganese to delete
     * 
    **/
    where?: ManganeseWhereInput
  }


  /**
   * Manganese without action
   */
  export type ManganeseArgs = {
    /**
     * Select specific fields to fetch from the Manganese
     * 
    **/
    select?: ManganeseSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ManganeseInclude | null
  }



  /**
   * Model Sulfur
   */


  export type AggregateSulfur = {
    _count: SulfurCountAggregateOutputType | null
    _avg: SulfurAvgAggregateOutputType | null
    _sum: SulfurSumAggregateOutputType | null
    _min: SulfurMinAggregateOutputType | null
    _max: SulfurMaxAggregateOutputType | null
  }

  export type SulfurAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SulfurSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SulfurMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SulfurMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type SulfurCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type SulfurAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SulfurSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SulfurMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SulfurMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type SulfurCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type SulfurAggregateArgs = {
    /**
     * Filter which Sulfur to aggregate.
     * 
    **/
    where?: SulfurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sulfurs to fetch.
     * 
    **/
    orderBy?: Enumerable<SulfurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: SulfurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sulfurs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sulfurs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sulfurs
    **/
    _count?: true | SulfurCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SulfurAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SulfurSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SulfurMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SulfurMaxAggregateInputType
  }

  export type GetSulfurAggregateType<T extends SulfurAggregateArgs> = {
        [P in keyof T & keyof AggregateSulfur]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSulfur[P]>
      : GetScalarType<T[P], AggregateSulfur[P]>
  }




  export type SulfurGroupByArgs = {
    where?: SulfurWhereInput
    orderBy?: Enumerable<SulfurOrderByWithAggregationInput>
    by: Array<SulfurScalarFieldEnum>
    having?: SulfurScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SulfurCountAggregateInputType | true
    _avg?: SulfurAvgAggregateInputType
    _sum?: SulfurSumAggregateInputType
    _min?: SulfurMinAggregateInputType
    _max?: SulfurMaxAggregateInputType
  }


  export type SulfurGroupByOutputType = {
    id: number
    measurementId: number
    _count: SulfurCountAggregateOutputType | null
    _avg: SulfurAvgAggregateOutputType | null
    _sum: SulfurSumAggregateOutputType | null
    _min: SulfurMinAggregateOutputType | null
    _max: SulfurMaxAggregateOutputType | null
  }

  type GetSulfurGroupByPayload<T extends SulfurGroupByArgs> = PrismaPromise<
    Array<
      PickArray<SulfurGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SulfurGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SulfurGroupByOutputType[P]>
            : GetScalarType<T[P], SulfurGroupByOutputType[P]>
        }
      >
    >


  export type SulfurSelect = {
    id?: boolean
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    measurementId?: boolean
    _count?: boolean | SulfurCountOutputTypeArgs
  }

  export type SulfurInclude = {
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    _count?: boolean | SulfurCountOutputTypeArgs
  }

  export type SulfurGetPayload<
    S extends boolean | null | undefined | SulfurArgs,
    U = keyof S
      > = S extends true
        ? Sulfur
    : S extends undefined
    ? never
    : S extends SulfurArgs | SulfurFindManyArgs
    ?'include' extends U
    ? Sulfur  & {
    [P in TrueKeys<S['include']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['include'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends '_count' ? SulfurCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['select'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends '_count' ? SulfurCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Sulfur ? Sulfur[P] : never
  } 
    : Sulfur
  : Sulfur


  type SulfurCountArgs = Merge<
    Omit<SulfurFindManyArgs, 'select' | 'include'> & {
      select?: SulfurCountAggregateInputType | true
    }
  >

  export interface SulfurDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Sulfur that matches the filter.
     * @param {SulfurFindUniqueArgs} args - Arguments to find a Sulfur
     * @example
     * // Get one Sulfur
     * const sulfur = await prisma.sulfur.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends SulfurFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, SulfurFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Sulfur'> extends True ? CheckSelect<T, Prisma__SulfurClient<Sulfur>, Prisma__SulfurClient<SulfurGetPayload<T>>> : CheckSelect<T, Prisma__SulfurClient<Sulfur | null >, Prisma__SulfurClient<SulfurGetPayload<T> | null >>

    /**
     * Find the first Sulfur that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SulfurFindFirstArgs} args - Arguments to find a Sulfur
     * @example
     * // Get one Sulfur
     * const sulfur = await prisma.sulfur.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends SulfurFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, SulfurFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Sulfur'> extends True ? CheckSelect<T, Prisma__SulfurClient<Sulfur>, Prisma__SulfurClient<SulfurGetPayload<T>>> : CheckSelect<T, Prisma__SulfurClient<Sulfur | null >, Prisma__SulfurClient<SulfurGetPayload<T> | null >>

    /**
     * Find zero or more Sulfurs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SulfurFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sulfurs
     * const sulfurs = await prisma.sulfur.findMany()
     * 
     * // Get first 10 Sulfurs
     * const sulfurs = await prisma.sulfur.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sulfurWithIdOnly = await prisma.sulfur.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends SulfurFindManyArgs>(
      args?: SelectSubset<T, SulfurFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Sulfur>>, PrismaPromise<Array<SulfurGetPayload<T>>>>

    /**
     * Create a Sulfur.
     * @param {SulfurCreateArgs} args - Arguments to create a Sulfur.
     * @example
     * // Create one Sulfur
     * const Sulfur = await prisma.sulfur.create({
     *   data: {
     *     // ... data to create a Sulfur
     *   }
     * })
     * 
    **/
    create<T extends SulfurCreateArgs>(
      args: SelectSubset<T, SulfurCreateArgs>
    ): CheckSelect<T, Prisma__SulfurClient<Sulfur>, Prisma__SulfurClient<SulfurGetPayload<T>>>

    /**
     * Create many Sulfurs.
     *     @param {SulfurCreateManyArgs} args - Arguments to create many Sulfurs.
     *     @example
     *     // Create many Sulfurs
     *     const sulfur = await prisma.sulfur.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends SulfurCreateManyArgs>(
      args?: SelectSubset<T, SulfurCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Sulfur.
     * @param {SulfurDeleteArgs} args - Arguments to delete one Sulfur.
     * @example
     * // Delete one Sulfur
     * const Sulfur = await prisma.sulfur.delete({
     *   where: {
     *     // ... filter to delete one Sulfur
     *   }
     * })
     * 
    **/
    delete<T extends SulfurDeleteArgs>(
      args: SelectSubset<T, SulfurDeleteArgs>
    ): CheckSelect<T, Prisma__SulfurClient<Sulfur>, Prisma__SulfurClient<SulfurGetPayload<T>>>

    /**
     * Update one Sulfur.
     * @param {SulfurUpdateArgs} args - Arguments to update one Sulfur.
     * @example
     * // Update one Sulfur
     * const sulfur = await prisma.sulfur.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends SulfurUpdateArgs>(
      args: SelectSubset<T, SulfurUpdateArgs>
    ): CheckSelect<T, Prisma__SulfurClient<Sulfur>, Prisma__SulfurClient<SulfurGetPayload<T>>>

    /**
     * Delete zero or more Sulfurs.
     * @param {SulfurDeleteManyArgs} args - Arguments to filter Sulfurs to delete.
     * @example
     * // Delete a few Sulfurs
     * const { count } = await prisma.sulfur.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends SulfurDeleteManyArgs>(
      args?: SelectSubset<T, SulfurDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sulfurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SulfurUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sulfurs
     * const sulfur = await prisma.sulfur.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends SulfurUpdateManyArgs>(
      args: SelectSubset<T, SulfurUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Sulfur.
     * @param {SulfurUpsertArgs} args - Arguments to update or create a Sulfur.
     * @example
     * // Update or create a Sulfur
     * const sulfur = await prisma.sulfur.upsert({
     *   create: {
     *     // ... data to create a Sulfur
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sulfur we want to update
     *   }
     * })
    **/
    upsert<T extends SulfurUpsertArgs>(
      args: SelectSubset<T, SulfurUpsertArgs>
    ): CheckSelect<T, Prisma__SulfurClient<Sulfur>, Prisma__SulfurClient<SulfurGetPayload<T>>>

    /**
     * Count the number of Sulfurs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SulfurCountArgs} args - Arguments to filter Sulfurs to count.
     * @example
     * // Count the number of Sulfurs
     * const count = await prisma.sulfur.count({
     *   where: {
     *     // ... the filter for the Sulfurs we want to count
     *   }
     * })
    **/
    count<T extends SulfurCountArgs>(
      args?: Subset<T, SulfurCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SulfurCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sulfur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SulfurAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SulfurAggregateArgs>(args: Subset<T, SulfurAggregateArgs>): PrismaPromise<GetSulfurAggregateType<T>>

    /**
     * Group by Sulfur.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SulfurGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SulfurGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SulfurGroupByArgs['orderBy'] }
        : { orderBy?: SulfurGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SulfurGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSulfurGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sulfur.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__SulfurClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    minerals<T extends MineralFindManyArgs = {}>(args?: Subset<T, MineralFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mineral>>, PrismaPromise<Array<MineralGetPayload<T>>>>;

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Sulfur findUnique
   */
  export type SulfurFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Sulfur
     * 
    **/
    select?: SulfurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SulfurInclude | null
    /**
     * Throw an Error if a Sulfur can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Sulfur to fetch.
     * 
    **/
    where: SulfurWhereUniqueInput
  }


  /**
   * Sulfur findFirst
   */
  export type SulfurFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Sulfur
     * 
    **/
    select?: SulfurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SulfurInclude | null
    /**
     * Throw an Error if a Sulfur can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Sulfur to fetch.
     * 
    **/
    where?: SulfurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sulfurs to fetch.
     * 
    **/
    orderBy?: Enumerable<SulfurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sulfurs.
     * 
    **/
    cursor?: SulfurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sulfurs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sulfurs.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sulfurs.
     * 
    **/
    distinct?: Enumerable<SulfurScalarFieldEnum>
  }


  /**
   * Sulfur findMany
   */
  export type SulfurFindManyArgs = {
    /**
     * Select specific fields to fetch from the Sulfur
     * 
    **/
    select?: SulfurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SulfurInclude | null
    /**
     * Filter, which Sulfurs to fetch.
     * 
    **/
    where?: SulfurWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sulfurs to fetch.
     * 
    **/
    orderBy?: Enumerable<SulfurOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sulfurs.
     * 
    **/
    cursor?: SulfurWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sulfurs from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sulfurs.
     * 
    **/
    skip?: number
    distinct?: Enumerable<SulfurScalarFieldEnum>
  }


  /**
   * Sulfur create
   */
  export type SulfurCreateArgs = {
    /**
     * Select specific fields to fetch from the Sulfur
     * 
    **/
    select?: SulfurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SulfurInclude | null
    /**
     * The data needed to create a Sulfur.
     * 
    **/
    data: XOR<SulfurCreateInput, SulfurUncheckedCreateInput>
  }


  /**
   * Sulfur createMany
   */
  export type SulfurCreateManyArgs = {
    /**
     * The data used to create many Sulfurs.
     * 
    **/
    data: Enumerable<SulfurCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Sulfur update
   */
  export type SulfurUpdateArgs = {
    /**
     * Select specific fields to fetch from the Sulfur
     * 
    **/
    select?: SulfurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SulfurInclude | null
    /**
     * The data needed to update a Sulfur.
     * 
    **/
    data: XOR<SulfurUpdateInput, SulfurUncheckedUpdateInput>
    /**
     * Choose, which Sulfur to update.
     * 
    **/
    where: SulfurWhereUniqueInput
  }


  /**
   * Sulfur updateMany
   */
  export type SulfurUpdateManyArgs = {
    /**
     * The data used to update Sulfurs.
     * 
    **/
    data: XOR<SulfurUpdateManyMutationInput, SulfurUncheckedUpdateManyInput>
    /**
     * Filter which Sulfurs to update
     * 
    **/
    where?: SulfurWhereInput
  }


  /**
   * Sulfur upsert
   */
  export type SulfurUpsertArgs = {
    /**
     * Select specific fields to fetch from the Sulfur
     * 
    **/
    select?: SulfurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SulfurInclude | null
    /**
     * The filter to search for the Sulfur to update in case it exists.
     * 
    **/
    where: SulfurWhereUniqueInput
    /**
     * In case the Sulfur found by the `where` argument doesn't exist, create a new Sulfur with this data.
     * 
    **/
    create: XOR<SulfurCreateInput, SulfurUncheckedCreateInput>
    /**
     * In case the Sulfur was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<SulfurUpdateInput, SulfurUncheckedUpdateInput>
  }


  /**
   * Sulfur delete
   */
  export type SulfurDeleteArgs = {
    /**
     * Select specific fields to fetch from the Sulfur
     * 
    **/
    select?: SulfurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SulfurInclude | null
    /**
     * Filter which Sulfur to delete.
     * 
    **/
    where: SulfurWhereUniqueInput
  }


  /**
   * Sulfur deleteMany
   */
  export type SulfurDeleteManyArgs = {
    /**
     * Filter which Sulfurs to delete
     * 
    **/
    where?: SulfurWhereInput
  }


  /**
   * Sulfur without action
   */
  export type SulfurArgs = {
    /**
     * Select specific fields to fetch from the Sulfur
     * 
    **/
    select?: SulfurSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: SulfurInclude | null
  }



  /**
   * Model Potassium
   */


  export type AggregatePotassium = {
    _count: PotassiumCountAggregateOutputType | null
    _avg: PotassiumAvgAggregateOutputType | null
    _sum: PotassiumSumAggregateOutputType | null
    _min: PotassiumMinAggregateOutputType | null
    _max: PotassiumMaxAggregateOutputType | null
  }

  export type PotassiumAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type PotassiumSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type PotassiumMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type PotassiumMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type PotassiumCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type PotassiumAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type PotassiumSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type PotassiumMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type PotassiumMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type PotassiumCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type PotassiumAggregateArgs = {
    /**
     * Filter which Potassium to aggregate.
     * 
    **/
    where?: PotassiumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Potassiums to fetch.
     * 
    **/
    orderBy?: Enumerable<PotassiumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PotassiumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Potassiums from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Potassiums.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Potassiums
    **/
    _count?: true | PotassiumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PotassiumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PotassiumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PotassiumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PotassiumMaxAggregateInputType
  }

  export type GetPotassiumAggregateType<T extends PotassiumAggregateArgs> = {
        [P in keyof T & keyof AggregatePotassium]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePotassium[P]>
      : GetScalarType<T[P], AggregatePotassium[P]>
  }




  export type PotassiumGroupByArgs = {
    where?: PotassiumWhereInput
    orderBy?: Enumerable<PotassiumOrderByWithAggregationInput>
    by: Array<PotassiumScalarFieldEnum>
    having?: PotassiumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PotassiumCountAggregateInputType | true
    _avg?: PotassiumAvgAggregateInputType
    _sum?: PotassiumSumAggregateInputType
    _min?: PotassiumMinAggregateInputType
    _max?: PotassiumMaxAggregateInputType
  }


  export type PotassiumGroupByOutputType = {
    id: number
    measurementId: number
    _count: PotassiumCountAggregateOutputType | null
    _avg: PotassiumAvgAggregateOutputType | null
    _sum: PotassiumSumAggregateOutputType | null
    _min: PotassiumMinAggregateOutputType | null
    _max: PotassiumMaxAggregateOutputType | null
  }

  type GetPotassiumGroupByPayload<T extends PotassiumGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PotassiumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PotassiumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PotassiumGroupByOutputType[P]>
            : GetScalarType<T[P], PotassiumGroupByOutputType[P]>
        }
      >
    >


  export type PotassiumSelect = {
    id?: boolean
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    measurementId?: boolean
    _count?: boolean | PotassiumCountOutputTypeArgs
  }

  export type PotassiumInclude = {
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    _count?: boolean | PotassiumCountOutputTypeArgs
  }

  export type PotassiumGetPayload<
    S extends boolean | null | undefined | PotassiumArgs,
    U = keyof S
      > = S extends true
        ? Potassium
    : S extends undefined
    ? never
    : S extends PotassiumArgs | PotassiumFindManyArgs
    ?'include' extends U
    ? Potassium  & {
    [P in TrueKeys<S['include']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['include'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends '_count' ? PotassiumCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['select'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends '_count' ? PotassiumCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Potassium ? Potassium[P] : never
  } 
    : Potassium
  : Potassium


  type PotassiumCountArgs = Merge<
    Omit<PotassiumFindManyArgs, 'select' | 'include'> & {
      select?: PotassiumCountAggregateInputType | true
    }
  >

  export interface PotassiumDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Potassium that matches the filter.
     * @param {PotassiumFindUniqueArgs} args - Arguments to find a Potassium
     * @example
     * // Get one Potassium
     * const potassium = await prisma.potassium.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PotassiumFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PotassiumFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Potassium'> extends True ? CheckSelect<T, Prisma__PotassiumClient<Potassium>, Prisma__PotassiumClient<PotassiumGetPayload<T>>> : CheckSelect<T, Prisma__PotassiumClient<Potassium | null >, Prisma__PotassiumClient<PotassiumGetPayload<T> | null >>

    /**
     * Find the first Potassium that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotassiumFindFirstArgs} args - Arguments to find a Potassium
     * @example
     * // Get one Potassium
     * const potassium = await prisma.potassium.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PotassiumFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PotassiumFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Potassium'> extends True ? CheckSelect<T, Prisma__PotassiumClient<Potassium>, Prisma__PotassiumClient<PotassiumGetPayload<T>>> : CheckSelect<T, Prisma__PotassiumClient<Potassium | null >, Prisma__PotassiumClient<PotassiumGetPayload<T> | null >>

    /**
     * Find zero or more Potassiums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotassiumFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Potassiums
     * const potassiums = await prisma.potassium.findMany()
     * 
     * // Get first 10 Potassiums
     * const potassiums = await prisma.potassium.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const potassiumWithIdOnly = await prisma.potassium.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PotassiumFindManyArgs>(
      args?: SelectSubset<T, PotassiumFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Potassium>>, PrismaPromise<Array<PotassiumGetPayload<T>>>>

    /**
     * Create a Potassium.
     * @param {PotassiumCreateArgs} args - Arguments to create a Potassium.
     * @example
     * // Create one Potassium
     * const Potassium = await prisma.potassium.create({
     *   data: {
     *     // ... data to create a Potassium
     *   }
     * })
     * 
    **/
    create<T extends PotassiumCreateArgs>(
      args: SelectSubset<T, PotassiumCreateArgs>
    ): CheckSelect<T, Prisma__PotassiumClient<Potassium>, Prisma__PotassiumClient<PotassiumGetPayload<T>>>

    /**
     * Create many Potassiums.
     *     @param {PotassiumCreateManyArgs} args - Arguments to create many Potassiums.
     *     @example
     *     // Create many Potassiums
     *     const potassium = await prisma.potassium.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PotassiumCreateManyArgs>(
      args?: SelectSubset<T, PotassiumCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Potassium.
     * @param {PotassiumDeleteArgs} args - Arguments to delete one Potassium.
     * @example
     * // Delete one Potassium
     * const Potassium = await prisma.potassium.delete({
     *   where: {
     *     // ... filter to delete one Potassium
     *   }
     * })
     * 
    **/
    delete<T extends PotassiumDeleteArgs>(
      args: SelectSubset<T, PotassiumDeleteArgs>
    ): CheckSelect<T, Prisma__PotassiumClient<Potassium>, Prisma__PotassiumClient<PotassiumGetPayload<T>>>

    /**
     * Update one Potassium.
     * @param {PotassiumUpdateArgs} args - Arguments to update one Potassium.
     * @example
     * // Update one Potassium
     * const potassium = await prisma.potassium.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PotassiumUpdateArgs>(
      args: SelectSubset<T, PotassiumUpdateArgs>
    ): CheckSelect<T, Prisma__PotassiumClient<Potassium>, Prisma__PotassiumClient<PotassiumGetPayload<T>>>

    /**
     * Delete zero or more Potassiums.
     * @param {PotassiumDeleteManyArgs} args - Arguments to filter Potassiums to delete.
     * @example
     * // Delete a few Potassiums
     * const { count } = await prisma.potassium.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PotassiumDeleteManyArgs>(
      args?: SelectSubset<T, PotassiumDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Potassiums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotassiumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Potassiums
     * const potassium = await prisma.potassium.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PotassiumUpdateManyArgs>(
      args: SelectSubset<T, PotassiumUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Potassium.
     * @param {PotassiumUpsertArgs} args - Arguments to update or create a Potassium.
     * @example
     * // Update or create a Potassium
     * const potassium = await prisma.potassium.upsert({
     *   create: {
     *     // ... data to create a Potassium
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Potassium we want to update
     *   }
     * })
    **/
    upsert<T extends PotassiumUpsertArgs>(
      args: SelectSubset<T, PotassiumUpsertArgs>
    ): CheckSelect<T, Prisma__PotassiumClient<Potassium>, Prisma__PotassiumClient<PotassiumGetPayload<T>>>

    /**
     * Count the number of Potassiums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotassiumCountArgs} args - Arguments to filter Potassiums to count.
     * @example
     * // Count the number of Potassiums
     * const count = await prisma.potassium.count({
     *   where: {
     *     // ... the filter for the Potassiums we want to count
     *   }
     * })
    **/
    count<T extends PotassiumCountArgs>(
      args?: Subset<T, PotassiumCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PotassiumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Potassium.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotassiumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PotassiumAggregateArgs>(args: Subset<T, PotassiumAggregateArgs>): PrismaPromise<GetPotassiumAggregateType<T>>

    /**
     * Group by Potassium.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PotassiumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PotassiumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PotassiumGroupByArgs['orderBy'] }
        : { orderBy?: PotassiumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PotassiumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPotassiumGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Potassium.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PotassiumClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    minerals<T extends MineralFindManyArgs = {}>(args?: Subset<T, MineralFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mineral>>, PrismaPromise<Array<MineralGetPayload<T>>>>;

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Potassium findUnique
   */
  export type PotassiumFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Potassium
     * 
    **/
    select?: PotassiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PotassiumInclude | null
    /**
     * Throw an Error if a Potassium can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Potassium to fetch.
     * 
    **/
    where: PotassiumWhereUniqueInput
  }


  /**
   * Potassium findFirst
   */
  export type PotassiumFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Potassium
     * 
    **/
    select?: PotassiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PotassiumInclude | null
    /**
     * Throw an Error if a Potassium can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Potassium to fetch.
     * 
    **/
    where?: PotassiumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Potassiums to fetch.
     * 
    **/
    orderBy?: Enumerable<PotassiumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Potassiums.
     * 
    **/
    cursor?: PotassiumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Potassiums from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Potassiums.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Potassiums.
     * 
    **/
    distinct?: Enumerable<PotassiumScalarFieldEnum>
  }


  /**
   * Potassium findMany
   */
  export type PotassiumFindManyArgs = {
    /**
     * Select specific fields to fetch from the Potassium
     * 
    **/
    select?: PotassiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PotassiumInclude | null
    /**
     * Filter, which Potassiums to fetch.
     * 
    **/
    where?: PotassiumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Potassiums to fetch.
     * 
    **/
    orderBy?: Enumerable<PotassiumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Potassiums.
     * 
    **/
    cursor?: PotassiumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Potassiums from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Potassiums.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PotassiumScalarFieldEnum>
  }


  /**
   * Potassium create
   */
  export type PotassiumCreateArgs = {
    /**
     * Select specific fields to fetch from the Potassium
     * 
    **/
    select?: PotassiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PotassiumInclude | null
    /**
     * The data needed to create a Potassium.
     * 
    **/
    data: XOR<PotassiumCreateInput, PotassiumUncheckedCreateInput>
  }


  /**
   * Potassium createMany
   */
  export type PotassiumCreateManyArgs = {
    /**
     * The data used to create many Potassiums.
     * 
    **/
    data: Enumerable<PotassiumCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Potassium update
   */
  export type PotassiumUpdateArgs = {
    /**
     * Select specific fields to fetch from the Potassium
     * 
    **/
    select?: PotassiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PotassiumInclude | null
    /**
     * The data needed to update a Potassium.
     * 
    **/
    data: XOR<PotassiumUpdateInput, PotassiumUncheckedUpdateInput>
    /**
     * Choose, which Potassium to update.
     * 
    **/
    where: PotassiumWhereUniqueInput
  }


  /**
   * Potassium updateMany
   */
  export type PotassiumUpdateManyArgs = {
    /**
     * The data used to update Potassiums.
     * 
    **/
    data: XOR<PotassiumUpdateManyMutationInput, PotassiumUncheckedUpdateManyInput>
    /**
     * Filter which Potassiums to update
     * 
    **/
    where?: PotassiumWhereInput
  }


  /**
   * Potassium upsert
   */
  export type PotassiumUpsertArgs = {
    /**
     * Select specific fields to fetch from the Potassium
     * 
    **/
    select?: PotassiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PotassiumInclude | null
    /**
     * The filter to search for the Potassium to update in case it exists.
     * 
    **/
    where: PotassiumWhereUniqueInput
    /**
     * In case the Potassium found by the `where` argument doesn't exist, create a new Potassium with this data.
     * 
    **/
    create: XOR<PotassiumCreateInput, PotassiumUncheckedCreateInput>
    /**
     * In case the Potassium was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PotassiumUpdateInput, PotassiumUncheckedUpdateInput>
  }


  /**
   * Potassium delete
   */
  export type PotassiumDeleteArgs = {
    /**
     * Select specific fields to fetch from the Potassium
     * 
    **/
    select?: PotassiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PotassiumInclude | null
    /**
     * Filter which Potassium to delete.
     * 
    **/
    where: PotassiumWhereUniqueInput
  }


  /**
   * Potassium deleteMany
   */
  export type PotassiumDeleteManyArgs = {
    /**
     * Filter which Potassiums to delete
     * 
    **/
    where?: PotassiumWhereInput
  }


  /**
   * Potassium without action
   */
  export type PotassiumArgs = {
    /**
     * Select specific fields to fetch from the Potassium
     * 
    **/
    select?: PotassiumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PotassiumInclude | null
  }



  /**
   * Model Fluoride
   */


  export type AggregateFluoride = {
    _count: FluorideCountAggregateOutputType | null
    _avg: FluorideAvgAggregateOutputType | null
    _sum: FluorideSumAggregateOutputType | null
    _min: FluorideMinAggregateOutputType | null
    _max: FluorideMaxAggregateOutputType | null
  }

  export type FluorideAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type FluorideSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type FluorideMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type FluorideMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type FluorideCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type FluorideAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type FluorideSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type FluorideMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type FluorideMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type FluorideCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type FluorideAggregateArgs = {
    /**
     * Filter which Fluoride to aggregate.
     * 
    **/
    where?: FluorideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fluorides to fetch.
     * 
    **/
    orderBy?: Enumerable<FluorideOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FluorideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fluorides from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fluorides.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fluorides
    **/
    _count?: true | FluorideCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FluorideAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FluorideSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FluorideMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FluorideMaxAggregateInputType
  }

  export type GetFluorideAggregateType<T extends FluorideAggregateArgs> = {
        [P in keyof T & keyof AggregateFluoride]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFluoride[P]>
      : GetScalarType<T[P], AggregateFluoride[P]>
  }




  export type FluorideGroupByArgs = {
    where?: FluorideWhereInput
    orderBy?: Enumerable<FluorideOrderByWithAggregationInput>
    by: Array<FluorideScalarFieldEnum>
    having?: FluorideScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FluorideCountAggregateInputType | true
    _avg?: FluorideAvgAggregateInputType
    _sum?: FluorideSumAggregateInputType
    _min?: FluorideMinAggregateInputType
    _max?: FluorideMaxAggregateInputType
  }


  export type FluorideGroupByOutputType = {
    id: number
    measurementId: number
    _count: FluorideCountAggregateOutputType | null
    _avg: FluorideAvgAggregateOutputType | null
    _sum: FluorideSumAggregateOutputType | null
    _min: FluorideMinAggregateOutputType | null
    _max: FluorideMaxAggregateOutputType | null
  }

  type GetFluorideGroupByPayload<T extends FluorideGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FluorideGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FluorideGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FluorideGroupByOutputType[P]>
            : GetScalarType<T[P], FluorideGroupByOutputType[P]>
        }
      >
    >


  export type FluorideSelect = {
    id?: boolean
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    measurementId?: boolean
    _count?: boolean | FluorideCountOutputTypeArgs
  }

  export type FluorideInclude = {
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    _count?: boolean | FluorideCountOutputTypeArgs
  }

  export type FluorideGetPayload<
    S extends boolean | null | undefined | FluorideArgs,
    U = keyof S
      > = S extends true
        ? Fluoride
    : S extends undefined
    ? never
    : S extends FluorideArgs | FluorideFindManyArgs
    ?'include' extends U
    ? Fluoride  & {
    [P in TrueKeys<S['include']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['include'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends '_count' ? FluorideCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['select'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends '_count' ? FluorideCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Fluoride ? Fluoride[P] : never
  } 
    : Fluoride
  : Fluoride


  type FluorideCountArgs = Merge<
    Omit<FluorideFindManyArgs, 'select' | 'include'> & {
      select?: FluorideCountAggregateInputType | true
    }
  >

  export interface FluorideDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Fluoride that matches the filter.
     * @param {FluorideFindUniqueArgs} args - Arguments to find a Fluoride
     * @example
     * // Get one Fluoride
     * const fluoride = await prisma.fluoride.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FluorideFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FluorideFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Fluoride'> extends True ? CheckSelect<T, Prisma__FluorideClient<Fluoride>, Prisma__FluorideClient<FluorideGetPayload<T>>> : CheckSelect<T, Prisma__FluorideClient<Fluoride | null >, Prisma__FluorideClient<FluorideGetPayload<T> | null >>

    /**
     * Find the first Fluoride that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FluorideFindFirstArgs} args - Arguments to find a Fluoride
     * @example
     * // Get one Fluoride
     * const fluoride = await prisma.fluoride.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FluorideFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FluorideFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Fluoride'> extends True ? CheckSelect<T, Prisma__FluorideClient<Fluoride>, Prisma__FluorideClient<FluorideGetPayload<T>>> : CheckSelect<T, Prisma__FluorideClient<Fluoride | null >, Prisma__FluorideClient<FluorideGetPayload<T> | null >>

    /**
     * Find zero or more Fluorides that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FluorideFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fluorides
     * const fluorides = await prisma.fluoride.findMany()
     * 
     * // Get first 10 Fluorides
     * const fluorides = await prisma.fluoride.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fluorideWithIdOnly = await prisma.fluoride.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FluorideFindManyArgs>(
      args?: SelectSubset<T, FluorideFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Fluoride>>, PrismaPromise<Array<FluorideGetPayload<T>>>>

    /**
     * Create a Fluoride.
     * @param {FluorideCreateArgs} args - Arguments to create a Fluoride.
     * @example
     * // Create one Fluoride
     * const Fluoride = await prisma.fluoride.create({
     *   data: {
     *     // ... data to create a Fluoride
     *   }
     * })
     * 
    **/
    create<T extends FluorideCreateArgs>(
      args: SelectSubset<T, FluorideCreateArgs>
    ): CheckSelect<T, Prisma__FluorideClient<Fluoride>, Prisma__FluorideClient<FluorideGetPayload<T>>>

    /**
     * Create many Fluorides.
     *     @param {FluorideCreateManyArgs} args - Arguments to create many Fluorides.
     *     @example
     *     // Create many Fluorides
     *     const fluoride = await prisma.fluoride.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FluorideCreateManyArgs>(
      args?: SelectSubset<T, FluorideCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Fluoride.
     * @param {FluorideDeleteArgs} args - Arguments to delete one Fluoride.
     * @example
     * // Delete one Fluoride
     * const Fluoride = await prisma.fluoride.delete({
     *   where: {
     *     // ... filter to delete one Fluoride
     *   }
     * })
     * 
    **/
    delete<T extends FluorideDeleteArgs>(
      args: SelectSubset<T, FluorideDeleteArgs>
    ): CheckSelect<T, Prisma__FluorideClient<Fluoride>, Prisma__FluorideClient<FluorideGetPayload<T>>>

    /**
     * Update one Fluoride.
     * @param {FluorideUpdateArgs} args - Arguments to update one Fluoride.
     * @example
     * // Update one Fluoride
     * const fluoride = await prisma.fluoride.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FluorideUpdateArgs>(
      args: SelectSubset<T, FluorideUpdateArgs>
    ): CheckSelect<T, Prisma__FluorideClient<Fluoride>, Prisma__FluorideClient<FluorideGetPayload<T>>>

    /**
     * Delete zero or more Fluorides.
     * @param {FluorideDeleteManyArgs} args - Arguments to filter Fluorides to delete.
     * @example
     * // Delete a few Fluorides
     * const { count } = await prisma.fluoride.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FluorideDeleteManyArgs>(
      args?: SelectSubset<T, FluorideDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fluorides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FluorideUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fluorides
     * const fluoride = await prisma.fluoride.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FluorideUpdateManyArgs>(
      args: SelectSubset<T, FluorideUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Fluoride.
     * @param {FluorideUpsertArgs} args - Arguments to update or create a Fluoride.
     * @example
     * // Update or create a Fluoride
     * const fluoride = await prisma.fluoride.upsert({
     *   create: {
     *     // ... data to create a Fluoride
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fluoride we want to update
     *   }
     * })
    **/
    upsert<T extends FluorideUpsertArgs>(
      args: SelectSubset<T, FluorideUpsertArgs>
    ): CheckSelect<T, Prisma__FluorideClient<Fluoride>, Prisma__FluorideClient<FluorideGetPayload<T>>>

    /**
     * Count the number of Fluorides.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FluorideCountArgs} args - Arguments to filter Fluorides to count.
     * @example
     * // Count the number of Fluorides
     * const count = await prisma.fluoride.count({
     *   where: {
     *     // ... the filter for the Fluorides we want to count
     *   }
     * })
    **/
    count<T extends FluorideCountArgs>(
      args?: Subset<T, FluorideCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FluorideCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fluoride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FluorideAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FluorideAggregateArgs>(args: Subset<T, FluorideAggregateArgs>): PrismaPromise<GetFluorideAggregateType<T>>

    /**
     * Group by Fluoride.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FluorideGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FluorideGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FluorideGroupByArgs['orderBy'] }
        : { orderBy?: FluorideGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FluorideGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFluorideGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fluoride.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FluorideClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    minerals<T extends MineralFindManyArgs = {}>(args?: Subset<T, MineralFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mineral>>, PrismaPromise<Array<MineralGetPayload<T>>>>;

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Fluoride findUnique
   */
  export type FluorideFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Fluoride
     * 
    **/
    select?: FluorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FluorideInclude | null
    /**
     * Throw an Error if a Fluoride can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Fluoride to fetch.
     * 
    **/
    where: FluorideWhereUniqueInput
  }


  /**
   * Fluoride findFirst
   */
  export type FluorideFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Fluoride
     * 
    **/
    select?: FluorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FluorideInclude | null
    /**
     * Throw an Error if a Fluoride can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Fluoride to fetch.
     * 
    **/
    where?: FluorideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fluorides to fetch.
     * 
    **/
    orderBy?: Enumerable<FluorideOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fluorides.
     * 
    **/
    cursor?: FluorideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fluorides from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fluorides.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fluorides.
     * 
    **/
    distinct?: Enumerable<FluorideScalarFieldEnum>
  }


  /**
   * Fluoride findMany
   */
  export type FluorideFindManyArgs = {
    /**
     * Select specific fields to fetch from the Fluoride
     * 
    **/
    select?: FluorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FluorideInclude | null
    /**
     * Filter, which Fluorides to fetch.
     * 
    **/
    where?: FluorideWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fluorides to fetch.
     * 
    **/
    orderBy?: Enumerable<FluorideOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fluorides.
     * 
    **/
    cursor?: FluorideWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fluorides from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fluorides.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FluorideScalarFieldEnum>
  }


  /**
   * Fluoride create
   */
  export type FluorideCreateArgs = {
    /**
     * Select specific fields to fetch from the Fluoride
     * 
    **/
    select?: FluorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FluorideInclude | null
    /**
     * The data needed to create a Fluoride.
     * 
    **/
    data: XOR<FluorideCreateInput, FluorideUncheckedCreateInput>
  }


  /**
   * Fluoride createMany
   */
  export type FluorideCreateManyArgs = {
    /**
     * The data used to create many Fluorides.
     * 
    **/
    data: Enumerable<FluorideCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Fluoride update
   */
  export type FluorideUpdateArgs = {
    /**
     * Select specific fields to fetch from the Fluoride
     * 
    **/
    select?: FluorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FluorideInclude | null
    /**
     * The data needed to update a Fluoride.
     * 
    **/
    data: XOR<FluorideUpdateInput, FluorideUncheckedUpdateInput>
    /**
     * Choose, which Fluoride to update.
     * 
    **/
    where: FluorideWhereUniqueInput
  }


  /**
   * Fluoride updateMany
   */
  export type FluorideUpdateManyArgs = {
    /**
     * The data used to update Fluorides.
     * 
    **/
    data: XOR<FluorideUpdateManyMutationInput, FluorideUncheckedUpdateManyInput>
    /**
     * Filter which Fluorides to update
     * 
    **/
    where?: FluorideWhereInput
  }


  /**
   * Fluoride upsert
   */
  export type FluorideUpsertArgs = {
    /**
     * Select specific fields to fetch from the Fluoride
     * 
    **/
    select?: FluorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FluorideInclude | null
    /**
     * The filter to search for the Fluoride to update in case it exists.
     * 
    **/
    where: FluorideWhereUniqueInput
    /**
     * In case the Fluoride found by the `where` argument doesn't exist, create a new Fluoride with this data.
     * 
    **/
    create: XOR<FluorideCreateInput, FluorideUncheckedCreateInput>
    /**
     * In case the Fluoride was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FluorideUpdateInput, FluorideUncheckedUpdateInput>
  }


  /**
   * Fluoride delete
   */
  export type FluorideDeleteArgs = {
    /**
     * Select specific fields to fetch from the Fluoride
     * 
    **/
    select?: FluorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FluorideInclude | null
    /**
     * Filter which Fluoride to delete.
     * 
    **/
    where: FluorideWhereUniqueInput
  }


  /**
   * Fluoride deleteMany
   */
  export type FluorideDeleteManyArgs = {
    /**
     * Filter which Fluorides to delete
     * 
    **/
    where?: FluorideWhereInput
  }


  /**
   * Fluoride without action
   */
  export type FluorideArgs = {
    /**
     * Select specific fields to fetch from the Fluoride
     * 
    **/
    select?: FluorideSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FluorideInclude | null
  }



  /**
   * Model Phosphorous
   */


  export type AggregatePhosphorous = {
    _count: PhosphorousCountAggregateOutputType | null
    _avg: PhosphorousAvgAggregateOutputType | null
    _sum: PhosphorousSumAggregateOutputType | null
    _min: PhosphorousMinAggregateOutputType | null
    _max: PhosphorousMaxAggregateOutputType | null
  }

  export type PhosphorousAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type PhosphorousSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type PhosphorousMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type PhosphorousMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type PhosphorousCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type PhosphorousAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type PhosphorousSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type PhosphorousMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type PhosphorousMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type PhosphorousCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type PhosphorousAggregateArgs = {
    /**
     * Filter which Phosphorous to aggregate.
     * 
    **/
    where?: PhosphorousWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phosphorous to fetch.
     * 
    **/
    orderBy?: Enumerable<PhosphorousOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: PhosphorousWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phosphorous from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phosphorous.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Phosphorous
    **/
    _count?: true | PhosphorousCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhosphorousAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhosphorousSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhosphorousMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhosphorousMaxAggregateInputType
  }

  export type GetPhosphorousAggregateType<T extends PhosphorousAggregateArgs> = {
        [P in keyof T & keyof AggregatePhosphorous]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhosphorous[P]>
      : GetScalarType<T[P], AggregatePhosphorous[P]>
  }




  export type PhosphorousGroupByArgs = {
    where?: PhosphorousWhereInput
    orderBy?: Enumerable<PhosphorousOrderByWithAggregationInput>
    by: Array<PhosphorousScalarFieldEnum>
    having?: PhosphorousScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhosphorousCountAggregateInputType | true
    _avg?: PhosphorousAvgAggregateInputType
    _sum?: PhosphorousSumAggregateInputType
    _min?: PhosphorousMinAggregateInputType
    _max?: PhosphorousMaxAggregateInputType
  }


  export type PhosphorousGroupByOutputType = {
    id: number
    measurementId: number
    _count: PhosphorousCountAggregateOutputType | null
    _avg: PhosphorousAvgAggregateOutputType | null
    _sum: PhosphorousSumAggregateOutputType | null
    _min: PhosphorousMinAggregateOutputType | null
    _max: PhosphorousMaxAggregateOutputType | null
  }

  type GetPhosphorousGroupByPayload<T extends PhosphorousGroupByArgs> = PrismaPromise<
    Array<
      PickArray<PhosphorousGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhosphorousGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhosphorousGroupByOutputType[P]>
            : GetScalarType<T[P], PhosphorousGroupByOutputType[P]>
        }
      >
    >


  export type PhosphorousSelect = {
    id?: boolean
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    measurementId?: boolean
    _count?: boolean | PhosphorousCountOutputTypeArgs
  }

  export type PhosphorousInclude = {
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    _count?: boolean | PhosphorousCountOutputTypeArgs
  }

  export type PhosphorousGetPayload<
    S extends boolean | null | undefined | PhosphorousArgs,
    U = keyof S
      > = S extends true
        ? Phosphorous
    : S extends undefined
    ? never
    : S extends PhosphorousArgs | PhosphorousFindManyArgs
    ?'include' extends U
    ? Phosphorous  & {
    [P in TrueKeys<S['include']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['include'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends '_count' ? PhosphorousCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['select'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends '_count' ? PhosphorousCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Phosphorous ? Phosphorous[P] : never
  } 
    : Phosphorous
  : Phosphorous


  type PhosphorousCountArgs = Merge<
    Omit<PhosphorousFindManyArgs, 'select' | 'include'> & {
      select?: PhosphorousCountAggregateInputType | true
    }
  >

  export interface PhosphorousDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Phosphorous that matches the filter.
     * @param {PhosphorousFindUniqueArgs} args - Arguments to find a Phosphorous
     * @example
     * // Get one Phosphorous
     * const phosphorous = await prisma.phosphorous.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends PhosphorousFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, PhosphorousFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Phosphorous'> extends True ? CheckSelect<T, Prisma__PhosphorousClient<Phosphorous>, Prisma__PhosphorousClient<PhosphorousGetPayload<T>>> : CheckSelect<T, Prisma__PhosphorousClient<Phosphorous | null >, Prisma__PhosphorousClient<PhosphorousGetPayload<T> | null >>

    /**
     * Find the first Phosphorous that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhosphorousFindFirstArgs} args - Arguments to find a Phosphorous
     * @example
     * // Get one Phosphorous
     * const phosphorous = await prisma.phosphorous.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends PhosphorousFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, PhosphorousFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Phosphorous'> extends True ? CheckSelect<T, Prisma__PhosphorousClient<Phosphorous>, Prisma__PhosphorousClient<PhosphorousGetPayload<T>>> : CheckSelect<T, Prisma__PhosphorousClient<Phosphorous | null >, Prisma__PhosphorousClient<PhosphorousGetPayload<T> | null >>

    /**
     * Find zero or more Phosphorous that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhosphorousFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Phosphorous
     * const phosphorous = await prisma.phosphorous.findMany()
     * 
     * // Get first 10 Phosphorous
     * const phosphorous = await prisma.phosphorous.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phosphorousWithIdOnly = await prisma.phosphorous.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends PhosphorousFindManyArgs>(
      args?: SelectSubset<T, PhosphorousFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Phosphorous>>, PrismaPromise<Array<PhosphorousGetPayload<T>>>>

    /**
     * Create a Phosphorous.
     * @param {PhosphorousCreateArgs} args - Arguments to create a Phosphorous.
     * @example
     * // Create one Phosphorous
     * const Phosphorous = await prisma.phosphorous.create({
     *   data: {
     *     // ... data to create a Phosphorous
     *   }
     * })
     * 
    **/
    create<T extends PhosphorousCreateArgs>(
      args: SelectSubset<T, PhosphorousCreateArgs>
    ): CheckSelect<T, Prisma__PhosphorousClient<Phosphorous>, Prisma__PhosphorousClient<PhosphorousGetPayload<T>>>

    /**
     * Create many Phosphorous.
     *     @param {PhosphorousCreateManyArgs} args - Arguments to create many Phosphorous.
     *     @example
     *     // Create many Phosphorous
     *     const phosphorous = await prisma.phosphorous.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends PhosphorousCreateManyArgs>(
      args?: SelectSubset<T, PhosphorousCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Phosphorous.
     * @param {PhosphorousDeleteArgs} args - Arguments to delete one Phosphorous.
     * @example
     * // Delete one Phosphorous
     * const Phosphorous = await prisma.phosphorous.delete({
     *   where: {
     *     // ... filter to delete one Phosphorous
     *   }
     * })
     * 
    **/
    delete<T extends PhosphorousDeleteArgs>(
      args: SelectSubset<T, PhosphorousDeleteArgs>
    ): CheckSelect<T, Prisma__PhosphorousClient<Phosphorous>, Prisma__PhosphorousClient<PhosphorousGetPayload<T>>>

    /**
     * Update one Phosphorous.
     * @param {PhosphorousUpdateArgs} args - Arguments to update one Phosphorous.
     * @example
     * // Update one Phosphorous
     * const phosphorous = await prisma.phosphorous.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends PhosphorousUpdateArgs>(
      args: SelectSubset<T, PhosphorousUpdateArgs>
    ): CheckSelect<T, Prisma__PhosphorousClient<Phosphorous>, Prisma__PhosphorousClient<PhosphorousGetPayload<T>>>

    /**
     * Delete zero or more Phosphorous.
     * @param {PhosphorousDeleteManyArgs} args - Arguments to filter Phosphorous to delete.
     * @example
     * // Delete a few Phosphorous
     * const { count } = await prisma.phosphorous.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends PhosphorousDeleteManyArgs>(
      args?: SelectSubset<T, PhosphorousDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Phosphorous.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhosphorousUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Phosphorous
     * const phosphorous = await prisma.phosphorous.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends PhosphorousUpdateManyArgs>(
      args: SelectSubset<T, PhosphorousUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Phosphorous.
     * @param {PhosphorousUpsertArgs} args - Arguments to update or create a Phosphorous.
     * @example
     * // Update or create a Phosphorous
     * const phosphorous = await prisma.phosphorous.upsert({
     *   create: {
     *     // ... data to create a Phosphorous
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Phosphorous we want to update
     *   }
     * })
    **/
    upsert<T extends PhosphorousUpsertArgs>(
      args: SelectSubset<T, PhosphorousUpsertArgs>
    ): CheckSelect<T, Prisma__PhosphorousClient<Phosphorous>, Prisma__PhosphorousClient<PhosphorousGetPayload<T>>>

    /**
     * Count the number of Phosphorous.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhosphorousCountArgs} args - Arguments to filter Phosphorous to count.
     * @example
     * // Count the number of Phosphorous
     * const count = await prisma.phosphorous.count({
     *   where: {
     *     // ... the filter for the Phosphorous we want to count
     *   }
     * })
    **/
    count<T extends PhosphorousCountArgs>(
      args?: Subset<T, PhosphorousCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhosphorousCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Phosphorous.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhosphorousAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhosphorousAggregateArgs>(args: Subset<T, PhosphorousAggregateArgs>): PrismaPromise<GetPhosphorousAggregateType<T>>

    /**
     * Group by Phosphorous.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhosphorousGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhosphorousGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhosphorousGroupByArgs['orderBy'] }
        : { orderBy?: PhosphorousGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhosphorousGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhosphorousGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Phosphorous.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__PhosphorousClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    minerals<T extends MineralFindManyArgs = {}>(args?: Subset<T, MineralFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mineral>>, PrismaPromise<Array<MineralGetPayload<T>>>>;

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Phosphorous findUnique
   */
  export type PhosphorousFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Phosphorous
     * 
    **/
    select?: PhosphorousSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhosphorousInclude | null
    /**
     * Throw an Error if a Phosphorous can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Phosphorous to fetch.
     * 
    **/
    where: PhosphorousWhereUniqueInput
  }


  /**
   * Phosphorous findFirst
   */
  export type PhosphorousFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Phosphorous
     * 
    **/
    select?: PhosphorousSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhosphorousInclude | null
    /**
     * Throw an Error if a Phosphorous can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Phosphorous to fetch.
     * 
    **/
    where?: PhosphorousWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phosphorous to fetch.
     * 
    **/
    orderBy?: Enumerable<PhosphorousOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Phosphorous.
     * 
    **/
    cursor?: PhosphorousWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phosphorous from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phosphorous.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Phosphorous.
     * 
    **/
    distinct?: Enumerable<PhosphorousScalarFieldEnum>
  }


  /**
   * Phosphorous findMany
   */
  export type PhosphorousFindManyArgs = {
    /**
     * Select specific fields to fetch from the Phosphorous
     * 
    **/
    select?: PhosphorousSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhosphorousInclude | null
    /**
     * Filter, which Phosphorous to fetch.
     * 
    **/
    where?: PhosphorousWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Phosphorous to fetch.
     * 
    **/
    orderBy?: Enumerable<PhosphorousOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Phosphorous.
     * 
    **/
    cursor?: PhosphorousWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Phosphorous from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Phosphorous.
     * 
    **/
    skip?: number
    distinct?: Enumerable<PhosphorousScalarFieldEnum>
  }


  /**
   * Phosphorous create
   */
  export type PhosphorousCreateArgs = {
    /**
     * Select specific fields to fetch from the Phosphorous
     * 
    **/
    select?: PhosphorousSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhosphorousInclude | null
    /**
     * The data needed to create a Phosphorous.
     * 
    **/
    data: XOR<PhosphorousCreateInput, PhosphorousUncheckedCreateInput>
  }


  /**
   * Phosphorous createMany
   */
  export type PhosphorousCreateManyArgs = {
    /**
     * The data used to create many Phosphorous.
     * 
    **/
    data: Enumerable<PhosphorousCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Phosphorous update
   */
  export type PhosphorousUpdateArgs = {
    /**
     * Select specific fields to fetch from the Phosphorous
     * 
    **/
    select?: PhosphorousSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhosphorousInclude | null
    /**
     * The data needed to update a Phosphorous.
     * 
    **/
    data: XOR<PhosphorousUpdateInput, PhosphorousUncheckedUpdateInput>
    /**
     * Choose, which Phosphorous to update.
     * 
    **/
    where: PhosphorousWhereUniqueInput
  }


  /**
   * Phosphorous updateMany
   */
  export type PhosphorousUpdateManyArgs = {
    /**
     * The data used to update Phosphorous.
     * 
    **/
    data: XOR<PhosphorousUpdateManyMutationInput, PhosphorousUncheckedUpdateManyInput>
    /**
     * Filter which Phosphorous to update
     * 
    **/
    where?: PhosphorousWhereInput
  }


  /**
   * Phosphorous upsert
   */
  export type PhosphorousUpsertArgs = {
    /**
     * Select specific fields to fetch from the Phosphorous
     * 
    **/
    select?: PhosphorousSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhosphorousInclude | null
    /**
     * The filter to search for the Phosphorous to update in case it exists.
     * 
    **/
    where: PhosphorousWhereUniqueInput
    /**
     * In case the Phosphorous found by the `where` argument doesn't exist, create a new Phosphorous with this data.
     * 
    **/
    create: XOR<PhosphorousCreateInput, PhosphorousUncheckedCreateInput>
    /**
     * In case the Phosphorous was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<PhosphorousUpdateInput, PhosphorousUncheckedUpdateInput>
  }


  /**
   * Phosphorous delete
   */
  export type PhosphorousDeleteArgs = {
    /**
     * Select specific fields to fetch from the Phosphorous
     * 
    **/
    select?: PhosphorousSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhosphorousInclude | null
    /**
     * Filter which Phosphorous to delete.
     * 
    **/
    where: PhosphorousWhereUniqueInput
  }


  /**
   * Phosphorous deleteMany
   */
  export type PhosphorousDeleteManyArgs = {
    /**
     * Filter which Phosphorous to delete
     * 
    **/
    where?: PhosphorousWhereInput
  }


  /**
   * Phosphorous without action
   */
  export type PhosphorousArgs = {
    /**
     * Select specific fields to fetch from the Phosphorous
     * 
    **/
    select?: PhosphorousSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: PhosphorousInclude | null
  }



  /**
   * Model Copper
   */


  export type AggregateCopper = {
    _count: CopperCountAggregateOutputType | null
    _avg: CopperAvgAggregateOutputType | null
    _sum: CopperSumAggregateOutputType | null
    _min: CopperMinAggregateOutputType | null
    _max: CopperMaxAggregateOutputType | null
  }

  export type CopperAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type CopperSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type CopperMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type CopperMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type CopperCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type CopperAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type CopperSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type CopperMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type CopperMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type CopperCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type CopperAggregateArgs = {
    /**
     * Filter which Copper to aggregate.
     * 
    **/
    where?: CopperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coppers to fetch.
     * 
    **/
    orderBy?: Enumerable<CopperOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CopperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coppers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coppers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Coppers
    **/
    _count?: true | CopperCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CopperAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CopperSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CopperMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CopperMaxAggregateInputType
  }

  export type GetCopperAggregateType<T extends CopperAggregateArgs> = {
        [P in keyof T & keyof AggregateCopper]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCopper[P]>
      : GetScalarType<T[P], AggregateCopper[P]>
  }




  export type CopperGroupByArgs = {
    where?: CopperWhereInput
    orderBy?: Enumerable<CopperOrderByWithAggregationInput>
    by: Array<CopperScalarFieldEnum>
    having?: CopperScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CopperCountAggregateInputType | true
    _avg?: CopperAvgAggregateInputType
    _sum?: CopperSumAggregateInputType
    _min?: CopperMinAggregateInputType
    _max?: CopperMaxAggregateInputType
  }


  export type CopperGroupByOutputType = {
    id: number
    measurementId: number
    _count: CopperCountAggregateOutputType | null
    _avg: CopperAvgAggregateOutputType | null
    _sum: CopperSumAggregateOutputType | null
    _min: CopperMinAggregateOutputType | null
    _max: CopperMaxAggregateOutputType | null
  }

  type GetCopperGroupByPayload<T extends CopperGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CopperGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CopperGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CopperGroupByOutputType[P]>
            : GetScalarType<T[P], CopperGroupByOutputType[P]>
        }
      >
    >


  export type CopperSelect = {
    id?: boolean
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    measurementId?: boolean
    _count?: boolean | CopperCountOutputTypeArgs
  }

  export type CopperInclude = {
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    _count?: boolean | CopperCountOutputTypeArgs
  }

  export type CopperGetPayload<
    S extends boolean | null | undefined | CopperArgs,
    U = keyof S
      > = S extends true
        ? Copper
    : S extends undefined
    ? never
    : S extends CopperArgs | CopperFindManyArgs
    ?'include' extends U
    ? Copper  & {
    [P in TrueKeys<S['include']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['include'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends '_count' ? CopperCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['select'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends '_count' ? CopperCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Copper ? Copper[P] : never
  } 
    : Copper
  : Copper


  type CopperCountArgs = Merge<
    Omit<CopperFindManyArgs, 'select' | 'include'> & {
      select?: CopperCountAggregateInputType | true
    }
  >

  export interface CopperDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Copper that matches the filter.
     * @param {CopperFindUniqueArgs} args - Arguments to find a Copper
     * @example
     * // Get one Copper
     * const copper = await prisma.copper.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CopperFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CopperFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Copper'> extends True ? CheckSelect<T, Prisma__CopperClient<Copper>, Prisma__CopperClient<CopperGetPayload<T>>> : CheckSelect<T, Prisma__CopperClient<Copper | null >, Prisma__CopperClient<CopperGetPayload<T> | null >>

    /**
     * Find the first Copper that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CopperFindFirstArgs} args - Arguments to find a Copper
     * @example
     * // Get one Copper
     * const copper = await prisma.copper.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CopperFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CopperFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Copper'> extends True ? CheckSelect<T, Prisma__CopperClient<Copper>, Prisma__CopperClient<CopperGetPayload<T>>> : CheckSelect<T, Prisma__CopperClient<Copper | null >, Prisma__CopperClient<CopperGetPayload<T> | null >>

    /**
     * Find zero or more Coppers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CopperFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Coppers
     * const coppers = await prisma.copper.findMany()
     * 
     * // Get first 10 Coppers
     * const coppers = await prisma.copper.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const copperWithIdOnly = await prisma.copper.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CopperFindManyArgs>(
      args?: SelectSubset<T, CopperFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Copper>>, PrismaPromise<Array<CopperGetPayload<T>>>>

    /**
     * Create a Copper.
     * @param {CopperCreateArgs} args - Arguments to create a Copper.
     * @example
     * // Create one Copper
     * const Copper = await prisma.copper.create({
     *   data: {
     *     // ... data to create a Copper
     *   }
     * })
     * 
    **/
    create<T extends CopperCreateArgs>(
      args: SelectSubset<T, CopperCreateArgs>
    ): CheckSelect<T, Prisma__CopperClient<Copper>, Prisma__CopperClient<CopperGetPayload<T>>>

    /**
     * Create many Coppers.
     *     @param {CopperCreateManyArgs} args - Arguments to create many Coppers.
     *     @example
     *     // Create many Coppers
     *     const copper = await prisma.copper.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CopperCreateManyArgs>(
      args?: SelectSubset<T, CopperCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Copper.
     * @param {CopperDeleteArgs} args - Arguments to delete one Copper.
     * @example
     * // Delete one Copper
     * const Copper = await prisma.copper.delete({
     *   where: {
     *     // ... filter to delete one Copper
     *   }
     * })
     * 
    **/
    delete<T extends CopperDeleteArgs>(
      args: SelectSubset<T, CopperDeleteArgs>
    ): CheckSelect<T, Prisma__CopperClient<Copper>, Prisma__CopperClient<CopperGetPayload<T>>>

    /**
     * Update one Copper.
     * @param {CopperUpdateArgs} args - Arguments to update one Copper.
     * @example
     * // Update one Copper
     * const copper = await prisma.copper.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CopperUpdateArgs>(
      args: SelectSubset<T, CopperUpdateArgs>
    ): CheckSelect<T, Prisma__CopperClient<Copper>, Prisma__CopperClient<CopperGetPayload<T>>>

    /**
     * Delete zero or more Coppers.
     * @param {CopperDeleteManyArgs} args - Arguments to filter Coppers to delete.
     * @example
     * // Delete a few Coppers
     * const { count } = await prisma.copper.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CopperDeleteManyArgs>(
      args?: SelectSubset<T, CopperDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Coppers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CopperUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Coppers
     * const copper = await prisma.copper.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CopperUpdateManyArgs>(
      args: SelectSubset<T, CopperUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Copper.
     * @param {CopperUpsertArgs} args - Arguments to update or create a Copper.
     * @example
     * // Update or create a Copper
     * const copper = await prisma.copper.upsert({
     *   create: {
     *     // ... data to create a Copper
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Copper we want to update
     *   }
     * })
    **/
    upsert<T extends CopperUpsertArgs>(
      args: SelectSubset<T, CopperUpsertArgs>
    ): CheckSelect<T, Prisma__CopperClient<Copper>, Prisma__CopperClient<CopperGetPayload<T>>>

    /**
     * Count the number of Coppers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CopperCountArgs} args - Arguments to filter Coppers to count.
     * @example
     * // Count the number of Coppers
     * const count = await prisma.copper.count({
     *   where: {
     *     // ... the filter for the Coppers we want to count
     *   }
     * })
    **/
    count<T extends CopperCountArgs>(
      args?: Subset<T, CopperCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CopperCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Copper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CopperAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CopperAggregateArgs>(args: Subset<T, CopperAggregateArgs>): PrismaPromise<GetCopperAggregateType<T>>

    /**
     * Group by Copper.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CopperGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CopperGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CopperGroupByArgs['orderBy'] }
        : { orderBy?: CopperGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CopperGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCopperGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Copper.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CopperClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    minerals<T extends MineralFindManyArgs = {}>(args?: Subset<T, MineralFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mineral>>, PrismaPromise<Array<MineralGetPayload<T>>>>;

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Copper findUnique
   */
  export type CopperFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Copper
     * 
    **/
    select?: CopperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CopperInclude | null
    /**
     * Throw an Error if a Copper can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Copper to fetch.
     * 
    **/
    where: CopperWhereUniqueInput
  }


  /**
   * Copper findFirst
   */
  export type CopperFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Copper
     * 
    **/
    select?: CopperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CopperInclude | null
    /**
     * Throw an Error if a Copper can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Copper to fetch.
     * 
    **/
    where?: CopperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coppers to fetch.
     * 
    **/
    orderBy?: Enumerable<CopperOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Coppers.
     * 
    **/
    cursor?: CopperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coppers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coppers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Coppers.
     * 
    **/
    distinct?: Enumerable<CopperScalarFieldEnum>
  }


  /**
   * Copper findMany
   */
  export type CopperFindManyArgs = {
    /**
     * Select specific fields to fetch from the Copper
     * 
    **/
    select?: CopperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CopperInclude | null
    /**
     * Filter, which Coppers to fetch.
     * 
    **/
    where?: CopperWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Coppers to fetch.
     * 
    **/
    orderBy?: Enumerable<CopperOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Coppers.
     * 
    **/
    cursor?: CopperWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Coppers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Coppers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CopperScalarFieldEnum>
  }


  /**
   * Copper create
   */
  export type CopperCreateArgs = {
    /**
     * Select specific fields to fetch from the Copper
     * 
    **/
    select?: CopperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CopperInclude | null
    /**
     * The data needed to create a Copper.
     * 
    **/
    data: XOR<CopperCreateInput, CopperUncheckedCreateInput>
  }


  /**
   * Copper createMany
   */
  export type CopperCreateManyArgs = {
    /**
     * The data used to create many Coppers.
     * 
    **/
    data: Enumerable<CopperCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Copper update
   */
  export type CopperUpdateArgs = {
    /**
     * Select specific fields to fetch from the Copper
     * 
    **/
    select?: CopperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CopperInclude | null
    /**
     * The data needed to update a Copper.
     * 
    **/
    data: XOR<CopperUpdateInput, CopperUncheckedUpdateInput>
    /**
     * Choose, which Copper to update.
     * 
    **/
    where: CopperWhereUniqueInput
  }


  /**
   * Copper updateMany
   */
  export type CopperUpdateManyArgs = {
    /**
     * The data used to update Coppers.
     * 
    **/
    data: XOR<CopperUpdateManyMutationInput, CopperUncheckedUpdateManyInput>
    /**
     * Filter which Coppers to update
     * 
    **/
    where?: CopperWhereInput
  }


  /**
   * Copper upsert
   */
  export type CopperUpsertArgs = {
    /**
     * Select specific fields to fetch from the Copper
     * 
    **/
    select?: CopperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CopperInclude | null
    /**
     * The filter to search for the Copper to update in case it exists.
     * 
    **/
    where: CopperWhereUniqueInput
    /**
     * In case the Copper found by the `where` argument doesn't exist, create a new Copper with this data.
     * 
    **/
    create: XOR<CopperCreateInput, CopperUncheckedCreateInput>
    /**
     * In case the Copper was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CopperUpdateInput, CopperUncheckedUpdateInput>
  }


  /**
   * Copper delete
   */
  export type CopperDeleteArgs = {
    /**
     * Select specific fields to fetch from the Copper
     * 
    **/
    select?: CopperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CopperInclude | null
    /**
     * Filter which Copper to delete.
     * 
    **/
    where: CopperWhereUniqueInput
  }


  /**
   * Copper deleteMany
   */
  export type CopperDeleteManyArgs = {
    /**
     * Filter which Coppers to delete
     * 
    **/
    where?: CopperWhereInput
  }


  /**
   * Copper without action
   */
  export type CopperArgs = {
    /**
     * Select specific fields to fetch from the Copper
     * 
    **/
    select?: CopperSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CopperInclude | null
  }



  /**
   * Model Iodine
   */


  export type AggregateIodine = {
    _count: IodineCountAggregateOutputType | null
    _avg: IodineAvgAggregateOutputType | null
    _sum: IodineSumAggregateOutputType | null
    _min: IodineMinAggregateOutputType | null
    _max: IodineMaxAggregateOutputType | null
  }

  export type IodineAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type IodineSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type IodineMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type IodineMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type IodineCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type IodineAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type IodineSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type IodineMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type IodineMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type IodineCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type IodineAggregateArgs = {
    /**
     * Filter which Iodine to aggregate.
     * 
    **/
    where?: IodineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Iodines to fetch.
     * 
    **/
    orderBy?: Enumerable<IodineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: IodineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Iodines from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Iodines.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Iodines
    **/
    _count?: true | IodineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: IodineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: IodineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: IodineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: IodineMaxAggregateInputType
  }

  export type GetIodineAggregateType<T extends IodineAggregateArgs> = {
        [P in keyof T & keyof AggregateIodine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIodine[P]>
      : GetScalarType<T[P], AggregateIodine[P]>
  }




  export type IodineGroupByArgs = {
    where?: IodineWhereInput
    orderBy?: Enumerable<IodineOrderByWithAggregationInput>
    by: Array<IodineScalarFieldEnum>
    having?: IodineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: IodineCountAggregateInputType | true
    _avg?: IodineAvgAggregateInputType
    _sum?: IodineSumAggregateInputType
    _min?: IodineMinAggregateInputType
    _max?: IodineMaxAggregateInputType
  }


  export type IodineGroupByOutputType = {
    id: number
    measurementId: number
    _count: IodineCountAggregateOutputType | null
    _avg: IodineAvgAggregateOutputType | null
    _sum: IodineSumAggregateOutputType | null
    _min: IodineMinAggregateOutputType | null
    _max: IodineMaxAggregateOutputType | null
  }

  type GetIodineGroupByPayload<T extends IodineGroupByArgs> = PrismaPromise<
    Array<
      PickArray<IodineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof IodineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], IodineGroupByOutputType[P]>
            : GetScalarType<T[P], IodineGroupByOutputType[P]>
        }
      >
    >


  export type IodineSelect = {
    id?: boolean
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    measurementId?: boolean
    _count?: boolean | IodineCountOutputTypeArgs
  }

  export type IodineInclude = {
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    _count?: boolean | IodineCountOutputTypeArgs
  }

  export type IodineGetPayload<
    S extends boolean | null | undefined | IodineArgs,
    U = keyof S
      > = S extends true
        ? Iodine
    : S extends undefined
    ? never
    : S extends IodineArgs | IodineFindManyArgs
    ?'include' extends U
    ? Iodine  & {
    [P in TrueKeys<S['include']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['include'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends '_count' ? IodineCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['select'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends '_count' ? IodineCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Iodine ? Iodine[P] : never
  } 
    : Iodine
  : Iodine


  type IodineCountArgs = Merge<
    Omit<IodineFindManyArgs, 'select' | 'include'> & {
      select?: IodineCountAggregateInputType | true
    }
  >

  export interface IodineDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Iodine that matches the filter.
     * @param {IodineFindUniqueArgs} args - Arguments to find a Iodine
     * @example
     * // Get one Iodine
     * const iodine = await prisma.iodine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends IodineFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, IodineFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Iodine'> extends True ? CheckSelect<T, Prisma__IodineClient<Iodine>, Prisma__IodineClient<IodineGetPayload<T>>> : CheckSelect<T, Prisma__IodineClient<Iodine | null >, Prisma__IodineClient<IodineGetPayload<T> | null >>

    /**
     * Find the first Iodine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IodineFindFirstArgs} args - Arguments to find a Iodine
     * @example
     * // Get one Iodine
     * const iodine = await prisma.iodine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends IodineFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, IodineFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Iodine'> extends True ? CheckSelect<T, Prisma__IodineClient<Iodine>, Prisma__IodineClient<IodineGetPayload<T>>> : CheckSelect<T, Prisma__IodineClient<Iodine | null >, Prisma__IodineClient<IodineGetPayload<T> | null >>

    /**
     * Find zero or more Iodines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IodineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Iodines
     * const iodines = await prisma.iodine.findMany()
     * 
     * // Get first 10 Iodines
     * const iodines = await prisma.iodine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const iodineWithIdOnly = await prisma.iodine.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends IodineFindManyArgs>(
      args?: SelectSubset<T, IodineFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Iodine>>, PrismaPromise<Array<IodineGetPayload<T>>>>

    /**
     * Create a Iodine.
     * @param {IodineCreateArgs} args - Arguments to create a Iodine.
     * @example
     * // Create one Iodine
     * const Iodine = await prisma.iodine.create({
     *   data: {
     *     // ... data to create a Iodine
     *   }
     * })
     * 
    **/
    create<T extends IodineCreateArgs>(
      args: SelectSubset<T, IodineCreateArgs>
    ): CheckSelect<T, Prisma__IodineClient<Iodine>, Prisma__IodineClient<IodineGetPayload<T>>>

    /**
     * Create many Iodines.
     *     @param {IodineCreateManyArgs} args - Arguments to create many Iodines.
     *     @example
     *     // Create many Iodines
     *     const iodine = await prisma.iodine.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends IodineCreateManyArgs>(
      args?: SelectSubset<T, IodineCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Iodine.
     * @param {IodineDeleteArgs} args - Arguments to delete one Iodine.
     * @example
     * // Delete one Iodine
     * const Iodine = await prisma.iodine.delete({
     *   where: {
     *     // ... filter to delete one Iodine
     *   }
     * })
     * 
    **/
    delete<T extends IodineDeleteArgs>(
      args: SelectSubset<T, IodineDeleteArgs>
    ): CheckSelect<T, Prisma__IodineClient<Iodine>, Prisma__IodineClient<IodineGetPayload<T>>>

    /**
     * Update one Iodine.
     * @param {IodineUpdateArgs} args - Arguments to update one Iodine.
     * @example
     * // Update one Iodine
     * const iodine = await prisma.iodine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends IodineUpdateArgs>(
      args: SelectSubset<T, IodineUpdateArgs>
    ): CheckSelect<T, Prisma__IodineClient<Iodine>, Prisma__IodineClient<IodineGetPayload<T>>>

    /**
     * Delete zero or more Iodines.
     * @param {IodineDeleteManyArgs} args - Arguments to filter Iodines to delete.
     * @example
     * // Delete a few Iodines
     * const { count } = await prisma.iodine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends IodineDeleteManyArgs>(
      args?: SelectSubset<T, IodineDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Iodines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IodineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Iodines
     * const iodine = await prisma.iodine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends IodineUpdateManyArgs>(
      args: SelectSubset<T, IodineUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Iodine.
     * @param {IodineUpsertArgs} args - Arguments to update or create a Iodine.
     * @example
     * // Update or create a Iodine
     * const iodine = await prisma.iodine.upsert({
     *   create: {
     *     // ... data to create a Iodine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Iodine we want to update
     *   }
     * })
    **/
    upsert<T extends IodineUpsertArgs>(
      args: SelectSubset<T, IodineUpsertArgs>
    ): CheckSelect<T, Prisma__IodineClient<Iodine>, Prisma__IodineClient<IodineGetPayload<T>>>

    /**
     * Count the number of Iodines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IodineCountArgs} args - Arguments to filter Iodines to count.
     * @example
     * // Count the number of Iodines
     * const count = await prisma.iodine.count({
     *   where: {
     *     // ... the filter for the Iodines we want to count
     *   }
     * })
    **/
    count<T extends IodineCountArgs>(
      args?: Subset<T, IodineCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], IodineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Iodine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IodineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends IodineAggregateArgs>(args: Subset<T, IodineAggregateArgs>): PrismaPromise<GetIodineAggregateType<T>>

    /**
     * Group by Iodine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {IodineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends IodineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: IodineGroupByArgs['orderBy'] }
        : { orderBy?: IodineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, IodineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIodineGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Iodine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__IodineClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    minerals<T extends MineralFindManyArgs = {}>(args?: Subset<T, MineralFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mineral>>, PrismaPromise<Array<MineralGetPayload<T>>>>;

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Iodine findUnique
   */
  export type IodineFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Iodine
     * 
    **/
    select?: IodineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IodineInclude | null
    /**
     * Throw an Error if a Iodine can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Iodine to fetch.
     * 
    **/
    where: IodineWhereUniqueInput
  }


  /**
   * Iodine findFirst
   */
  export type IodineFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Iodine
     * 
    **/
    select?: IodineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IodineInclude | null
    /**
     * Throw an Error if a Iodine can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Iodine to fetch.
     * 
    **/
    where?: IodineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Iodines to fetch.
     * 
    **/
    orderBy?: Enumerable<IodineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Iodines.
     * 
    **/
    cursor?: IodineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Iodines from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Iodines.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Iodines.
     * 
    **/
    distinct?: Enumerable<IodineScalarFieldEnum>
  }


  /**
   * Iodine findMany
   */
  export type IodineFindManyArgs = {
    /**
     * Select specific fields to fetch from the Iodine
     * 
    **/
    select?: IodineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IodineInclude | null
    /**
     * Filter, which Iodines to fetch.
     * 
    **/
    where?: IodineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Iodines to fetch.
     * 
    **/
    orderBy?: Enumerable<IodineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Iodines.
     * 
    **/
    cursor?: IodineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Iodines from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Iodines.
     * 
    **/
    skip?: number
    distinct?: Enumerable<IodineScalarFieldEnum>
  }


  /**
   * Iodine create
   */
  export type IodineCreateArgs = {
    /**
     * Select specific fields to fetch from the Iodine
     * 
    **/
    select?: IodineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IodineInclude | null
    /**
     * The data needed to create a Iodine.
     * 
    **/
    data: XOR<IodineCreateInput, IodineUncheckedCreateInput>
  }


  /**
   * Iodine createMany
   */
  export type IodineCreateManyArgs = {
    /**
     * The data used to create many Iodines.
     * 
    **/
    data: Enumerable<IodineCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Iodine update
   */
  export type IodineUpdateArgs = {
    /**
     * Select specific fields to fetch from the Iodine
     * 
    **/
    select?: IodineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IodineInclude | null
    /**
     * The data needed to update a Iodine.
     * 
    **/
    data: XOR<IodineUpdateInput, IodineUncheckedUpdateInput>
    /**
     * Choose, which Iodine to update.
     * 
    **/
    where: IodineWhereUniqueInput
  }


  /**
   * Iodine updateMany
   */
  export type IodineUpdateManyArgs = {
    /**
     * The data used to update Iodines.
     * 
    **/
    data: XOR<IodineUpdateManyMutationInput, IodineUncheckedUpdateManyInput>
    /**
     * Filter which Iodines to update
     * 
    **/
    where?: IodineWhereInput
  }


  /**
   * Iodine upsert
   */
  export type IodineUpsertArgs = {
    /**
     * Select specific fields to fetch from the Iodine
     * 
    **/
    select?: IodineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IodineInclude | null
    /**
     * The filter to search for the Iodine to update in case it exists.
     * 
    **/
    where: IodineWhereUniqueInput
    /**
     * In case the Iodine found by the `where` argument doesn't exist, create a new Iodine with this data.
     * 
    **/
    create: XOR<IodineCreateInput, IodineUncheckedCreateInput>
    /**
     * In case the Iodine was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<IodineUpdateInput, IodineUncheckedUpdateInput>
  }


  /**
   * Iodine delete
   */
  export type IodineDeleteArgs = {
    /**
     * Select specific fields to fetch from the Iodine
     * 
    **/
    select?: IodineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IodineInclude | null
    /**
     * Filter which Iodine to delete.
     * 
    **/
    where: IodineWhereUniqueInput
  }


  /**
   * Iodine deleteMany
   */
  export type IodineDeleteManyArgs = {
    /**
     * Filter which Iodines to delete
     * 
    **/
    where?: IodineWhereInput
  }


  /**
   * Iodine without action
   */
  export type IodineArgs = {
    /**
     * Select specific fields to fetch from the Iodine
     * 
    **/
    select?: IodineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: IodineInclude | null
  }



  /**
   * Model Calcium
   */


  export type AggregateCalcium = {
    _count: CalciumCountAggregateOutputType | null
    _avg: CalciumAvgAggregateOutputType | null
    _sum: CalciumSumAggregateOutputType | null
    _min: CalciumMinAggregateOutputType | null
    _max: CalciumMaxAggregateOutputType | null
  }

  export type CalciumAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type CalciumSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type CalciumMinAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type CalciumMaxAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type CalciumCountAggregateOutputType = {
    id: number
    measurementId: number
    _all: number
  }


  export type CalciumAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type CalciumSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type CalciumMinAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type CalciumMaxAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type CalciumCountAggregateInputType = {
    id?: true
    measurementId?: true
    _all?: true
  }

  export type CalciumAggregateArgs = {
    /**
     * Filter which Calcium to aggregate.
     * 
    **/
    where?: CalciumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calciums to fetch.
     * 
    **/
    orderBy?: Enumerable<CalciumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CalciumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calciums from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calciums.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Calciums
    **/
    _count?: true | CalciumCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CalciumAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CalciumSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CalciumMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CalciumMaxAggregateInputType
  }

  export type GetCalciumAggregateType<T extends CalciumAggregateArgs> = {
        [P in keyof T & keyof AggregateCalcium]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCalcium[P]>
      : GetScalarType<T[P], AggregateCalcium[P]>
  }




  export type CalciumGroupByArgs = {
    where?: CalciumWhereInput
    orderBy?: Enumerable<CalciumOrderByWithAggregationInput>
    by: Array<CalciumScalarFieldEnum>
    having?: CalciumScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CalciumCountAggregateInputType | true
    _avg?: CalciumAvgAggregateInputType
    _sum?: CalciumSumAggregateInputType
    _min?: CalciumMinAggregateInputType
    _max?: CalciumMaxAggregateInputType
  }


  export type CalciumGroupByOutputType = {
    id: number
    measurementId: number
    _count: CalciumCountAggregateOutputType | null
    _avg: CalciumAvgAggregateOutputType | null
    _sum: CalciumSumAggregateOutputType | null
    _min: CalciumMinAggregateOutputType | null
    _max: CalciumMaxAggregateOutputType | null
  }

  type GetCalciumGroupByPayload<T extends CalciumGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CalciumGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CalciumGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CalciumGroupByOutputType[P]>
            : GetScalarType<T[P], CalciumGroupByOutputType[P]>
        }
      >
    >


  export type CalciumSelect = {
    id?: boolean
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    measurementId?: boolean
    _count?: boolean | CalciumCountOutputTypeArgs
  }

  export type CalciumInclude = {
    minerals?: boolean | MineralFindManyArgs
    measurement?: boolean | MeasurementArgs
    _count?: boolean | CalciumCountOutputTypeArgs
  }

  export type CalciumGetPayload<
    S extends boolean | null | undefined | CalciumArgs,
    U = keyof S
      > = S extends true
        ? Calcium
    : S extends undefined
    ? never
    : S extends CalciumArgs | CalciumFindManyArgs
    ?'include' extends U
    ? Calcium  & {
    [P in TrueKeys<S['include']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['include'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends '_count' ? CalciumCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'minerals' ? Array < MineralGetPayload<S['select'][P]>>  :
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends '_count' ? CalciumCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Calcium ? Calcium[P] : never
  } 
    : Calcium
  : Calcium


  type CalciumCountArgs = Merge<
    Omit<CalciumFindManyArgs, 'select' | 'include'> & {
      select?: CalciumCountAggregateInputType | true
    }
  >

  export interface CalciumDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Calcium that matches the filter.
     * @param {CalciumFindUniqueArgs} args - Arguments to find a Calcium
     * @example
     * // Get one Calcium
     * const calcium = await prisma.calcium.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CalciumFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CalciumFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Calcium'> extends True ? CheckSelect<T, Prisma__CalciumClient<Calcium>, Prisma__CalciumClient<CalciumGetPayload<T>>> : CheckSelect<T, Prisma__CalciumClient<Calcium | null >, Prisma__CalciumClient<CalciumGetPayload<T> | null >>

    /**
     * Find the first Calcium that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalciumFindFirstArgs} args - Arguments to find a Calcium
     * @example
     * // Get one Calcium
     * const calcium = await prisma.calcium.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CalciumFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CalciumFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Calcium'> extends True ? CheckSelect<T, Prisma__CalciumClient<Calcium>, Prisma__CalciumClient<CalciumGetPayload<T>>> : CheckSelect<T, Prisma__CalciumClient<Calcium | null >, Prisma__CalciumClient<CalciumGetPayload<T> | null >>

    /**
     * Find zero or more Calciums that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalciumFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Calciums
     * const calciums = await prisma.calcium.findMany()
     * 
     * // Get first 10 Calciums
     * const calciums = await prisma.calcium.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const calciumWithIdOnly = await prisma.calcium.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CalciumFindManyArgs>(
      args?: SelectSubset<T, CalciumFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Calcium>>, PrismaPromise<Array<CalciumGetPayload<T>>>>

    /**
     * Create a Calcium.
     * @param {CalciumCreateArgs} args - Arguments to create a Calcium.
     * @example
     * // Create one Calcium
     * const Calcium = await prisma.calcium.create({
     *   data: {
     *     // ... data to create a Calcium
     *   }
     * })
     * 
    **/
    create<T extends CalciumCreateArgs>(
      args: SelectSubset<T, CalciumCreateArgs>
    ): CheckSelect<T, Prisma__CalciumClient<Calcium>, Prisma__CalciumClient<CalciumGetPayload<T>>>

    /**
     * Create many Calciums.
     *     @param {CalciumCreateManyArgs} args - Arguments to create many Calciums.
     *     @example
     *     // Create many Calciums
     *     const calcium = await prisma.calcium.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CalciumCreateManyArgs>(
      args?: SelectSubset<T, CalciumCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Calcium.
     * @param {CalciumDeleteArgs} args - Arguments to delete one Calcium.
     * @example
     * // Delete one Calcium
     * const Calcium = await prisma.calcium.delete({
     *   where: {
     *     // ... filter to delete one Calcium
     *   }
     * })
     * 
    **/
    delete<T extends CalciumDeleteArgs>(
      args: SelectSubset<T, CalciumDeleteArgs>
    ): CheckSelect<T, Prisma__CalciumClient<Calcium>, Prisma__CalciumClient<CalciumGetPayload<T>>>

    /**
     * Update one Calcium.
     * @param {CalciumUpdateArgs} args - Arguments to update one Calcium.
     * @example
     * // Update one Calcium
     * const calcium = await prisma.calcium.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CalciumUpdateArgs>(
      args: SelectSubset<T, CalciumUpdateArgs>
    ): CheckSelect<T, Prisma__CalciumClient<Calcium>, Prisma__CalciumClient<CalciumGetPayload<T>>>

    /**
     * Delete zero or more Calciums.
     * @param {CalciumDeleteManyArgs} args - Arguments to filter Calciums to delete.
     * @example
     * // Delete a few Calciums
     * const { count } = await prisma.calcium.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CalciumDeleteManyArgs>(
      args?: SelectSubset<T, CalciumDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Calciums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalciumUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Calciums
     * const calcium = await prisma.calcium.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CalciumUpdateManyArgs>(
      args: SelectSubset<T, CalciumUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Calcium.
     * @param {CalciumUpsertArgs} args - Arguments to update or create a Calcium.
     * @example
     * // Update or create a Calcium
     * const calcium = await prisma.calcium.upsert({
     *   create: {
     *     // ... data to create a Calcium
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Calcium we want to update
     *   }
     * })
    **/
    upsert<T extends CalciumUpsertArgs>(
      args: SelectSubset<T, CalciumUpsertArgs>
    ): CheckSelect<T, Prisma__CalciumClient<Calcium>, Prisma__CalciumClient<CalciumGetPayload<T>>>

    /**
     * Count the number of Calciums.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalciumCountArgs} args - Arguments to filter Calciums to count.
     * @example
     * // Count the number of Calciums
     * const count = await prisma.calcium.count({
     *   where: {
     *     // ... the filter for the Calciums we want to count
     *   }
     * })
    **/
    count<T extends CalciumCountArgs>(
      args?: Subset<T, CalciumCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CalciumCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Calcium.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalciumAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CalciumAggregateArgs>(args: Subset<T, CalciumAggregateArgs>): PrismaPromise<GetCalciumAggregateType<T>>

    /**
     * Group by Calcium.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CalciumGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CalciumGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CalciumGroupByArgs['orderBy'] }
        : { orderBy?: CalciumGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CalciumGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCalciumGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Calcium.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CalciumClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    minerals<T extends MineralFindManyArgs = {}>(args?: Subset<T, MineralFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Mineral>>, PrismaPromise<Array<MineralGetPayload<T>>>>;

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Calcium findUnique
   */
  export type CalciumFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Calcium
     * 
    **/
    select?: CalciumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CalciumInclude | null
    /**
     * Throw an Error if a Calcium can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Calcium to fetch.
     * 
    **/
    where: CalciumWhereUniqueInput
  }


  /**
   * Calcium findFirst
   */
  export type CalciumFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Calcium
     * 
    **/
    select?: CalciumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CalciumInclude | null
    /**
     * Throw an Error if a Calcium can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Calcium to fetch.
     * 
    **/
    where?: CalciumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calciums to fetch.
     * 
    **/
    orderBy?: Enumerable<CalciumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Calciums.
     * 
    **/
    cursor?: CalciumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calciums from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calciums.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Calciums.
     * 
    **/
    distinct?: Enumerable<CalciumScalarFieldEnum>
  }


  /**
   * Calcium findMany
   */
  export type CalciumFindManyArgs = {
    /**
     * Select specific fields to fetch from the Calcium
     * 
    **/
    select?: CalciumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CalciumInclude | null
    /**
     * Filter, which Calciums to fetch.
     * 
    **/
    where?: CalciumWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Calciums to fetch.
     * 
    **/
    orderBy?: Enumerable<CalciumOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Calciums.
     * 
    **/
    cursor?: CalciumWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Calciums from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Calciums.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CalciumScalarFieldEnum>
  }


  /**
   * Calcium create
   */
  export type CalciumCreateArgs = {
    /**
     * Select specific fields to fetch from the Calcium
     * 
    **/
    select?: CalciumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CalciumInclude | null
    /**
     * The data needed to create a Calcium.
     * 
    **/
    data: XOR<CalciumCreateInput, CalciumUncheckedCreateInput>
  }


  /**
   * Calcium createMany
   */
  export type CalciumCreateManyArgs = {
    /**
     * The data used to create many Calciums.
     * 
    **/
    data: Enumerable<CalciumCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Calcium update
   */
  export type CalciumUpdateArgs = {
    /**
     * Select specific fields to fetch from the Calcium
     * 
    **/
    select?: CalciumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CalciumInclude | null
    /**
     * The data needed to update a Calcium.
     * 
    **/
    data: XOR<CalciumUpdateInput, CalciumUncheckedUpdateInput>
    /**
     * Choose, which Calcium to update.
     * 
    **/
    where: CalciumWhereUniqueInput
  }


  /**
   * Calcium updateMany
   */
  export type CalciumUpdateManyArgs = {
    /**
     * The data used to update Calciums.
     * 
    **/
    data: XOR<CalciumUpdateManyMutationInput, CalciumUncheckedUpdateManyInput>
    /**
     * Filter which Calciums to update
     * 
    **/
    where?: CalciumWhereInput
  }


  /**
   * Calcium upsert
   */
  export type CalciumUpsertArgs = {
    /**
     * Select specific fields to fetch from the Calcium
     * 
    **/
    select?: CalciumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CalciumInclude | null
    /**
     * The filter to search for the Calcium to update in case it exists.
     * 
    **/
    where: CalciumWhereUniqueInput
    /**
     * In case the Calcium found by the `where` argument doesn't exist, create a new Calcium with this data.
     * 
    **/
    create: XOR<CalciumCreateInput, CalciumUncheckedCreateInput>
    /**
     * In case the Calcium was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CalciumUpdateInput, CalciumUncheckedUpdateInput>
  }


  /**
   * Calcium delete
   */
  export type CalciumDeleteArgs = {
    /**
     * Select specific fields to fetch from the Calcium
     * 
    **/
    select?: CalciumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CalciumInclude | null
    /**
     * Filter which Calcium to delete.
     * 
    **/
    where: CalciumWhereUniqueInput
  }


  /**
   * Calcium deleteMany
   */
  export type CalciumDeleteManyArgs = {
    /**
     * Filter which Calciums to delete
     * 
    **/
    where?: CalciumWhereInput
  }


  /**
   * Calcium without action
   */
  export type CalciumArgs = {
    /**
     * Select specific fields to fetch from the Calcium
     * 
    **/
    select?: CalciumSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CalciumInclude | null
  }



  /**
   * Model Mineral
   */


  export type AggregateMineral = {
    _count: MineralCountAggregateOutputType | null
    _avg: MineralAvgAggregateOutputType | null
    _sum: MineralSumAggregateOutputType | null
    _min: MineralMinAggregateOutputType | null
    _max: MineralMaxAggregateOutputType | null
  }

  export type MineralAvgAggregateOutputType = {
    id: number | null
    saltId: number | null
    ironId: number | null
    zincId: number | null
    magnesiumId: number | null
    chlorideId: number | null
    manganeseId: number | null
    sulfurId: number | null
    potassiumId: number | null
    fluorideId: number | null
    phosphorousId: number | null
    copperId: number | null
    iodineId: number | null
    calciumId: number | null
  }

  export type MineralSumAggregateOutputType = {
    id: number | null
    saltId: number | null
    ironId: number | null
    zincId: number | null
    magnesiumId: number | null
    chlorideId: number | null
    manganeseId: number | null
    sulfurId: number | null
    potassiumId: number | null
    fluorideId: number | null
    phosphorousId: number | null
    copperId: number | null
    iodineId: number | null
    calciumId: number | null
  }

  export type MineralMinAggregateOutputType = {
    id: number | null
    saltId: number | null
    ironId: number | null
    zincId: number | null
    magnesiumId: number | null
    chlorideId: number | null
    manganeseId: number | null
    sulfurId: number | null
    potassiumId: number | null
    fluorideId: number | null
    phosphorousId: number | null
    copperId: number | null
    iodineId: number | null
    calciumId: number | null
  }

  export type MineralMaxAggregateOutputType = {
    id: number | null
    saltId: number | null
    ironId: number | null
    zincId: number | null
    magnesiumId: number | null
    chlorideId: number | null
    manganeseId: number | null
    sulfurId: number | null
    potassiumId: number | null
    fluorideId: number | null
    phosphorousId: number | null
    copperId: number | null
    iodineId: number | null
    calciumId: number | null
  }

  export type MineralCountAggregateOutputType = {
    id: number
    saltId: number
    ironId: number
    zincId: number
    magnesiumId: number
    chlorideId: number
    manganeseId: number
    sulfurId: number
    potassiumId: number
    fluorideId: number
    phosphorousId: number
    copperId: number
    iodineId: number
    calciumId: number
    _all: number
  }


  export type MineralAvgAggregateInputType = {
    id?: true
    saltId?: true
    ironId?: true
    zincId?: true
    magnesiumId?: true
    chlorideId?: true
    manganeseId?: true
    sulfurId?: true
    potassiumId?: true
    fluorideId?: true
    phosphorousId?: true
    copperId?: true
    iodineId?: true
    calciumId?: true
  }

  export type MineralSumAggregateInputType = {
    id?: true
    saltId?: true
    ironId?: true
    zincId?: true
    magnesiumId?: true
    chlorideId?: true
    manganeseId?: true
    sulfurId?: true
    potassiumId?: true
    fluorideId?: true
    phosphorousId?: true
    copperId?: true
    iodineId?: true
    calciumId?: true
  }

  export type MineralMinAggregateInputType = {
    id?: true
    saltId?: true
    ironId?: true
    zincId?: true
    magnesiumId?: true
    chlorideId?: true
    manganeseId?: true
    sulfurId?: true
    potassiumId?: true
    fluorideId?: true
    phosphorousId?: true
    copperId?: true
    iodineId?: true
    calciumId?: true
  }

  export type MineralMaxAggregateInputType = {
    id?: true
    saltId?: true
    ironId?: true
    zincId?: true
    magnesiumId?: true
    chlorideId?: true
    manganeseId?: true
    sulfurId?: true
    potassiumId?: true
    fluorideId?: true
    phosphorousId?: true
    copperId?: true
    iodineId?: true
    calciumId?: true
  }

  export type MineralCountAggregateInputType = {
    id?: true
    saltId?: true
    ironId?: true
    zincId?: true
    magnesiumId?: true
    chlorideId?: true
    manganeseId?: true
    sulfurId?: true
    potassiumId?: true
    fluorideId?: true
    phosphorousId?: true
    copperId?: true
    iodineId?: true
    calciumId?: true
    _all?: true
  }

  export type MineralAggregateArgs = {
    /**
     * Filter which Mineral to aggregate.
     * 
    **/
    where?: MineralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Minerals to fetch.
     * 
    **/
    orderBy?: Enumerable<MineralOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MineralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Minerals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Minerals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Minerals
    **/
    _count?: true | MineralCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MineralAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MineralSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MineralMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MineralMaxAggregateInputType
  }

  export type GetMineralAggregateType<T extends MineralAggregateArgs> = {
        [P in keyof T & keyof AggregateMineral]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMineral[P]>
      : GetScalarType<T[P], AggregateMineral[P]>
  }




  export type MineralGroupByArgs = {
    where?: MineralWhereInput
    orderBy?: Enumerable<MineralOrderByWithAggregationInput>
    by: Array<MineralScalarFieldEnum>
    having?: MineralScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MineralCountAggregateInputType | true
    _avg?: MineralAvgAggregateInputType
    _sum?: MineralSumAggregateInputType
    _min?: MineralMinAggregateInputType
    _max?: MineralMaxAggregateInputType
  }


  export type MineralGroupByOutputType = {
    id: number
    saltId: number | null
    ironId: number | null
    zincId: number | null
    magnesiumId: number | null
    chlorideId: number | null
    manganeseId: number | null
    sulfurId: number | null
    potassiumId: number | null
    fluorideId: number | null
    phosphorousId: number | null
    copperId: number | null
    iodineId: number | null
    calciumId: number | null
    _count: MineralCountAggregateOutputType | null
    _avg: MineralAvgAggregateOutputType | null
    _sum: MineralSumAggregateOutputType | null
    _min: MineralMinAggregateOutputType | null
    _max: MineralMaxAggregateOutputType | null
  }

  type GetMineralGroupByPayload<T extends MineralGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MineralGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MineralGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MineralGroupByOutputType[P]>
            : GetScalarType<T[P], MineralGroupByOutputType[P]>
        }
      >
    >


  export type MineralSelect = {
    id?: boolean
    salt?: boolean | SaltArgs
    saltId?: boolean
    nutritionFact?: boolean | NutritionFactFindManyArgs
    iron?: boolean | IronArgs
    ironId?: boolean
    zinc?: boolean | ZincArgs
    zincId?: boolean
    magnesium?: boolean | MagnesiumArgs
    magnesiumId?: boolean
    chloride?: boolean | ChlorideArgs
    chlorideId?: boolean
    manganese?: boolean | ManganeseArgs
    manganeseId?: boolean
    sulfur?: boolean | SulfurArgs
    sulfurId?: boolean
    potassium?: boolean | PotassiumArgs
    potassiumId?: boolean
    fluoride?: boolean | FluorideArgs
    fluorideId?: boolean
    phosphorous?: boolean | PhosphorousArgs
    phosphorousId?: boolean
    copper?: boolean | CopperArgs
    copperId?: boolean
    iodine?: boolean | IodineArgs
    iodineId?: boolean
    calcium?: boolean | CalciumArgs
    calciumId?: boolean
    _count?: boolean | MineralCountOutputTypeArgs
  }

  export type MineralInclude = {
    salt?: boolean | SaltArgs
    nutritionFact?: boolean | NutritionFactFindManyArgs
    iron?: boolean | IronArgs
    zinc?: boolean | ZincArgs
    magnesium?: boolean | MagnesiumArgs
    chloride?: boolean | ChlorideArgs
    manganese?: boolean | ManganeseArgs
    sulfur?: boolean | SulfurArgs
    potassium?: boolean | PotassiumArgs
    fluoride?: boolean | FluorideArgs
    phosphorous?: boolean | PhosphorousArgs
    copper?: boolean | CopperArgs
    iodine?: boolean | IodineArgs
    calcium?: boolean | CalciumArgs
    _count?: boolean | MineralCountOutputTypeArgs
  }

  export type MineralGetPayload<
    S extends boolean | null | undefined | MineralArgs,
    U = keyof S
      > = S extends true
        ? Mineral
    : S extends undefined
    ? never
    : S extends MineralArgs | MineralFindManyArgs
    ?'include' extends U
    ? Mineral  & {
    [P in TrueKeys<S['include']>]:
        P extends 'salt' ? SaltGetPayload<S['include'][P]> | null :
        P extends 'nutritionFact' ? Array < NutritionFactGetPayload<S['include'][P]>>  :
        P extends 'iron' ? IronGetPayload<S['include'][P]> | null :
        P extends 'zinc' ? ZincGetPayload<S['include'][P]> | null :
        P extends 'magnesium' ? MagnesiumGetPayload<S['include'][P]> | null :
        P extends 'chloride' ? ChlorideGetPayload<S['include'][P]> | null :
        P extends 'manganese' ? ManganeseGetPayload<S['include'][P]> | null :
        P extends 'sulfur' ? SulfurGetPayload<S['include'][P]> | null :
        P extends 'potassium' ? PotassiumGetPayload<S['include'][P]> | null :
        P extends 'fluoride' ? FluorideGetPayload<S['include'][P]> | null :
        P extends 'phosphorous' ? PhosphorousGetPayload<S['include'][P]> | null :
        P extends 'copper' ? CopperGetPayload<S['include'][P]> | null :
        P extends 'iodine' ? IodineGetPayload<S['include'][P]> | null :
        P extends 'calcium' ? CalciumGetPayload<S['include'][P]> | null :
        P extends '_count' ? MineralCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'salt' ? SaltGetPayload<S['select'][P]> | null :
        P extends 'nutritionFact' ? Array < NutritionFactGetPayload<S['select'][P]>>  :
        P extends 'iron' ? IronGetPayload<S['select'][P]> | null :
        P extends 'zinc' ? ZincGetPayload<S['select'][P]> | null :
        P extends 'magnesium' ? MagnesiumGetPayload<S['select'][P]> | null :
        P extends 'chloride' ? ChlorideGetPayload<S['select'][P]> | null :
        P extends 'manganese' ? ManganeseGetPayload<S['select'][P]> | null :
        P extends 'sulfur' ? SulfurGetPayload<S['select'][P]> | null :
        P extends 'potassium' ? PotassiumGetPayload<S['select'][P]> | null :
        P extends 'fluoride' ? FluorideGetPayload<S['select'][P]> | null :
        P extends 'phosphorous' ? PhosphorousGetPayload<S['select'][P]> | null :
        P extends 'copper' ? CopperGetPayload<S['select'][P]> | null :
        P extends 'iodine' ? IodineGetPayload<S['select'][P]> | null :
        P extends 'calcium' ? CalciumGetPayload<S['select'][P]> | null :
        P extends '_count' ? MineralCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Mineral ? Mineral[P] : never
  } 
    : Mineral
  : Mineral


  type MineralCountArgs = Merge<
    Omit<MineralFindManyArgs, 'select' | 'include'> & {
      select?: MineralCountAggregateInputType | true
    }
  >

  export interface MineralDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Mineral that matches the filter.
     * @param {MineralFindUniqueArgs} args - Arguments to find a Mineral
     * @example
     * // Get one Mineral
     * const mineral = await prisma.mineral.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MineralFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MineralFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Mineral'> extends True ? CheckSelect<T, Prisma__MineralClient<Mineral>, Prisma__MineralClient<MineralGetPayload<T>>> : CheckSelect<T, Prisma__MineralClient<Mineral | null >, Prisma__MineralClient<MineralGetPayload<T> | null >>

    /**
     * Find the first Mineral that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MineralFindFirstArgs} args - Arguments to find a Mineral
     * @example
     * // Get one Mineral
     * const mineral = await prisma.mineral.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MineralFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MineralFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Mineral'> extends True ? CheckSelect<T, Prisma__MineralClient<Mineral>, Prisma__MineralClient<MineralGetPayload<T>>> : CheckSelect<T, Prisma__MineralClient<Mineral | null >, Prisma__MineralClient<MineralGetPayload<T> | null >>

    /**
     * Find zero or more Minerals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MineralFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Minerals
     * const minerals = await prisma.mineral.findMany()
     * 
     * // Get first 10 Minerals
     * const minerals = await prisma.mineral.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mineralWithIdOnly = await prisma.mineral.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MineralFindManyArgs>(
      args?: SelectSubset<T, MineralFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Mineral>>, PrismaPromise<Array<MineralGetPayload<T>>>>

    /**
     * Create a Mineral.
     * @param {MineralCreateArgs} args - Arguments to create a Mineral.
     * @example
     * // Create one Mineral
     * const Mineral = await prisma.mineral.create({
     *   data: {
     *     // ... data to create a Mineral
     *   }
     * })
     * 
    **/
    create<T extends MineralCreateArgs>(
      args: SelectSubset<T, MineralCreateArgs>
    ): CheckSelect<T, Prisma__MineralClient<Mineral>, Prisma__MineralClient<MineralGetPayload<T>>>

    /**
     * Create many Minerals.
     *     @param {MineralCreateManyArgs} args - Arguments to create many Minerals.
     *     @example
     *     // Create many Minerals
     *     const mineral = await prisma.mineral.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MineralCreateManyArgs>(
      args?: SelectSubset<T, MineralCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Mineral.
     * @param {MineralDeleteArgs} args - Arguments to delete one Mineral.
     * @example
     * // Delete one Mineral
     * const Mineral = await prisma.mineral.delete({
     *   where: {
     *     // ... filter to delete one Mineral
     *   }
     * })
     * 
    **/
    delete<T extends MineralDeleteArgs>(
      args: SelectSubset<T, MineralDeleteArgs>
    ): CheckSelect<T, Prisma__MineralClient<Mineral>, Prisma__MineralClient<MineralGetPayload<T>>>

    /**
     * Update one Mineral.
     * @param {MineralUpdateArgs} args - Arguments to update one Mineral.
     * @example
     * // Update one Mineral
     * const mineral = await prisma.mineral.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MineralUpdateArgs>(
      args: SelectSubset<T, MineralUpdateArgs>
    ): CheckSelect<T, Prisma__MineralClient<Mineral>, Prisma__MineralClient<MineralGetPayload<T>>>

    /**
     * Delete zero or more Minerals.
     * @param {MineralDeleteManyArgs} args - Arguments to filter Minerals to delete.
     * @example
     * // Delete a few Minerals
     * const { count } = await prisma.mineral.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MineralDeleteManyArgs>(
      args?: SelectSubset<T, MineralDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Minerals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MineralUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Minerals
     * const mineral = await prisma.mineral.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MineralUpdateManyArgs>(
      args: SelectSubset<T, MineralUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Mineral.
     * @param {MineralUpsertArgs} args - Arguments to update or create a Mineral.
     * @example
     * // Update or create a Mineral
     * const mineral = await prisma.mineral.upsert({
     *   create: {
     *     // ... data to create a Mineral
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Mineral we want to update
     *   }
     * })
    **/
    upsert<T extends MineralUpsertArgs>(
      args: SelectSubset<T, MineralUpsertArgs>
    ): CheckSelect<T, Prisma__MineralClient<Mineral>, Prisma__MineralClient<MineralGetPayload<T>>>

    /**
     * Count the number of Minerals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MineralCountArgs} args - Arguments to filter Minerals to count.
     * @example
     * // Count the number of Minerals
     * const count = await prisma.mineral.count({
     *   where: {
     *     // ... the filter for the Minerals we want to count
     *   }
     * })
    **/
    count<T extends MineralCountArgs>(
      args?: Subset<T, MineralCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MineralCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Mineral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MineralAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MineralAggregateArgs>(args: Subset<T, MineralAggregateArgs>): PrismaPromise<GetMineralAggregateType<T>>

    /**
     * Group by Mineral.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MineralGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MineralGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MineralGroupByArgs['orderBy'] }
        : { orderBy?: MineralGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MineralGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMineralGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Mineral.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MineralClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    salt<T extends SaltArgs = {}>(args?: Subset<T, SaltArgs>): CheckSelect<T, Prisma__SaltClient<Salt | null >, Prisma__SaltClient<SaltGetPayload<T> | null >>;

    nutritionFact<T extends NutritionFactFindManyArgs = {}>(args?: Subset<T, NutritionFactFindManyArgs>): CheckSelect<T, PrismaPromise<Array<NutritionFact>>, PrismaPromise<Array<NutritionFactGetPayload<T>>>>;

    iron<T extends IronArgs = {}>(args?: Subset<T, IronArgs>): CheckSelect<T, Prisma__IronClient<Iron | null >, Prisma__IronClient<IronGetPayload<T> | null >>;

    zinc<T extends ZincArgs = {}>(args?: Subset<T, ZincArgs>): CheckSelect<T, Prisma__ZincClient<Zinc | null >, Prisma__ZincClient<ZincGetPayload<T> | null >>;

    magnesium<T extends MagnesiumArgs = {}>(args?: Subset<T, MagnesiumArgs>): CheckSelect<T, Prisma__MagnesiumClient<Magnesium | null >, Prisma__MagnesiumClient<MagnesiumGetPayload<T> | null >>;

    chloride<T extends ChlorideArgs = {}>(args?: Subset<T, ChlorideArgs>): CheckSelect<T, Prisma__ChlorideClient<Chloride | null >, Prisma__ChlorideClient<ChlorideGetPayload<T> | null >>;

    manganese<T extends ManganeseArgs = {}>(args?: Subset<T, ManganeseArgs>): CheckSelect<T, Prisma__ManganeseClient<Manganese | null >, Prisma__ManganeseClient<ManganeseGetPayload<T> | null >>;

    sulfur<T extends SulfurArgs = {}>(args?: Subset<T, SulfurArgs>): CheckSelect<T, Prisma__SulfurClient<Sulfur | null >, Prisma__SulfurClient<SulfurGetPayload<T> | null >>;

    potassium<T extends PotassiumArgs = {}>(args?: Subset<T, PotassiumArgs>): CheckSelect<T, Prisma__PotassiumClient<Potassium | null >, Prisma__PotassiumClient<PotassiumGetPayload<T> | null >>;

    fluoride<T extends FluorideArgs = {}>(args?: Subset<T, FluorideArgs>): CheckSelect<T, Prisma__FluorideClient<Fluoride | null >, Prisma__FluorideClient<FluorideGetPayload<T> | null >>;

    phosphorous<T extends PhosphorousArgs = {}>(args?: Subset<T, PhosphorousArgs>): CheckSelect<T, Prisma__PhosphorousClient<Phosphorous | null >, Prisma__PhosphorousClient<PhosphorousGetPayload<T> | null >>;

    copper<T extends CopperArgs = {}>(args?: Subset<T, CopperArgs>): CheckSelect<T, Prisma__CopperClient<Copper | null >, Prisma__CopperClient<CopperGetPayload<T> | null >>;

    iodine<T extends IodineArgs = {}>(args?: Subset<T, IodineArgs>): CheckSelect<T, Prisma__IodineClient<Iodine | null >, Prisma__IodineClient<IodineGetPayload<T> | null >>;

    calcium<T extends CalciumArgs = {}>(args?: Subset<T, CalciumArgs>): CheckSelect<T, Prisma__CalciumClient<Calcium | null >, Prisma__CalciumClient<CalciumGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Mineral findUnique
   */
  export type MineralFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Mineral
     * 
    **/
    select?: MineralSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MineralInclude | null
    /**
     * Throw an Error if a Mineral can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Mineral to fetch.
     * 
    **/
    where: MineralWhereUniqueInput
  }


  /**
   * Mineral findFirst
   */
  export type MineralFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Mineral
     * 
    **/
    select?: MineralSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MineralInclude | null
    /**
     * Throw an Error if a Mineral can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Mineral to fetch.
     * 
    **/
    where?: MineralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Minerals to fetch.
     * 
    **/
    orderBy?: Enumerable<MineralOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Minerals.
     * 
    **/
    cursor?: MineralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Minerals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Minerals.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Minerals.
     * 
    **/
    distinct?: Enumerable<MineralScalarFieldEnum>
  }


  /**
   * Mineral findMany
   */
  export type MineralFindManyArgs = {
    /**
     * Select specific fields to fetch from the Mineral
     * 
    **/
    select?: MineralSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MineralInclude | null
    /**
     * Filter, which Minerals to fetch.
     * 
    **/
    where?: MineralWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Minerals to fetch.
     * 
    **/
    orderBy?: Enumerable<MineralOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Minerals.
     * 
    **/
    cursor?: MineralWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Minerals from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Minerals.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MineralScalarFieldEnum>
  }


  /**
   * Mineral create
   */
  export type MineralCreateArgs = {
    /**
     * Select specific fields to fetch from the Mineral
     * 
    **/
    select?: MineralSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MineralInclude | null
    /**
     * The data needed to create a Mineral.
     * 
    **/
    data: XOR<MineralCreateInput, MineralUncheckedCreateInput>
  }


  /**
   * Mineral createMany
   */
  export type MineralCreateManyArgs = {
    /**
     * The data used to create many Minerals.
     * 
    **/
    data: Enumerable<MineralCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Mineral update
   */
  export type MineralUpdateArgs = {
    /**
     * Select specific fields to fetch from the Mineral
     * 
    **/
    select?: MineralSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MineralInclude | null
    /**
     * The data needed to update a Mineral.
     * 
    **/
    data: XOR<MineralUpdateInput, MineralUncheckedUpdateInput>
    /**
     * Choose, which Mineral to update.
     * 
    **/
    where: MineralWhereUniqueInput
  }


  /**
   * Mineral updateMany
   */
  export type MineralUpdateManyArgs = {
    /**
     * The data used to update Minerals.
     * 
    **/
    data: XOR<MineralUpdateManyMutationInput, MineralUncheckedUpdateManyInput>
    /**
     * Filter which Minerals to update
     * 
    **/
    where?: MineralWhereInput
  }


  /**
   * Mineral upsert
   */
  export type MineralUpsertArgs = {
    /**
     * Select specific fields to fetch from the Mineral
     * 
    **/
    select?: MineralSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MineralInclude | null
    /**
     * The filter to search for the Mineral to update in case it exists.
     * 
    **/
    where: MineralWhereUniqueInput
    /**
     * In case the Mineral found by the `where` argument doesn't exist, create a new Mineral with this data.
     * 
    **/
    create: XOR<MineralCreateInput, MineralUncheckedCreateInput>
    /**
     * In case the Mineral was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MineralUpdateInput, MineralUncheckedUpdateInput>
  }


  /**
   * Mineral delete
   */
  export type MineralDeleteArgs = {
    /**
     * Select specific fields to fetch from the Mineral
     * 
    **/
    select?: MineralSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MineralInclude | null
    /**
     * Filter which Mineral to delete.
     * 
    **/
    where: MineralWhereUniqueInput
  }


  /**
   * Mineral deleteMany
   */
  export type MineralDeleteManyArgs = {
    /**
     * Filter which Minerals to delete
     * 
    **/
    where?: MineralWhereInput
  }


  /**
   * Mineral without action
   */
  export type MineralArgs = {
    /**
     * Select specific fields to fetch from the Mineral
     * 
    **/
    select?: MineralSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MineralInclude | null
  }



  /**
   * Model Unit
   */


  export type AggregateUnit = {
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  export type UnitAvgAggregateOutputType = {
    id: number | null
  }

  export type UnitSumAggregateOutputType = {
    id: number | null
  }

  export type UnitMinAggregateOutputType = {
    id: number | null
    name: string | null
    abbreviation: string | null
  }

  export type UnitMaxAggregateOutputType = {
    id: number | null
    name: string | null
    abbreviation: string | null
  }

  export type UnitCountAggregateOutputType = {
    id: number
    name: number
    abbreviation: number
    _all: number
  }


  export type UnitAvgAggregateInputType = {
    id?: true
  }

  export type UnitSumAggregateInputType = {
    id?: true
  }

  export type UnitMinAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
  }

  export type UnitMaxAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
  }

  export type UnitCountAggregateInputType = {
    id?: true
    name?: true
    abbreviation?: true
    _all?: true
  }

  export type UnitAggregateArgs = {
    /**
     * Filter which Unit to aggregate.
     * 
    **/
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     * 
    **/
    orderBy?: Enumerable<UnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Units
    **/
    _count?: true | UnitCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UnitAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UnitSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UnitMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UnitMaxAggregateInputType
  }

  export type GetUnitAggregateType<T extends UnitAggregateArgs> = {
        [P in keyof T & keyof AggregateUnit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUnit[P]>
      : GetScalarType<T[P], AggregateUnit[P]>
  }




  export type UnitGroupByArgs = {
    where?: UnitWhereInput
    orderBy?: Enumerable<UnitOrderByWithAggregationInput>
    by: Array<UnitScalarFieldEnum>
    having?: UnitScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UnitCountAggregateInputType | true
    _avg?: UnitAvgAggregateInputType
    _sum?: UnitSumAggregateInputType
    _min?: UnitMinAggregateInputType
    _max?: UnitMaxAggregateInputType
  }


  export type UnitGroupByOutputType = {
    id: number
    name: string
    abbreviation: string
    _count: UnitCountAggregateOutputType | null
    _avg: UnitAvgAggregateOutputType | null
    _sum: UnitSumAggregateOutputType | null
    _min: UnitMinAggregateOutputType | null
    _max: UnitMaxAggregateOutputType | null
  }

  type GetUnitGroupByPayload<T extends UnitGroupByArgs> = PrismaPromise<
    Array<
      PickArray<UnitGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UnitGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UnitGroupByOutputType[P]>
            : GetScalarType<T[P], UnitGroupByOutputType[P]>
        }
      >
    >


  export type UnitSelect = {
    id?: boolean
    name?: boolean
    abbreviation?: boolean
    measurements?: boolean | MeasurementFindManyArgs
    _count?: boolean | UnitCountOutputTypeArgs
  }

  export type UnitInclude = {
    measurements?: boolean | MeasurementFindManyArgs
    _count?: boolean | UnitCountOutputTypeArgs
  }

  export type UnitGetPayload<
    S extends boolean | null | undefined | UnitArgs,
    U = keyof S
      > = S extends true
        ? Unit
    : S extends undefined
    ? never
    : S extends UnitArgs | UnitFindManyArgs
    ?'include' extends U
    ? Unit  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurements' ? Array < MeasurementGetPayload<S['include'][P]>>  :
        P extends '_count' ? UnitCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurements' ? Array < MeasurementGetPayload<S['select'][P]>>  :
        P extends '_count' ? UnitCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Unit ? Unit[P] : never
  } 
    : Unit
  : Unit


  type UnitCountArgs = Merge<
    Omit<UnitFindManyArgs, 'select' | 'include'> & {
      select?: UnitCountAggregateInputType | true
    }
  >

  export interface UnitDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Unit that matches the filter.
     * @param {UnitFindUniqueArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UnitFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, UnitFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Unit'> extends True ? CheckSelect<T, Prisma__UnitClient<Unit>, Prisma__UnitClient<UnitGetPayload<T>>> : CheckSelect<T, Prisma__UnitClient<Unit | null >, Prisma__UnitClient<UnitGetPayload<T> | null >>

    /**
     * Find the first Unit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindFirstArgs} args - Arguments to find a Unit
     * @example
     * // Get one Unit
     * const unit = await prisma.unit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UnitFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, UnitFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Unit'> extends True ? CheckSelect<T, Prisma__UnitClient<Unit>, Prisma__UnitClient<UnitGetPayload<T>>> : CheckSelect<T, Prisma__UnitClient<Unit | null >, Prisma__UnitClient<UnitGetPayload<T> | null >>

    /**
     * Find zero or more Units that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Units
     * const units = await prisma.unit.findMany()
     * 
     * // Get first 10 Units
     * const units = await prisma.unit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const unitWithIdOnly = await prisma.unit.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UnitFindManyArgs>(
      args?: SelectSubset<T, UnitFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Unit>>, PrismaPromise<Array<UnitGetPayload<T>>>>

    /**
     * Create a Unit.
     * @param {UnitCreateArgs} args - Arguments to create a Unit.
     * @example
     * // Create one Unit
     * const Unit = await prisma.unit.create({
     *   data: {
     *     // ... data to create a Unit
     *   }
     * })
     * 
    **/
    create<T extends UnitCreateArgs>(
      args: SelectSubset<T, UnitCreateArgs>
    ): CheckSelect<T, Prisma__UnitClient<Unit>, Prisma__UnitClient<UnitGetPayload<T>>>

    /**
     * Create many Units.
     *     @param {UnitCreateManyArgs} args - Arguments to create many Units.
     *     @example
     *     // Create many Units
     *     const unit = await prisma.unit.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends UnitCreateManyArgs>(
      args?: SelectSubset<T, UnitCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Unit.
     * @param {UnitDeleteArgs} args - Arguments to delete one Unit.
     * @example
     * // Delete one Unit
     * const Unit = await prisma.unit.delete({
     *   where: {
     *     // ... filter to delete one Unit
     *   }
     * })
     * 
    **/
    delete<T extends UnitDeleteArgs>(
      args: SelectSubset<T, UnitDeleteArgs>
    ): CheckSelect<T, Prisma__UnitClient<Unit>, Prisma__UnitClient<UnitGetPayload<T>>>

    /**
     * Update one Unit.
     * @param {UnitUpdateArgs} args - Arguments to update one Unit.
     * @example
     * // Update one Unit
     * const unit = await prisma.unit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UnitUpdateArgs>(
      args: SelectSubset<T, UnitUpdateArgs>
    ): CheckSelect<T, Prisma__UnitClient<Unit>, Prisma__UnitClient<UnitGetPayload<T>>>

    /**
     * Delete zero or more Units.
     * @param {UnitDeleteManyArgs} args - Arguments to filter Units to delete.
     * @example
     * // Delete a few Units
     * const { count } = await prisma.unit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UnitDeleteManyArgs>(
      args?: SelectSubset<T, UnitDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Units
     * const unit = await prisma.unit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UnitUpdateManyArgs>(
      args: SelectSubset<T, UnitUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Unit.
     * @param {UnitUpsertArgs} args - Arguments to update or create a Unit.
     * @example
     * // Update or create a Unit
     * const unit = await prisma.unit.upsert({
     *   create: {
     *     // ... data to create a Unit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Unit we want to update
     *   }
     * })
    **/
    upsert<T extends UnitUpsertArgs>(
      args: SelectSubset<T, UnitUpsertArgs>
    ): CheckSelect<T, Prisma__UnitClient<Unit>, Prisma__UnitClient<UnitGetPayload<T>>>

    /**
     * Count the number of Units.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitCountArgs} args - Arguments to filter Units to count.
     * @example
     * // Count the number of Units
     * const count = await prisma.unit.count({
     *   where: {
     *     // ... the filter for the Units we want to count
     *   }
     * })
    **/
    count<T extends UnitCountArgs>(
      args?: Subset<T, UnitCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UnitCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UnitAggregateArgs>(args: Subset<T, UnitAggregateArgs>): PrismaPromise<GetUnitAggregateType<T>>

    /**
     * Group by Unit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UnitGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UnitGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UnitGroupByArgs['orderBy'] }
        : { orderBy?: UnitGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UnitGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUnitGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Unit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__UnitClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurements<T extends MeasurementFindManyArgs = {}>(args?: Subset<T, MeasurementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Measurement>>, PrismaPromise<Array<MeasurementGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Unit findUnique
   */
  export type UnitFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Unit
     * 
    **/
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UnitInclude | null
    /**
     * Throw an Error if a Unit can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Unit to fetch.
     * 
    **/
    where: UnitWhereUniqueInput
  }


  /**
   * Unit findFirst
   */
  export type UnitFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Unit
     * 
    **/
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UnitInclude | null
    /**
     * Throw an Error if a Unit can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Unit to fetch.
     * 
    **/
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     * 
    **/
    orderBy?: Enumerable<UnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Units.
     * 
    **/
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Units.
     * 
    **/
    distinct?: Enumerable<UnitScalarFieldEnum>
  }


  /**
   * Unit findMany
   */
  export type UnitFindManyArgs = {
    /**
     * Select specific fields to fetch from the Unit
     * 
    **/
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UnitInclude | null
    /**
     * Filter, which Units to fetch.
     * 
    **/
    where?: UnitWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Units to fetch.
     * 
    **/
    orderBy?: Enumerable<UnitOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Units.
     * 
    **/
    cursor?: UnitWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Units from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Units.
     * 
    **/
    skip?: number
    distinct?: Enumerable<UnitScalarFieldEnum>
  }


  /**
   * Unit create
   */
  export type UnitCreateArgs = {
    /**
     * Select specific fields to fetch from the Unit
     * 
    **/
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UnitInclude | null
    /**
     * The data needed to create a Unit.
     * 
    **/
    data: XOR<UnitCreateInput, UnitUncheckedCreateInput>
  }


  /**
   * Unit createMany
   */
  export type UnitCreateManyArgs = {
    /**
     * The data used to create many Units.
     * 
    **/
    data: Enumerable<UnitCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Unit update
   */
  export type UnitUpdateArgs = {
    /**
     * Select specific fields to fetch from the Unit
     * 
    **/
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UnitInclude | null
    /**
     * The data needed to update a Unit.
     * 
    **/
    data: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
    /**
     * Choose, which Unit to update.
     * 
    **/
    where: UnitWhereUniqueInput
  }


  /**
   * Unit updateMany
   */
  export type UnitUpdateManyArgs = {
    /**
     * The data used to update Units.
     * 
    **/
    data: XOR<UnitUpdateManyMutationInput, UnitUncheckedUpdateManyInput>
    /**
     * Filter which Units to update
     * 
    **/
    where?: UnitWhereInput
  }


  /**
   * Unit upsert
   */
  export type UnitUpsertArgs = {
    /**
     * Select specific fields to fetch from the Unit
     * 
    **/
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UnitInclude | null
    /**
     * The filter to search for the Unit to update in case it exists.
     * 
    **/
    where: UnitWhereUniqueInput
    /**
     * In case the Unit found by the `where` argument doesn't exist, create a new Unit with this data.
     * 
    **/
    create: XOR<UnitCreateInput, UnitUncheckedCreateInput>
    /**
     * In case the Unit was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<UnitUpdateInput, UnitUncheckedUpdateInput>
  }


  /**
   * Unit delete
   */
  export type UnitDeleteArgs = {
    /**
     * Select specific fields to fetch from the Unit
     * 
    **/
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UnitInclude | null
    /**
     * Filter which Unit to delete.
     * 
    **/
    where: UnitWhereUniqueInput
  }


  /**
   * Unit deleteMany
   */
  export type UnitDeleteManyArgs = {
    /**
     * Filter which Units to delete
     * 
    **/
    where?: UnitWhereInput
  }


  /**
   * Unit without action
   */
  export type UnitArgs = {
    /**
     * Select specific fields to fetch from the Unit
     * 
    **/
    select?: UnitSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: UnitInclude | null
  }



  /**
   * Model Measurement
   */


  export type AggregateMeasurement = {
    _count: MeasurementCountAggregateOutputType | null
    _avg: MeasurementAvgAggregateOutputType | null
    _sum: MeasurementSumAggregateOutputType | null
    _min: MeasurementMinAggregateOutputType | null
    _max: MeasurementMaxAggregateOutputType | null
  }

  export type MeasurementAvgAggregateOutputType = {
    id: number | null
    value: Decimal | null
    unitId: number | null
    proteinId: number | null
    cholesterolId: number | null
    fiberId: number | null
    waterId: number | null
  }

  export type MeasurementSumAggregateOutputType = {
    id: number | null
    value: Decimal | null
    unitId: number | null
    proteinId: number | null
    cholesterolId: number | null
    fiberId: number | null
    waterId: number | null
  }

  export type MeasurementMinAggregateOutputType = {
    id: number | null
    value: Decimal | null
    unitId: number | null
    proteinId: number | null
    cholesterolId: number | null
    fiberId: number | null
    waterId: number | null
  }

  export type MeasurementMaxAggregateOutputType = {
    id: number | null
    value: Decimal | null
    unitId: number | null
    proteinId: number | null
    cholesterolId: number | null
    fiberId: number | null
    waterId: number | null
  }

  export type MeasurementCountAggregateOutputType = {
    id: number
    value: number
    unitId: number
    proteinId: number
    cholesterolId: number
    fiberId: number
    waterId: number
    _all: number
  }


  export type MeasurementAvgAggregateInputType = {
    id?: true
    value?: true
    unitId?: true
    proteinId?: true
    cholesterolId?: true
    fiberId?: true
    waterId?: true
  }

  export type MeasurementSumAggregateInputType = {
    id?: true
    value?: true
    unitId?: true
    proteinId?: true
    cholesterolId?: true
    fiberId?: true
    waterId?: true
  }

  export type MeasurementMinAggregateInputType = {
    id?: true
    value?: true
    unitId?: true
    proteinId?: true
    cholesterolId?: true
    fiberId?: true
    waterId?: true
  }

  export type MeasurementMaxAggregateInputType = {
    id?: true
    value?: true
    unitId?: true
    proteinId?: true
    cholesterolId?: true
    fiberId?: true
    waterId?: true
  }

  export type MeasurementCountAggregateInputType = {
    id?: true
    value?: true
    unitId?: true
    proteinId?: true
    cholesterolId?: true
    fiberId?: true
    waterId?: true
    _all?: true
  }

  export type MeasurementAggregateArgs = {
    /**
     * Filter which Measurement to aggregate.
     * 
    **/
    where?: MeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Measurements to fetch.
     * 
    **/
    orderBy?: Enumerable<MeasurementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: MeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Measurements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Measurements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Measurements
    **/
    _count?: true | MeasurementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeasurementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeasurementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeasurementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeasurementMaxAggregateInputType
  }

  export type GetMeasurementAggregateType<T extends MeasurementAggregateArgs> = {
        [P in keyof T & keyof AggregateMeasurement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeasurement[P]>
      : GetScalarType<T[P], AggregateMeasurement[P]>
  }




  export type MeasurementGroupByArgs = {
    where?: MeasurementWhereInput
    orderBy?: Enumerable<MeasurementOrderByWithAggregationInput>
    by: Array<MeasurementScalarFieldEnum>
    having?: MeasurementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeasurementCountAggregateInputType | true
    _avg?: MeasurementAvgAggregateInputType
    _sum?: MeasurementSumAggregateInputType
    _min?: MeasurementMinAggregateInputType
    _max?: MeasurementMaxAggregateInputType
  }


  export type MeasurementGroupByOutputType = {
    id: number
    value: Decimal | null
    unitId: number
    proteinId: number | null
    cholesterolId: number | null
    fiberId: number | null
    waterId: number | null
    _count: MeasurementCountAggregateOutputType | null
    _avg: MeasurementAvgAggregateOutputType | null
    _sum: MeasurementSumAggregateOutputType | null
    _min: MeasurementMinAggregateOutputType | null
    _max: MeasurementMaxAggregateOutputType | null
  }

  type GetMeasurementGroupByPayload<T extends MeasurementGroupByArgs> = PrismaPromise<
    Array<
      PickArray<MeasurementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeasurementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeasurementGroupByOutputType[P]>
            : GetScalarType<T[P], MeasurementGroupByOutputType[P]>
        }
      >
    >


  export type MeasurementSelect = {
    id?: boolean
    value?: boolean
    unit?: boolean | UnitArgs
    unitId?: boolean
    servings?: boolean | ServingFindManyArgs
    vitamin?: boolean | VitaminFindManyArgs
    salt?: boolean | SaltFindManyArgs
    zinc?: boolean | ZincFindManyArgs
    iron?: boolean | IronFindManyArgs
    magnesium?: boolean | MagnesiumFindManyArgs
    chloride?: boolean | ChlorideFindManyArgs
    manganese?: boolean | ManganeseFindManyArgs
    sulfur?: boolean | SulfurFindManyArgs
    potassium?: boolean | PotassiumFindManyArgs
    fluoride?: boolean | FluorideFindManyArgs
    phosphorous?: boolean | PhosphorousFindManyArgs
    copper?: boolean | CopperFindManyArgs
    iodine?: boolean | IodineFindManyArgs
    calcium?: boolean | CalciumFindManyArgs
    totalFat?: boolean | TotalFatFindManyArgs
    saturatedFat?: boolean | SaturatedFatFindManyArgs
    monosaturatedFat?: boolean | MonosaturatedFatFindManyArgs
    polyunsaturatedFat?: boolean | PolyunsaturatedFatFindManyArgs
    transFat?: boolean | TransFatFindManyArgs
    totalCarbohydrate?: boolean | TotalCarbohydrateFindManyArgs
    sugarCarbohydrate?: boolean | SugarCarbohydrateFindManyArgs
    vitaminC?: boolean | VitaminCFindManyArgs
    vitaminA?: boolean | VitaminAFindManyArgs
    vitaminD?: boolean | VitaminDFindManyArgs
    vitaminE?: boolean | VitaminEFindManyArgs
    vitaminB1?: boolean | VitaminB1FindManyArgs
    vitaminB2?: boolean | VitaminB2FindManyArgs
    vitaminB6?: boolean | VitaminB6FindManyArgs
    vitaminB12?: boolean | VitaminB12FindManyArgs
    energy?: boolean | EnergyFindManyArgs
    protein?: boolean | ProteinArgs
    proteinId?: boolean
    cholesterol?: boolean | CholesterolArgs
    cholesterolId?: boolean
    ciber?: boolean | FiberArgs
    fiberId?: boolean
    cater?: boolean | WaterArgs
    waterId?: boolean
    _count?: boolean | MeasurementCountOutputTypeArgs
  }

  export type MeasurementInclude = {
    unit?: boolean | UnitArgs
    servings?: boolean | ServingFindManyArgs
    vitamin?: boolean | VitaminFindManyArgs
    salt?: boolean | SaltFindManyArgs
    zinc?: boolean | ZincFindManyArgs
    iron?: boolean | IronFindManyArgs
    magnesium?: boolean | MagnesiumFindManyArgs
    chloride?: boolean | ChlorideFindManyArgs
    manganese?: boolean | ManganeseFindManyArgs
    sulfur?: boolean | SulfurFindManyArgs
    potassium?: boolean | PotassiumFindManyArgs
    fluoride?: boolean | FluorideFindManyArgs
    phosphorous?: boolean | PhosphorousFindManyArgs
    copper?: boolean | CopperFindManyArgs
    iodine?: boolean | IodineFindManyArgs
    calcium?: boolean | CalciumFindManyArgs
    totalFat?: boolean | TotalFatFindManyArgs
    saturatedFat?: boolean | SaturatedFatFindManyArgs
    monosaturatedFat?: boolean | MonosaturatedFatFindManyArgs
    polyunsaturatedFat?: boolean | PolyunsaturatedFatFindManyArgs
    transFat?: boolean | TransFatFindManyArgs
    totalCarbohydrate?: boolean | TotalCarbohydrateFindManyArgs
    sugarCarbohydrate?: boolean | SugarCarbohydrateFindManyArgs
    vitaminC?: boolean | VitaminCFindManyArgs
    vitaminA?: boolean | VitaminAFindManyArgs
    vitaminD?: boolean | VitaminDFindManyArgs
    vitaminE?: boolean | VitaminEFindManyArgs
    vitaminB1?: boolean | VitaminB1FindManyArgs
    vitaminB2?: boolean | VitaminB2FindManyArgs
    vitaminB6?: boolean | VitaminB6FindManyArgs
    vitaminB12?: boolean | VitaminB12FindManyArgs
    energy?: boolean | EnergyFindManyArgs
    protein?: boolean | ProteinArgs
    cholesterol?: boolean | CholesterolArgs
    ciber?: boolean | FiberArgs
    cater?: boolean | WaterArgs
    _count?: boolean | MeasurementCountOutputTypeArgs
  }

  export type MeasurementGetPayload<
    S extends boolean | null | undefined | MeasurementArgs,
    U = keyof S
      > = S extends true
        ? Measurement
    : S extends undefined
    ? never
    : S extends MeasurementArgs | MeasurementFindManyArgs
    ?'include' extends U
    ? Measurement  & {
    [P in TrueKeys<S['include']>]:
        P extends 'unit' ? UnitGetPayload<S['include'][P]> :
        P extends 'servings' ? Array < ServingGetPayload<S['include'][P]>>  :
        P extends 'vitamin' ? Array < VitaminGetPayload<S['include'][P]>>  :
        P extends 'salt' ? Array < SaltGetPayload<S['include'][P]>>  :
        P extends 'zinc' ? Array < ZincGetPayload<S['include'][P]>>  :
        P extends 'iron' ? Array < IronGetPayload<S['include'][P]>>  :
        P extends 'magnesium' ? Array < MagnesiumGetPayload<S['include'][P]>>  :
        P extends 'chloride' ? Array < ChlorideGetPayload<S['include'][P]>>  :
        P extends 'manganese' ? Array < ManganeseGetPayload<S['include'][P]>>  :
        P extends 'sulfur' ? Array < SulfurGetPayload<S['include'][P]>>  :
        P extends 'potassium' ? Array < PotassiumGetPayload<S['include'][P]>>  :
        P extends 'fluoride' ? Array < FluorideGetPayload<S['include'][P]>>  :
        P extends 'phosphorous' ? Array < PhosphorousGetPayload<S['include'][P]>>  :
        P extends 'copper' ? Array < CopperGetPayload<S['include'][P]>>  :
        P extends 'iodine' ? Array < IodineGetPayload<S['include'][P]>>  :
        P extends 'calcium' ? Array < CalciumGetPayload<S['include'][P]>>  :
        P extends 'totalFat' ? Array < TotalFatGetPayload<S['include'][P]>>  :
        P extends 'saturatedFat' ? Array < SaturatedFatGetPayload<S['include'][P]>>  :
        P extends 'monosaturatedFat' ? Array < MonosaturatedFatGetPayload<S['include'][P]>>  :
        P extends 'polyunsaturatedFat' ? Array < PolyunsaturatedFatGetPayload<S['include'][P]>>  :
        P extends 'transFat' ? Array < TransFatGetPayload<S['include'][P]>>  :
        P extends 'totalCarbohydrate' ? Array < TotalCarbohydrateGetPayload<S['include'][P]>>  :
        P extends 'sugarCarbohydrate' ? Array < SugarCarbohydrateGetPayload<S['include'][P]>>  :
        P extends 'vitaminC' ? Array < VitaminCGetPayload<S['include'][P]>>  :
        P extends 'vitaminA' ? Array < VitaminAGetPayload<S['include'][P]>>  :
        P extends 'vitaminD' ? Array < VitaminDGetPayload<S['include'][P]>>  :
        P extends 'vitaminE' ? Array < VitaminEGetPayload<S['include'][P]>>  :
        P extends 'vitaminB1' ? Array < VitaminB1GetPayload<S['include'][P]>>  :
        P extends 'vitaminB2' ? Array < VitaminB2GetPayload<S['include'][P]>>  :
        P extends 'vitaminB6' ? Array < VitaminB6GetPayload<S['include'][P]>>  :
        P extends 'vitaminB12' ? Array < VitaminB12GetPayload<S['include'][P]>>  :
        P extends 'energy' ? Array < EnergyGetPayload<S['include'][P]>>  :
        P extends 'protein' ? ProteinGetPayload<S['include'][P]> | null :
        P extends 'cholesterol' ? CholesterolGetPayload<S['include'][P]> | null :
        P extends 'ciber' ? FiberGetPayload<S['include'][P]> | null :
        P extends 'cater' ? WaterGetPayload<S['include'][P]> | null :
        P extends '_count' ? MeasurementCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'unit' ? UnitGetPayload<S['select'][P]> :
        P extends 'servings' ? Array < ServingGetPayload<S['select'][P]>>  :
        P extends 'vitamin' ? Array < VitaminGetPayload<S['select'][P]>>  :
        P extends 'salt' ? Array < SaltGetPayload<S['select'][P]>>  :
        P extends 'zinc' ? Array < ZincGetPayload<S['select'][P]>>  :
        P extends 'iron' ? Array < IronGetPayload<S['select'][P]>>  :
        P extends 'magnesium' ? Array < MagnesiumGetPayload<S['select'][P]>>  :
        P extends 'chloride' ? Array < ChlorideGetPayload<S['select'][P]>>  :
        P extends 'manganese' ? Array < ManganeseGetPayload<S['select'][P]>>  :
        P extends 'sulfur' ? Array < SulfurGetPayload<S['select'][P]>>  :
        P extends 'potassium' ? Array < PotassiumGetPayload<S['select'][P]>>  :
        P extends 'fluoride' ? Array < FluorideGetPayload<S['select'][P]>>  :
        P extends 'phosphorous' ? Array < PhosphorousGetPayload<S['select'][P]>>  :
        P extends 'copper' ? Array < CopperGetPayload<S['select'][P]>>  :
        P extends 'iodine' ? Array < IodineGetPayload<S['select'][P]>>  :
        P extends 'calcium' ? Array < CalciumGetPayload<S['select'][P]>>  :
        P extends 'totalFat' ? Array < TotalFatGetPayload<S['select'][P]>>  :
        P extends 'saturatedFat' ? Array < SaturatedFatGetPayload<S['select'][P]>>  :
        P extends 'monosaturatedFat' ? Array < MonosaturatedFatGetPayload<S['select'][P]>>  :
        P extends 'polyunsaturatedFat' ? Array < PolyunsaturatedFatGetPayload<S['select'][P]>>  :
        P extends 'transFat' ? Array < TransFatGetPayload<S['select'][P]>>  :
        P extends 'totalCarbohydrate' ? Array < TotalCarbohydrateGetPayload<S['select'][P]>>  :
        P extends 'sugarCarbohydrate' ? Array < SugarCarbohydrateGetPayload<S['select'][P]>>  :
        P extends 'vitaminC' ? Array < VitaminCGetPayload<S['select'][P]>>  :
        P extends 'vitaminA' ? Array < VitaminAGetPayload<S['select'][P]>>  :
        P extends 'vitaminD' ? Array < VitaminDGetPayload<S['select'][P]>>  :
        P extends 'vitaminE' ? Array < VitaminEGetPayload<S['select'][P]>>  :
        P extends 'vitaminB1' ? Array < VitaminB1GetPayload<S['select'][P]>>  :
        P extends 'vitaminB2' ? Array < VitaminB2GetPayload<S['select'][P]>>  :
        P extends 'vitaminB6' ? Array < VitaminB6GetPayload<S['select'][P]>>  :
        P extends 'vitaminB12' ? Array < VitaminB12GetPayload<S['select'][P]>>  :
        P extends 'energy' ? Array < EnergyGetPayload<S['select'][P]>>  :
        P extends 'protein' ? ProteinGetPayload<S['select'][P]> | null :
        P extends 'cholesterol' ? CholesterolGetPayload<S['select'][P]> | null :
        P extends 'ciber' ? FiberGetPayload<S['select'][P]> | null :
        P extends 'cater' ? WaterGetPayload<S['select'][P]> | null :
        P extends '_count' ? MeasurementCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Measurement ? Measurement[P] : never
  } 
    : Measurement
  : Measurement


  type MeasurementCountArgs = Merge<
    Omit<MeasurementFindManyArgs, 'select' | 'include'> & {
      select?: MeasurementCountAggregateInputType | true
    }
  >

  export interface MeasurementDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Measurement that matches the filter.
     * @param {MeasurementFindUniqueArgs} args - Arguments to find a Measurement
     * @example
     * // Get one Measurement
     * const measurement = await prisma.measurement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends MeasurementFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, MeasurementFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Measurement'> extends True ? CheckSelect<T, Prisma__MeasurementClient<Measurement>, Prisma__MeasurementClient<MeasurementGetPayload<T>>> : CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>

    /**
     * Find the first Measurement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasurementFindFirstArgs} args - Arguments to find a Measurement
     * @example
     * // Get one Measurement
     * const measurement = await prisma.measurement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends MeasurementFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, MeasurementFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Measurement'> extends True ? CheckSelect<T, Prisma__MeasurementClient<Measurement>, Prisma__MeasurementClient<MeasurementGetPayload<T>>> : CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>

    /**
     * Find zero or more Measurements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasurementFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Measurements
     * const measurements = await prisma.measurement.findMany()
     * 
     * // Get first 10 Measurements
     * const measurements = await prisma.measurement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const measurementWithIdOnly = await prisma.measurement.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends MeasurementFindManyArgs>(
      args?: SelectSubset<T, MeasurementFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Measurement>>, PrismaPromise<Array<MeasurementGetPayload<T>>>>

    /**
     * Create a Measurement.
     * @param {MeasurementCreateArgs} args - Arguments to create a Measurement.
     * @example
     * // Create one Measurement
     * const Measurement = await prisma.measurement.create({
     *   data: {
     *     // ... data to create a Measurement
     *   }
     * })
     * 
    **/
    create<T extends MeasurementCreateArgs>(
      args: SelectSubset<T, MeasurementCreateArgs>
    ): CheckSelect<T, Prisma__MeasurementClient<Measurement>, Prisma__MeasurementClient<MeasurementGetPayload<T>>>

    /**
     * Create many Measurements.
     *     @param {MeasurementCreateManyArgs} args - Arguments to create many Measurements.
     *     @example
     *     // Create many Measurements
     *     const measurement = await prisma.measurement.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends MeasurementCreateManyArgs>(
      args?: SelectSubset<T, MeasurementCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Measurement.
     * @param {MeasurementDeleteArgs} args - Arguments to delete one Measurement.
     * @example
     * // Delete one Measurement
     * const Measurement = await prisma.measurement.delete({
     *   where: {
     *     // ... filter to delete one Measurement
     *   }
     * })
     * 
    **/
    delete<T extends MeasurementDeleteArgs>(
      args: SelectSubset<T, MeasurementDeleteArgs>
    ): CheckSelect<T, Prisma__MeasurementClient<Measurement>, Prisma__MeasurementClient<MeasurementGetPayload<T>>>

    /**
     * Update one Measurement.
     * @param {MeasurementUpdateArgs} args - Arguments to update one Measurement.
     * @example
     * // Update one Measurement
     * const measurement = await prisma.measurement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends MeasurementUpdateArgs>(
      args: SelectSubset<T, MeasurementUpdateArgs>
    ): CheckSelect<T, Prisma__MeasurementClient<Measurement>, Prisma__MeasurementClient<MeasurementGetPayload<T>>>

    /**
     * Delete zero or more Measurements.
     * @param {MeasurementDeleteManyArgs} args - Arguments to filter Measurements to delete.
     * @example
     * // Delete a few Measurements
     * const { count } = await prisma.measurement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends MeasurementDeleteManyArgs>(
      args?: SelectSubset<T, MeasurementDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Measurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasurementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Measurements
     * const measurement = await prisma.measurement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends MeasurementUpdateManyArgs>(
      args: SelectSubset<T, MeasurementUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Measurement.
     * @param {MeasurementUpsertArgs} args - Arguments to update or create a Measurement.
     * @example
     * // Update or create a Measurement
     * const measurement = await prisma.measurement.upsert({
     *   create: {
     *     // ... data to create a Measurement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Measurement we want to update
     *   }
     * })
    **/
    upsert<T extends MeasurementUpsertArgs>(
      args: SelectSubset<T, MeasurementUpsertArgs>
    ): CheckSelect<T, Prisma__MeasurementClient<Measurement>, Prisma__MeasurementClient<MeasurementGetPayload<T>>>

    /**
     * Count the number of Measurements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasurementCountArgs} args - Arguments to filter Measurements to count.
     * @example
     * // Count the number of Measurements
     * const count = await prisma.measurement.count({
     *   where: {
     *     // ... the filter for the Measurements we want to count
     *   }
     * })
    **/
    count<T extends MeasurementCountArgs>(
      args?: Subset<T, MeasurementCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeasurementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Measurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasurementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeasurementAggregateArgs>(args: Subset<T, MeasurementAggregateArgs>): PrismaPromise<GetMeasurementAggregateType<T>>

    /**
     * Group by Measurement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeasurementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeasurementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeasurementGroupByArgs['orderBy'] }
        : { orderBy?: MeasurementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeasurementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeasurementGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Measurement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__MeasurementClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    unit<T extends UnitArgs = {}>(args?: Subset<T, UnitArgs>): CheckSelect<T, Prisma__UnitClient<Unit | null >, Prisma__UnitClient<UnitGetPayload<T> | null >>;

    servings<T extends ServingFindManyArgs = {}>(args?: Subset<T, ServingFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Serving>>, PrismaPromise<Array<ServingGetPayload<T>>>>;

    vitamin<T extends VitaminFindManyArgs = {}>(args?: Subset<T, VitaminFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Vitamin>>, PrismaPromise<Array<VitaminGetPayload<T>>>>;

    salt<T extends SaltFindManyArgs = {}>(args?: Subset<T, SaltFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Salt>>, PrismaPromise<Array<SaltGetPayload<T>>>>;

    zinc<T extends ZincFindManyArgs = {}>(args?: Subset<T, ZincFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Zinc>>, PrismaPromise<Array<ZincGetPayload<T>>>>;

    iron<T extends IronFindManyArgs = {}>(args?: Subset<T, IronFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Iron>>, PrismaPromise<Array<IronGetPayload<T>>>>;

    magnesium<T extends MagnesiumFindManyArgs = {}>(args?: Subset<T, MagnesiumFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Magnesium>>, PrismaPromise<Array<MagnesiumGetPayload<T>>>>;

    chloride<T extends ChlorideFindManyArgs = {}>(args?: Subset<T, ChlorideFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Chloride>>, PrismaPromise<Array<ChlorideGetPayload<T>>>>;

    manganese<T extends ManganeseFindManyArgs = {}>(args?: Subset<T, ManganeseFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Manganese>>, PrismaPromise<Array<ManganeseGetPayload<T>>>>;

    sulfur<T extends SulfurFindManyArgs = {}>(args?: Subset<T, SulfurFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Sulfur>>, PrismaPromise<Array<SulfurGetPayload<T>>>>;

    potassium<T extends PotassiumFindManyArgs = {}>(args?: Subset<T, PotassiumFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Potassium>>, PrismaPromise<Array<PotassiumGetPayload<T>>>>;

    fluoride<T extends FluorideFindManyArgs = {}>(args?: Subset<T, FluorideFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Fluoride>>, PrismaPromise<Array<FluorideGetPayload<T>>>>;

    phosphorous<T extends PhosphorousFindManyArgs = {}>(args?: Subset<T, PhosphorousFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Phosphorous>>, PrismaPromise<Array<PhosphorousGetPayload<T>>>>;

    copper<T extends CopperFindManyArgs = {}>(args?: Subset<T, CopperFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Copper>>, PrismaPromise<Array<CopperGetPayload<T>>>>;

    iodine<T extends IodineFindManyArgs = {}>(args?: Subset<T, IodineFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Iodine>>, PrismaPromise<Array<IodineGetPayload<T>>>>;

    calcium<T extends CalciumFindManyArgs = {}>(args?: Subset<T, CalciumFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Calcium>>, PrismaPromise<Array<CalciumGetPayload<T>>>>;

    totalFat<T extends TotalFatFindManyArgs = {}>(args?: Subset<T, TotalFatFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TotalFat>>, PrismaPromise<Array<TotalFatGetPayload<T>>>>;

    saturatedFat<T extends SaturatedFatFindManyArgs = {}>(args?: Subset<T, SaturatedFatFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SaturatedFat>>, PrismaPromise<Array<SaturatedFatGetPayload<T>>>>;

    monosaturatedFat<T extends MonosaturatedFatFindManyArgs = {}>(args?: Subset<T, MonosaturatedFatFindManyArgs>): CheckSelect<T, PrismaPromise<Array<MonosaturatedFat>>, PrismaPromise<Array<MonosaturatedFatGetPayload<T>>>>;

    polyunsaturatedFat<T extends PolyunsaturatedFatFindManyArgs = {}>(args?: Subset<T, PolyunsaturatedFatFindManyArgs>): CheckSelect<T, PrismaPromise<Array<PolyunsaturatedFat>>, PrismaPromise<Array<PolyunsaturatedFatGetPayload<T>>>>;

    transFat<T extends TransFatFindManyArgs = {}>(args?: Subset<T, TransFatFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TransFat>>, PrismaPromise<Array<TransFatGetPayload<T>>>>;

    totalCarbohydrate<T extends TotalCarbohydrateFindManyArgs = {}>(args?: Subset<T, TotalCarbohydrateFindManyArgs>): CheckSelect<T, PrismaPromise<Array<TotalCarbohydrate>>, PrismaPromise<Array<TotalCarbohydrateGetPayload<T>>>>;

    sugarCarbohydrate<T extends SugarCarbohydrateFindManyArgs = {}>(args?: Subset<T, SugarCarbohydrateFindManyArgs>): CheckSelect<T, PrismaPromise<Array<SugarCarbohydrate>>, PrismaPromise<Array<SugarCarbohydrateGetPayload<T>>>>;

    vitaminC<T extends VitaminCFindManyArgs = {}>(args?: Subset<T, VitaminCFindManyArgs>): CheckSelect<T, PrismaPromise<Array<VitaminC>>, PrismaPromise<Array<VitaminCGetPayload<T>>>>;

    vitaminA<T extends VitaminAFindManyArgs = {}>(args?: Subset<T, VitaminAFindManyArgs>): CheckSelect<T, PrismaPromise<Array<VitaminA>>, PrismaPromise<Array<VitaminAGetPayload<T>>>>;

    vitaminD<T extends VitaminDFindManyArgs = {}>(args?: Subset<T, VitaminDFindManyArgs>): CheckSelect<T, PrismaPromise<Array<VitaminD>>, PrismaPromise<Array<VitaminDGetPayload<T>>>>;

    vitaminE<T extends VitaminEFindManyArgs = {}>(args?: Subset<T, VitaminEFindManyArgs>): CheckSelect<T, PrismaPromise<Array<VitaminE>>, PrismaPromise<Array<VitaminEGetPayload<T>>>>;

    vitaminB1<T extends VitaminB1FindManyArgs = {}>(args?: Subset<T, VitaminB1FindManyArgs>): CheckSelect<T, PrismaPromise<Array<VitaminB1>>, PrismaPromise<Array<VitaminB1GetPayload<T>>>>;

    vitaminB2<T extends VitaminB2FindManyArgs = {}>(args?: Subset<T, VitaminB2FindManyArgs>): CheckSelect<T, PrismaPromise<Array<VitaminB2>>, PrismaPromise<Array<VitaminB2GetPayload<T>>>>;

    vitaminB6<T extends VitaminB6FindManyArgs = {}>(args?: Subset<T, VitaminB6FindManyArgs>): CheckSelect<T, PrismaPromise<Array<VitaminB6>>, PrismaPromise<Array<VitaminB6GetPayload<T>>>>;

    vitaminB12<T extends VitaminB12FindManyArgs = {}>(args?: Subset<T, VitaminB12FindManyArgs>): CheckSelect<T, PrismaPromise<Array<VitaminB12>>, PrismaPromise<Array<VitaminB12GetPayload<T>>>>;

    energy<T extends EnergyFindManyArgs = {}>(args?: Subset<T, EnergyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Energy>>, PrismaPromise<Array<EnergyGetPayload<T>>>>;

    protein<T extends ProteinArgs = {}>(args?: Subset<T, ProteinArgs>): CheckSelect<T, Prisma__ProteinClient<Protein | null >, Prisma__ProteinClient<ProteinGetPayload<T> | null >>;

    cholesterol<T extends CholesterolArgs = {}>(args?: Subset<T, CholesterolArgs>): CheckSelect<T, Prisma__CholesterolClient<Cholesterol | null >, Prisma__CholesterolClient<CholesterolGetPayload<T> | null >>;

    ciber<T extends FiberArgs = {}>(args?: Subset<T, FiberArgs>): CheckSelect<T, Prisma__FiberClient<Fiber | null >, Prisma__FiberClient<FiberGetPayload<T> | null >>;

    cater<T extends WaterArgs = {}>(args?: Subset<T, WaterArgs>): CheckSelect<T, Prisma__WaterClient<Water | null >, Prisma__WaterClient<WaterGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Measurement findUnique
   */
  export type MeasurementFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Measurement
     * 
    **/
    select?: MeasurementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeasurementInclude | null
    /**
     * Throw an Error if a Measurement can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Measurement to fetch.
     * 
    **/
    where: MeasurementWhereUniqueInput
  }


  /**
   * Measurement findFirst
   */
  export type MeasurementFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Measurement
     * 
    **/
    select?: MeasurementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeasurementInclude | null
    /**
     * Throw an Error if a Measurement can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Measurement to fetch.
     * 
    **/
    where?: MeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Measurements to fetch.
     * 
    **/
    orderBy?: Enumerable<MeasurementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Measurements.
     * 
    **/
    cursor?: MeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Measurements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Measurements.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Measurements.
     * 
    **/
    distinct?: Enumerable<MeasurementScalarFieldEnum>
  }


  /**
   * Measurement findMany
   */
  export type MeasurementFindManyArgs = {
    /**
     * Select specific fields to fetch from the Measurement
     * 
    **/
    select?: MeasurementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeasurementInclude | null
    /**
     * Filter, which Measurements to fetch.
     * 
    **/
    where?: MeasurementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Measurements to fetch.
     * 
    **/
    orderBy?: Enumerable<MeasurementOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Measurements.
     * 
    **/
    cursor?: MeasurementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Measurements from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Measurements.
     * 
    **/
    skip?: number
    distinct?: Enumerable<MeasurementScalarFieldEnum>
  }


  /**
   * Measurement create
   */
  export type MeasurementCreateArgs = {
    /**
     * Select specific fields to fetch from the Measurement
     * 
    **/
    select?: MeasurementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeasurementInclude | null
    /**
     * The data needed to create a Measurement.
     * 
    **/
    data: XOR<MeasurementCreateInput, MeasurementUncheckedCreateInput>
  }


  /**
   * Measurement createMany
   */
  export type MeasurementCreateManyArgs = {
    /**
     * The data used to create many Measurements.
     * 
    **/
    data: Enumerable<MeasurementCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Measurement update
   */
  export type MeasurementUpdateArgs = {
    /**
     * Select specific fields to fetch from the Measurement
     * 
    **/
    select?: MeasurementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeasurementInclude | null
    /**
     * The data needed to update a Measurement.
     * 
    **/
    data: XOR<MeasurementUpdateInput, MeasurementUncheckedUpdateInput>
    /**
     * Choose, which Measurement to update.
     * 
    **/
    where: MeasurementWhereUniqueInput
  }


  /**
   * Measurement updateMany
   */
  export type MeasurementUpdateManyArgs = {
    /**
     * The data used to update Measurements.
     * 
    **/
    data: XOR<MeasurementUpdateManyMutationInput, MeasurementUncheckedUpdateManyInput>
    /**
     * Filter which Measurements to update
     * 
    **/
    where?: MeasurementWhereInput
  }


  /**
   * Measurement upsert
   */
  export type MeasurementUpsertArgs = {
    /**
     * Select specific fields to fetch from the Measurement
     * 
    **/
    select?: MeasurementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeasurementInclude | null
    /**
     * The filter to search for the Measurement to update in case it exists.
     * 
    **/
    where: MeasurementWhereUniqueInput
    /**
     * In case the Measurement found by the `where` argument doesn't exist, create a new Measurement with this data.
     * 
    **/
    create: XOR<MeasurementCreateInput, MeasurementUncheckedCreateInput>
    /**
     * In case the Measurement was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<MeasurementUpdateInput, MeasurementUncheckedUpdateInput>
  }


  /**
   * Measurement delete
   */
  export type MeasurementDeleteArgs = {
    /**
     * Select specific fields to fetch from the Measurement
     * 
    **/
    select?: MeasurementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeasurementInclude | null
    /**
     * Filter which Measurement to delete.
     * 
    **/
    where: MeasurementWhereUniqueInput
  }


  /**
   * Measurement deleteMany
   */
  export type MeasurementDeleteManyArgs = {
    /**
     * Filter which Measurements to delete
     * 
    **/
    where?: MeasurementWhereInput
  }


  /**
   * Measurement without action
   */
  export type MeasurementArgs = {
    /**
     * Select specific fields to fetch from the Measurement
     * 
    **/
    select?: MeasurementSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: MeasurementInclude | null
  }



  /**
   * Model Serving
   */


  export type AggregateServing = {
    _count: ServingCountAggregateOutputType | null
    _avg: ServingAvgAggregateOutputType | null
    _sum: ServingSumAggregateOutputType | null
    _min: ServingMinAggregateOutputType | null
    _max: ServingMaxAggregateOutputType | null
  }

  export type ServingAvgAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type ServingSumAggregateOutputType = {
    id: number | null
    measurementId: number | null
  }

  export type ServingMinAggregateOutputType = {
    id: number | null
    name: string | null
    measurementId: number | null
  }

  export type ServingMaxAggregateOutputType = {
    id: number | null
    name: string | null
    measurementId: number | null
  }

  export type ServingCountAggregateOutputType = {
    id: number
    name: number
    measurementId: number
    _all: number
  }


  export type ServingAvgAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type ServingSumAggregateInputType = {
    id?: true
    measurementId?: true
  }

  export type ServingMinAggregateInputType = {
    id?: true
    name?: true
    measurementId?: true
  }

  export type ServingMaxAggregateInputType = {
    id?: true
    name?: true
    measurementId?: true
  }

  export type ServingCountAggregateInputType = {
    id?: true
    name?: true
    measurementId?: true
    _all?: true
  }

  export type ServingAggregateArgs = {
    /**
     * Filter which Serving to aggregate.
     * 
    **/
    where?: ServingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servings to fetch.
     * 
    **/
    orderBy?: Enumerable<ServingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ServingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Servings
    **/
    _count?: true | ServingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServingMaxAggregateInputType
  }

  export type GetServingAggregateType<T extends ServingAggregateArgs> = {
        [P in keyof T & keyof AggregateServing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServing[P]>
      : GetScalarType<T[P], AggregateServing[P]>
  }




  export type ServingGroupByArgs = {
    where?: ServingWhereInput
    orderBy?: Enumerable<ServingOrderByWithAggregationInput>
    by: Array<ServingScalarFieldEnum>
    having?: ServingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServingCountAggregateInputType | true
    _avg?: ServingAvgAggregateInputType
    _sum?: ServingSumAggregateInputType
    _min?: ServingMinAggregateInputType
    _max?: ServingMaxAggregateInputType
  }


  export type ServingGroupByOutputType = {
    id: number
    name: string
    measurementId: number
    _count: ServingCountAggregateOutputType | null
    _avg: ServingAvgAggregateOutputType | null
    _sum: ServingSumAggregateOutputType | null
    _min: ServingMinAggregateOutputType | null
    _max: ServingMaxAggregateOutputType | null
  }

  type GetServingGroupByPayload<T extends ServingGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ServingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServingGroupByOutputType[P]>
            : GetScalarType<T[P], ServingGroupByOutputType[P]>
        }
      >
    >


  export type ServingSelect = {
    id?: boolean
    name?: boolean
    measurement?: boolean | MeasurementArgs
    measurementId?: boolean
    products?: boolean | ProductFindManyArgs
    _count?: boolean | ServingCountOutputTypeArgs
  }

  export type ServingInclude = {
    measurement?: boolean | MeasurementArgs
    products?: boolean | ProductFindManyArgs
    _count?: boolean | ServingCountOutputTypeArgs
  }

  export type ServingGetPayload<
    S extends boolean | null | undefined | ServingArgs,
    U = keyof S
      > = S extends true
        ? Serving
    : S extends undefined
    ? never
    : S extends ServingArgs | ServingFindManyArgs
    ?'include' extends U
    ? Serving  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['include'][P]> :
        P extends 'products' ? Array < ProductGetPayload<S['include'][P]>>  :
        P extends '_count' ? ServingCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurement' ? MeasurementGetPayload<S['select'][P]> :
        P extends 'products' ? Array < ProductGetPayload<S['select'][P]>>  :
        P extends '_count' ? ServingCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Serving ? Serving[P] : never
  } 
    : Serving
  : Serving


  type ServingCountArgs = Merge<
    Omit<ServingFindManyArgs, 'select' | 'include'> & {
      select?: ServingCountAggregateInputType | true
    }
  >

  export interface ServingDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Serving that matches the filter.
     * @param {ServingFindUniqueArgs} args - Arguments to find a Serving
     * @example
     * // Get one Serving
     * const serving = await prisma.serving.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ServingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ServingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Serving'> extends True ? CheckSelect<T, Prisma__ServingClient<Serving>, Prisma__ServingClient<ServingGetPayload<T>>> : CheckSelect<T, Prisma__ServingClient<Serving | null >, Prisma__ServingClient<ServingGetPayload<T> | null >>

    /**
     * Find the first Serving that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServingFindFirstArgs} args - Arguments to find a Serving
     * @example
     * // Get one Serving
     * const serving = await prisma.serving.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ServingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ServingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Serving'> extends True ? CheckSelect<T, Prisma__ServingClient<Serving>, Prisma__ServingClient<ServingGetPayload<T>>> : CheckSelect<T, Prisma__ServingClient<Serving | null >, Prisma__ServingClient<ServingGetPayload<T> | null >>

    /**
     * Find zero or more Servings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Servings
     * const servings = await prisma.serving.findMany()
     * 
     * // Get first 10 Servings
     * const servings = await prisma.serving.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servingWithIdOnly = await prisma.serving.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ServingFindManyArgs>(
      args?: SelectSubset<T, ServingFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Serving>>, PrismaPromise<Array<ServingGetPayload<T>>>>

    /**
     * Create a Serving.
     * @param {ServingCreateArgs} args - Arguments to create a Serving.
     * @example
     * // Create one Serving
     * const Serving = await prisma.serving.create({
     *   data: {
     *     // ... data to create a Serving
     *   }
     * })
     * 
    **/
    create<T extends ServingCreateArgs>(
      args: SelectSubset<T, ServingCreateArgs>
    ): CheckSelect<T, Prisma__ServingClient<Serving>, Prisma__ServingClient<ServingGetPayload<T>>>

    /**
     * Create many Servings.
     *     @param {ServingCreateManyArgs} args - Arguments to create many Servings.
     *     @example
     *     // Create many Servings
     *     const serving = await prisma.serving.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ServingCreateManyArgs>(
      args?: SelectSubset<T, ServingCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Serving.
     * @param {ServingDeleteArgs} args - Arguments to delete one Serving.
     * @example
     * // Delete one Serving
     * const Serving = await prisma.serving.delete({
     *   where: {
     *     // ... filter to delete one Serving
     *   }
     * })
     * 
    **/
    delete<T extends ServingDeleteArgs>(
      args: SelectSubset<T, ServingDeleteArgs>
    ): CheckSelect<T, Prisma__ServingClient<Serving>, Prisma__ServingClient<ServingGetPayload<T>>>

    /**
     * Update one Serving.
     * @param {ServingUpdateArgs} args - Arguments to update one Serving.
     * @example
     * // Update one Serving
     * const serving = await prisma.serving.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ServingUpdateArgs>(
      args: SelectSubset<T, ServingUpdateArgs>
    ): CheckSelect<T, Prisma__ServingClient<Serving>, Prisma__ServingClient<ServingGetPayload<T>>>

    /**
     * Delete zero or more Servings.
     * @param {ServingDeleteManyArgs} args - Arguments to filter Servings to delete.
     * @example
     * // Delete a few Servings
     * const { count } = await prisma.serving.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ServingDeleteManyArgs>(
      args?: SelectSubset<T, ServingDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Servings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Servings
     * const serving = await prisma.serving.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ServingUpdateManyArgs>(
      args: SelectSubset<T, ServingUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Serving.
     * @param {ServingUpsertArgs} args - Arguments to update or create a Serving.
     * @example
     * // Update or create a Serving
     * const serving = await prisma.serving.upsert({
     *   create: {
     *     // ... data to create a Serving
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Serving we want to update
     *   }
     * })
    **/
    upsert<T extends ServingUpsertArgs>(
      args: SelectSubset<T, ServingUpsertArgs>
    ): CheckSelect<T, Prisma__ServingClient<Serving>, Prisma__ServingClient<ServingGetPayload<T>>>

    /**
     * Count the number of Servings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServingCountArgs} args - Arguments to filter Servings to count.
     * @example
     * // Count the number of Servings
     * const count = await prisma.serving.count({
     *   where: {
     *     // ... the filter for the Servings we want to count
     *   }
     * })
    **/
    count<T extends ServingCountArgs>(
      args?: Subset<T, ServingCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Serving.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServingAggregateArgs>(args: Subset<T, ServingAggregateArgs>): PrismaPromise<GetServingAggregateType<T>>

    /**
     * Group by Serving.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServingGroupByArgs['orderBy'] }
        : { orderBy?: ServingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServingGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Serving.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ServingClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurement<T extends MeasurementArgs = {}>(args?: Subset<T, MeasurementArgs>): CheckSelect<T, Prisma__MeasurementClient<Measurement | null >, Prisma__MeasurementClient<MeasurementGetPayload<T> | null >>;

    products<T extends ProductFindManyArgs = {}>(args?: Subset<T, ProductFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Serving findUnique
   */
  export type ServingFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Serving
     * 
    **/
    select?: ServingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServingInclude | null
    /**
     * Throw an Error if a Serving can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Serving to fetch.
     * 
    **/
    where: ServingWhereUniqueInput
  }


  /**
   * Serving findFirst
   */
  export type ServingFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Serving
     * 
    **/
    select?: ServingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServingInclude | null
    /**
     * Throw an Error if a Serving can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Serving to fetch.
     * 
    **/
    where?: ServingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servings to fetch.
     * 
    **/
    orderBy?: Enumerable<ServingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Servings.
     * 
    **/
    cursor?: ServingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servings.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Servings.
     * 
    **/
    distinct?: Enumerable<ServingScalarFieldEnum>
  }


  /**
   * Serving findMany
   */
  export type ServingFindManyArgs = {
    /**
     * Select specific fields to fetch from the Serving
     * 
    **/
    select?: ServingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServingInclude | null
    /**
     * Filter, which Servings to fetch.
     * 
    **/
    where?: ServingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Servings to fetch.
     * 
    **/
    orderBy?: Enumerable<ServingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Servings.
     * 
    **/
    cursor?: ServingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Servings from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Servings.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ServingScalarFieldEnum>
  }


  /**
   * Serving create
   */
  export type ServingCreateArgs = {
    /**
     * Select specific fields to fetch from the Serving
     * 
    **/
    select?: ServingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServingInclude | null
    /**
     * The data needed to create a Serving.
     * 
    **/
    data: XOR<ServingCreateInput, ServingUncheckedCreateInput>
  }


  /**
   * Serving createMany
   */
  export type ServingCreateManyArgs = {
    /**
     * The data used to create many Servings.
     * 
    **/
    data: Enumerable<ServingCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Serving update
   */
  export type ServingUpdateArgs = {
    /**
     * Select specific fields to fetch from the Serving
     * 
    **/
    select?: ServingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServingInclude | null
    /**
     * The data needed to update a Serving.
     * 
    **/
    data: XOR<ServingUpdateInput, ServingUncheckedUpdateInput>
    /**
     * Choose, which Serving to update.
     * 
    **/
    where: ServingWhereUniqueInput
  }


  /**
   * Serving updateMany
   */
  export type ServingUpdateManyArgs = {
    /**
     * The data used to update Servings.
     * 
    **/
    data: XOR<ServingUpdateManyMutationInput, ServingUncheckedUpdateManyInput>
    /**
     * Filter which Servings to update
     * 
    **/
    where?: ServingWhereInput
  }


  /**
   * Serving upsert
   */
  export type ServingUpsertArgs = {
    /**
     * Select specific fields to fetch from the Serving
     * 
    **/
    select?: ServingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServingInclude | null
    /**
     * The filter to search for the Serving to update in case it exists.
     * 
    **/
    where: ServingWhereUniqueInput
    /**
     * In case the Serving found by the `where` argument doesn't exist, create a new Serving with this data.
     * 
    **/
    create: XOR<ServingCreateInput, ServingUncheckedCreateInput>
    /**
     * In case the Serving was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ServingUpdateInput, ServingUncheckedUpdateInput>
  }


  /**
   * Serving delete
   */
  export type ServingDeleteArgs = {
    /**
     * Select specific fields to fetch from the Serving
     * 
    **/
    select?: ServingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServingInclude | null
    /**
     * Filter which Serving to delete.
     * 
    **/
    where: ServingWhereUniqueInput
  }


  /**
   * Serving deleteMany
   */
  export type ServingDeleteManyArgs = {
    /**
     * Filter which Servings to delete
     * 
    **/
    where?: ServingWhereInput
  }


  /**
   * Serving without action
   */
  export type ServingArgs = {
    /**
     * Select specific fields to fetch from the Serving
     * 
    **/
    select?: ServingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ServingInclude | null
  }



  /**
   * Model Energy
   */


  export type AggregateEnergy = {
    _count: EnergyCountAggregateOutputType | null
    _avg: EnergyAvgAggregateOutputType | null
    _sum: EnergySumAggregateOutputType | null
    _min: EnergyMinAggregateOutputType | null
    _max: EnergyMaxAggregateOutputType | null
  }

  export type EnergyAvgAggregateOutputType = {
    id: number | null
    nutritionFactId: number | null
  }

  export type EnergySumAggregateOutputType = {
    id: number | null
    nutritionFactId: number | null
  }

  export type EnergyMinAggregateOutputType = {
    id: number | null
    nutritionFactId: number | null
  }

  export type EnergyMaxAggregateOutputType = {
    id: number | null
    nutritionFactId: number | null
  }

  export type EnergyCountAggregateOutputType = {
    id: number
    nutritionFactId: number
    _all: number
  }


  export type EnergyAvgAggregateInputType = {
    id?: true
    nutritionFactId?: true
  }

  export type EnergySumAggregateInputType = {
    id?: true
    nutritionFactId?: true
  }

  export type EnergyMinAggregateInputType = {
    id?: true
    nutritionFactId?: true
  }

  export type EnergyMaxAggregateInputType = {
    id?: true
    nutritionFactId?: true
  }

  export type EnergyCountAggregateInputType = {
    id?: true
    nutritionFactId?: true
    _all?: true
  }

  export type EnergyAggregateArgs = {
    /**
     * Filter which Energy to aggregate.
     * 
    **/
    where?: EnergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Energy to fetch.
     * 
    **/
    orderBy?: Enumerable<EnergyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: EnergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Energy from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Energy.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Energy
    **/
    _count?: true | EnergyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EnergyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EnergySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EnergyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EnergyMaxAggregateInputType
  }

  export type GetEnergyAggregateType<T extends EnergyAggregateArgs> = {
        [P in keyof T & keyof AggregateEnergy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEnergy[P]>
      : GetScalarType<T[P], AggregateEnergy[P]>
  }




  export type EnergyGroupByArgs = {
    where?: EnergyWhereInput
    orderBy?: Enumerable<EnergyOrderByWithAggregationInput>
    by: Array<EnergyScalarFieldEnum>
    having?: EnergyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EnergyCountAggregateInputType | true
    _avg?: EnergyAvgAggregateInputType
    _sum?: EnergySumAggregateInputType
    _min?: EnergyMinAggregateInputType
    _max?: EnergyMaxAggregateInputType
  }


  export type EnergyGroupByOutputType = {
    id: number
    nutritionFactId: number
    _count: EnergyCountAggregateOutputType | null
    _avg: EnergyAvgAggregateOutputType | null
    _sum: EnergySumAggregateOutputType | null
    _min: EnergyMinAggregateOutputType | null
    _max: EnergyMaxAggregateOutputType | null
  }

  type GetEnergyGroupByPayload<T extends EnergyGroupByArgs> = PrismaPromise<
    Array<
      PickArray<EnergyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EnergyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EnergyGroupByOutputType[P]>
            : GetScalarType<T[P], EnergyGroupByOutputType[P]>
        }
      >
    >


  export type EnergySelect = {
    id?: boolean
    measurements?: boolean | MeasurementFindManyArgs
    nutritionFactId?: boolean
    nutritionFact?: boolean | NutritionFactArgs
    _count?: boolean | EnergyCountOutputTypeArgs
  }

  export type EnergyInclude = {
    measurements?: boolean | MeasurementFindManyArgs
    nutritionFact?: boolean | NutritionFactArgs
    _count?: boolean | EnergyCountOutputTypeArgs
  }

  export type EnergyGetPayload<
    S extends boolean | null | undefined | EnergyArgs,
    U = keyof S
      > = S extends true
        ? Energy
    : S extends undefined
    ? never
    : S extends EnergyArgs | EnergyFindManyArgs
    ?'include' extends U
    ? Energy  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurements' ? Array < MeasurementGetPayload<S['include'][P]>>  :
        P extends 'nutritionFact' ? NutritionFactGetPayload<S['include'][P]> :
        P extends '_count' ? EnergyCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurements' ? Array < MeasurementGetPayload<S['select'][P]>>  :
        P extends 'nutritionFact' ? NutritionFactGetPayload<S['select'][P]> :
        P extends '_count' ? EnergyCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Energy ? Energy[P] : never
  } 
    : Energy
  : Energy


  type EnergyCountArgs = Merge<
    Omit<EnergyFindManyArgs, 'select' | 'include'> & {
      select?: EnergyCountAggregateInputType | true
    }
  >

  export interface EnergyDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Energy that matches the filter.
     * @param {EnergyFindUniqueArgs} args - Arguments to find a Energy
     * @example
     * // Get one Energy
     * const energy = await prisma.energy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends EnergyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, EnergyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Energy'> extends True ? CheckSelect<T, Prisma__EnergyClient<Energy>, Prisma__EnergyClient<EnergyGetPayload<T>>> : CheckSelect<T, Prisma__EnergyClient<Energy | null >, Prisma__EnergyClient<EnergyGetPayload<T> | null >>

    /**
     * Find the first Energy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnergyFindFirstArgs} args - Arguments to find a Energy
     * @example
     * // Get one Energy
     * const energy = await prisma.energy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends EnergyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, EnergyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Energy'> extends True ? CheckSelect<T, Prisma__EnergyClient<Energy>, Prisma__EnergyClient<EnergyGetPayload<T>>> : CheckSelect<T, Prisma__EnergyClient<Energy | null >, Prisma__EnergyClient<EnergyGetPayload<T> | null >>

    /**
     * Find zero or more Energy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnergyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Energy
     * const energy = await prisma.energy.findMany()
     * 
     * // Get first 10 Energy
     * const energy = await prisma.energy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const energyWithIdOnly = await prisma.energy.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends EnergyFindManyArgs>(
      args?: SelectSubset<T, EnergyFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Energy>>, PrismaPromise<Array<EnergyGetPayload<T>>>>

    /**
     * Create a Energy.
     * @param {EnergyCreateArgs} args - Arguments to create a Energy.
     * @example
     * // Create one Energy
     * const Energy = await prisma.energy.create({
     *   data: {
     *     // ... data to create a Energy
     *   }
     * })
     * 
    **/
    create<T extends EnergyCreateArgs>(
      args: SelectSubset<T, EnergyCreateArgs>
    ): CheckSelect<T, Prisma__EnergyClient<Energy>, Prisma__EnergyClient<EnergyGetPayload<T>>>

    /**
     * Create many Energy.
     *     @param {EnergyCreateManyArgs} args - Arguments to create many Energy.
     *     @example
     *     // Create many Energy
     *     const energy = await prisma.energy.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends EnergyCreateManyArgs>(
      args?: SelectSubset<T, EnergyCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Energy.
     * @param {EnergyDeleteArgs} args - Arguments to delete one Energy.
     * @example
     * // Delete one Energy
     * const Energy = await prisma.energy.delete({
     *   where: {
     *     // ... filter to delete one Energy
     *   }
     * })
     * 
    **/
    delete<T extends EnergyDeleteArgs>(
      args: SelectSubset<T, EnergyDeleteArgs>
    ): CheckSelect<T, Prisma__EnergyClient<Energy>, Prisma__EnergyClient<EnergyGetPayload<T>>>

    /**
     * Update one Energy.
     * @param {EnergyUpdateArgs} args - Arguments to update one Energy.
     * @example
     * // Update one Energy
     * const energy = await prisma.energy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends EnergyUpdateArgs>(
      args: SelectSubset<T, EnergyUpdateArgs>
    ): CheckSelect<T, Prisma__EnergyClient<Energy>, Prisma__EnergyClient<EnergyGetPayload<T>>>

    /**
     * Delete zero or more Energy.
     * @param {EnergyDeleteManyArgs} args - Arguments to filter Energy to delete.
     * @example
     * // Delete a few Energy
     * const { count } = await prisma.energy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends EnergyDeleteManyArgs>(
      args?: SelectSubset<T, EnergyDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Energy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnergyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Energy
     * const energy = await prisma.energy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends EnergyUpdateManyArgs>(
      args: SelectSubset<T, EnergyUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Energy.
     * @param {EnergyUpsertArgs} args - Arguments to update or create a Energy.
     * @example
     * // Update or create a Energy
     * const energy = await prisma.energy.upsert({
     *   create: {
     *     // ... data to create a Energy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Energy we want to update
     *   }
     * })
    **/
    upsert<T extends EnergyUpsertArgs>(
      args: SelectSubset<T, EnergyUpsertArgs>
    ): CheckSelect<T, Prisma__EnergyClient<Energy>, Prisma__EnergyClient<EnergyGetPayload<T>>>

    /**
     * Count the number of Energy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnergyCountArgs} args - Arguments to filter Energy to count.
     * @example
     * // Count the number of Energy
     * const count = await prisma.energy.count({
     *   where: {
     *     // ... the filter for the Energy we want to count
     *   }
     * })
    **/
    count<T extends EnergyCountArgs>(
      args?: Subset<T, EnergyCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EnergyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Energy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnergyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EnergyAggregateArgs>(args: Subset<T, EnergyAggregateArgs>): PrismaPromise<GetEnergyAggregateType<T>>

    /**
     * Group by Energy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EnergyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EnergyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EnergyGroupByArgs['orderBy'] }
        : { orderBy?: EnergyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EnergyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEnergyGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Energy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__EnergyClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurements<T extends MeasurementFindManyArgs = {}>(args?: Subset<T, MeasurementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Measurement>>, PrismaPromise<Array<MeasurementGetPayload<T>>>>;

    nutritionFact<T extends NutritionFactArgs = {}>(args?: Subset<T, NutritionFactArgs>): CheckSelect<T, Prisma__NutritionFactClient<NutritionFact | null >, Prisma__NutritionFactClient<NutritionFactGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Energy findUnique
   */
  export type EnergyFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Energy
     * 
    **/
    select?: EnergySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnergyInclude | null
    /**
     * Throw an Error if a Energy can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Energy to fetch.
     * 
    **/
    where: EnergyWhereUniqueInput
  }


  /**
   * Energy findFirst
   */
  export type EnergyFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Energy
     * 
    **/
    select?: EnergySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnergyInclude | null
    /**
     * Throw an Error if a Energy can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Energy to fetch.
     * 
    **/
    where?: EnergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Energy to fetch.
     * 
    **/
    orderBy?: Enumerable<EnergyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Energy.
     * 
    **/
    cursor?: EnergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Energy from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Energy.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Energy.
     * 
    **/
    distinct?: Enumerable<EnergyScalarFieldEnum>
  }


  /**
   * Energy findMany
   */
  export type EnergyFindManyArgs = {
    /**
     * Select specific fields to fetch from the Energy
     * 
    **/
    select?: EnergySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnergyInclude | null
    /**
     * Filter, which Energy to fetch.
     * 
    **/
    where?: EnergyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Energy to fetch.
     * 
    **/
    orderBy?: Enumerable<EnergyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Energy.
     * 
    **/
    cursor?: EnergyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Energy from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Energy.
     * 
    **/
    skip?: number
    distinct?: Enumerable<EnergyScalarFieldEnum>
  }


  /**
   * Energy create
   */
  export type EnergyCreateArgs = {
    /**
     * Select specific fields to fetch from the Energy
     * 
    **/
    select?: EnergySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnergyInclude | null
    /**
     * The data needed to create a Energy.
     * 
    **/
    data: XOR<EnergyCreateInput, EnergyUncheckedCreateInput>
  }


  /**
   * Energy createMany
   */
  export type EnergyCreateManyArgs = {
    /**
     * The data used to create many Energy.
     * 
    **/
    data: Enumerable<EnergyCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Energy update
   */
  export type EnergyUpdateArgs = {
    /**
     * Select specific fields to fetch from the Energy
     * 
    **/
    select?: EnergySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnergyInclude | null
    /**
     * The data needed to update a Energy.
     * 
    **/
    data: XOR<EnergyUpdateInput, EnergyUncheckedUpdateInput>
    /**
     * Choose, which Energy to update.
     * 
    **/
    where: EnergyWhereUniqueInput
  }


  /**
   * Energy updateMany
   */
  export type EnergyUpdateManyArgs = {
    /**
     * The data used to update Energy.
     * 
    **/
    data: XOR<EnergyUpdateManyMutationInput, EnergyUncheckedUpdateManyInput>
    /**
     * Filter which Energy to update
     * 
    **/
    where?: EnergyWhereInput
  }


  /**
   * Energy upsert
   */
  export type EnergyUpsertArgs = {
    /**
     * Select specific fields to fetch from the Energy
     * 
    **/
    select?: EnergySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnergyInclude | null
    /**
     * The filter to search for the Energy to update in case it exists.
     * 
    **/
    where: EnergyWhereUniqueInput
    /**
     * In case the Energy found by the `where` argument doesn't exist, create a new Energy with this data.
     * 
    **/
    create: XOR<EnergyCreateInput, EnergyUncheckedCreateInput>
    /**
     * In case the Energy was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<EnergyUpdateInput, EnergyUncheckedUpdateInput>
  }


  /**
   * Energy delete
   */
  export type EnergyDeleteArgs = {
    /**
     * Select specific fields to fetch from the Energy
     * 
    **/
    select?: EnergySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnergyInclude | null
    /**
     * Filter which Energy to delete.
     * 
    **/
    where: EnergyWhereUniqueInput
  }


  /**
   * Energy deleteMany
   */
  export type EnergyDeleteManyArgs = {
    /**
     * Filter which Energy to delete
     * 
    **/
    where?: EnergyWhereInput
  }


  /**
   * Energy without action
   */
  export type EnergyArgs = {
    /**
     * Select specific fields to fetch from the Energy
     * 
    **/
    select?: EnergySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: EnergyInclude | null
  }



  /**
   * Model Protein
   */


  export type AggregateProtein = {
    _count: ProteinCountAggregateOutputType | null
    _avg: ProteinAvgAggregateOutputType | null
    _sum: ProteinSumAggregateOutputType | null
    _min: ProteinMinAggregateOutputType | null
    _max: ProteinMaxAggregateOutputType | null
  }

  export type ProteinAvgAggregateOutputType = {
    id: number | null
  }

  export type ProteinSumAggregateOutputType = {
    id: number | null
  }

  export type ProteinMinAggregateOutputType = {
    id: number | null
  }

  export type ProteinMaxAggregateOutputType = {
    id: number | null
  }

  export type ProteinCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type ProteinAvgAggregateInputType = {
    id?: true
  }

  export type ProteinSumAggregateInputType = {
    id?: true
  }

  export type ProteinMinAggregateInputType = {
    id?: true
  }

  export type ProteinMaxAggregateInputType = {
    id?: true
  }

  export type ProteinCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type ProteinAggregateArgs = {
    /**
     * Filter which Protein to aggregate.
     * 
    **/
    where?: ProteinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proteins to fetch.
     * 
    **/
    orderBy?: Enumerable<ProteinOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProteinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proteins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proteins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Proteins
    **/
    _count?: true | ProteinCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProteinAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProteinSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProteinMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProteinMaxAggregateInputType
  }

  export type GetProteinAggregateType<T extends ProteinAggregateArgs> = {
        [P in keyof T & keyof AggregateProtein]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProtein[P]>
      : GetScalarType<T[P], AggregateProtein[P]>
  }




  export type ProteinGroupByArgs = {
    where?: ProteinWhereInput
    orderBy?: Enumerable<ProteinOrderByWithAggregationInput>
    by: Array<ProteinScalarFieldEnum>
    having?: ProteinScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProteinCountAggregateInputType | true
    _avg?: ProteinAvgAggregateInputType
    _sum?: ProteinSumAggregateInputType
    _min?: ProteinMinAggregateInputType
    _max?: ProteinMaxAggregateInputType
  }


  export type ProteinGroupByOutputType = {
    id: number
    _count: ProteinCountAggregateOutputType | null
    _avg: ProteinAvgAggregateOutputType | null
    _sum: ProteinSumAggregateOutputType | null
    _min: ProteinMinAggregateOutputType | null
    _max: ProteinMaxAggregateOutputType | null
  }

  type GetProteinGroupByPayload<T extends ProteinGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProteinGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProteinGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProteinGroupByOutputType[P]>
            : GetScalarType<T[P], ProteinGroupByOutputType[P]>
        }
      >
    >


  export type ProteinSelect = {
    id?: boolean
    measurements?: boolean | MeasurementFindManyArgs
    NutritionFact?: boolean | NutritionFactFindManyArgs
    _count?: boolean | ProteinCountOutputTypeArgs
  }

  export type ProteinInclude = {
    measurements?: boolean | MeasurementFindManyArgs
    NutritionFact?: boolean | NutritionFactFindManyArgs
    _count?: boolean | ProteinCountOutputTypeArgs
  }

  export type ProteinGetPayload<
    S extends boolean | null | undefined | ProteinArgs,
    U = keyof S
      > = S extends true
        ? Protein
    : S extends undefined
    ? never
    : S extends ProteinArgs | ProteinFindManyArgs
    ?'include' extends U
    ? Protein  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurements' ? Array < MeasurementGetPayload<S['include'][P]>>  :
        P extends 'NutritionFact' ? Array < NutritionFactGetPayload<S['include'][P]>>  :
        P extends '_count' ? ProteinCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurements' ? Array < MeasurementGetPayload<S['select'][P]>>  :
        P extends 'NutritionFact' ? Array < NutritionFactGetPayload<S['select'][P]>>  :
        P extends '_count' ? ProteinCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Protein ? Protein[P] : never
  } 
    : Protein
  : Protein


  type ProteinCountArgs = Merge<
    Omit<ProteinFindManyArgs, 'select' | 'include'> & {
      select?: ProteinCountAggregateInputType | true
    }
  >

  export interface ProteinDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Protein that matches the filter.
     * @param {ProteinFindUniqueArgs} args - Arguments to find a Protein
     * @example
     * // Get one Protein
     * const protein = await prisma.protein.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProteinFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProteinFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Protein'> extends True ? CheckSelect<T, Prisma__ProteinClient<Protein>, Prisma__ProteinClient<ProteinGetPayload<T>>> : CheckSelect<T, Prisma__ProteinClient<Protein | null >, Prisma__ProteinClient<ProteinGetPayload<T> | null >>

    /**
     * Find the first Protein that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProteinFindFirstArgs} args - Arguments to find a Protein
     * @example
     * // Get one Protein
     * const protein = await prisma.protein.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProteinFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProteinFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Protein'> extends True ? CheckSelect<T, Prisma__ProteinClient<Protein>, Prisma__ProteinClient<ProteinGetPayload<T>>> : CheckSelect<T, Prisma__ProteinClient<Protein | null >, Prisma__ProteinClient<ProteinGetPayload<T> | null >>

    /**
     * Find zero or more Proteins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProteinFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Proteins
     * const proteins = await prisma.protein.findMany()
     * 
     * // Get first 10 Proteins
     * const proteins = await prisma.protein.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proteinWithIdOnly = await prisma.protein.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProteinFindManyArgs>(
      args?: SelectSubset<T, ProteinFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Protein>>, PrismaPromise<Array<ProteinGetPayload<T>>>>

    /**
     * Create a Protein.
     * @param {ProteinCreateArgs} args - Arguments to create a Protein.
     * @example
     * // Create one Protein
     * const Protein = await prisma.protein.create({
     *   data: {
     *     // ... data to create a Protein
     *   }
     * })
     * 
    **/
    create<T extends ProteinCreateArgs>(
      args: SelectSubset<T, ProteinCreateArgs>
    ): CheckSelect<T, Prisma__ProteinClient<Protein>, Prisma__ProteinClient<ProteinGetPayload<T>>>

    /**
     * Create many Proteins.
     *     @param {ProteinCreateManyArgs} args - Arguments to create many Proteins.
     *     @example
     *     // Create many Proteins
     *     const protein = await prisma.protein.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProteinCreateManyArgs>(
      args?: SelectSubset<T, ProteinCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Protein.
     * @param {ProteinDeleteArgs} args - Arguments to delete one Protein.
     * @example
     * // Delete one Protein
     * const Protein = await prisma.protein.delete({
     *   where: {
     *     // ... filter to delete one Protein
     *   }
     * })
     * 
    **/
    delete<T extends ProteinDeleteArgs>(
      args: SelectSubset<T, ProteinDeleteArgs>
    ): CheckSelect<T, Prisma__ProteinClient<Protein>, Prisma__ProteinClient<ProteinGetPayload<T>>>

    /**
     * Update one Protein.
     * @param {ProteinUpdateArgs} args - Arguments to update one Protein.
     * @example
     * // Update one Protein
     * const protein = await prisma.protein.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProteinUpdateArgs>(
      args: SelectSubset<T, ProteinUpdateArgs>
    ): CheckSelect<T, Prisma__ProteinClient<Protein>, Prisma__ProteinClient<ProteinGetPayload<T>>>

    /**
     * Delete zero or more Proteins.
     * @param {ProteinDeleteManyArgs} args - Arguments to filter Proteins to delete.
     * @example
     * // Delete a few Proteins
     * const { count } = await prisma.protein.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProteinDeleteManyArgs>(
      args?: SelectSubset<T, ProteinDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Proteins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProteinUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Proteins
     * const protein = await prisma.protein.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProteinUpdateManyArgs>(
      args: SelectSubset<T, ProteinUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Protein.
     * @param {ProteinUpsertArgs} args - Arguments to update or create a Protein.
     * @example
     * // Update or create a Protein
     * const protein = await prisma.protein.upsert({
     *   create: {
     *     // ... data to create a Protein
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Protein we want to update
     *   }
     * })
    **/
    upsert<T extends ProteinUpsertArgs>(
      args: SelectSubset<T, ProteinUpsertArgs>
    ): CheckSelect<T, Prisma__ProteinClient<Protein>, Prisma__ProteinClient<ProteinGetPayload<T>>>

    /**
     * Count the number of Proteins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProteinCountArgs} args - Arguments to filter Proteins to count.
     * @example
     * // Count the number of Proteins
     * const count = await prisma.protein.count({
     *   where: {
     *     // ... the filter for the Proteins we want to count
     *   }
     * })
    **/
    count<T extends ProteinCountArgs>(
      args?: Subset<T, ProteinCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProteinCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Protein.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProteinAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProteinAggregateArgs>(args: Subset<T, ProteinAggregateArgs>): PrismaPromise<GetProteinAggregateType<T>>

    /**
     * Group by Protein.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProteinGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProteinGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProteinGroupByArgs['orderBy'] }
        : { orderBy?: ProteinGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProteinGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProteinGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Protein.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProteinClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurements<T extends MeasurementFindManyArgs = {}>(args?: Subset<T, MeasurementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Measurement>>, PrismaPromise<Array<MeasurementGetPayload<T>>>>;

    NutritionFact<T extends NutritionFactFindManyArgs = {}>(args?: Subset<T, NutritionFactFindManyArgs>): CheckSelect<T, PrismaPromise<Array<NutritionFact>>, PrismaPromise<Array<NutritionFactGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Protein findUnique
   */
  export type ProteinFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Protein
     * 
    **/
    select?: ProteinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProteinInclude | null
    /**
     * Throw an Error if a Protein can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Protein to fetch.
     * 
    **/
    where: ProteinWhereUniqueInput
  }


  /**
   * Protein findFirst
   */
  export type ProteinFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Protein
     * 
    **/
    select?: ProteinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProteinInclude | null
    /**
     * Throw an Error if a Protein can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Protein to fetch.
     * 
    **/
    where?: ProteinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proteins to fetch.
     * 
    **/
    orderBy?: Enumerable<ProteinOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Proteins.
     * 
    **/
    cursor?: ProteinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proteins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proteins.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Proteins.
     * 
    **/
    distinct?: Enumerable<ProteinScalarFieldEnum>
  }


  /**
   * Protein findMany
   */
  export type ProteinFindManyArgs = {
    /**
     * Select specific fields to fetch from the Protein
     * 
    **/
    select?: ProteinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProteinInclude | null
    /**
     * Filter, which Proteins to fetch.
     * 
    **/
    where?: ProteinWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Proteins to fetch.
     * 
    **/
    orderBy?: Enumerable<ProteinOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Proteins.
     * 
    **/
    cursor?: ProteinWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Proteins from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Proteins.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProteinScalarFieldEnum>
  }


  /**
   * Protein create
   */
  export type ProteinCreateArgs = {
    /**
     * Select specific fields to fetch from the Protein
     * 
    **/
    select?: ProteinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProteinInclude | null
    /**
     * The data needed to create a Protein.
     * 
    **/
    data: XOR<ProteinCreateInput, ProteinUncheckedCreateInput>
  }


  /**
   * Protein createMany
   */
  export type ProteinCreateManyArgs = {
    /**
     * The data used to create many Proteins.
     * 
    **/
    data: Enumerable<ProteinCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Protein update
   */
  export type ProteinUpdateArgs = {
    /**
     * Select specific fields to fetch from the Protein
     * 
    **/
    select?: ProteinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProteinInclude | null
    /**
     * The data needed to update a Protein.
     * 
    **/
    data: XOR<ProteinUpdateInput, ProteinUncheckedUpdateInput>
    /**
     * Choose, which Protein to update.
     * 
    **/
    where: ProteinWhereUniqueInput
  }


  /**
   * Protein updateMany
   */
  export type ProteinUpdateManyArgs = {
    /**
     * The data used to update Proteins.
     * 
    **/
    data: XOR<ProteinUpdateManyMutationInput, ProteinUncheckedUpdateManyInput>
    /**
     * Filter which Proteins to update
     * 
    **/
    where?: ProteinWhereInput
  }


  /**
   * Protein upsert
   */
  export type ProteinUpsertArgs = {
    /**
     * Select specific fields to fetch from the Protein
     * 
    **/
    select?: ProteinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProteinInclude | null
    /**
     * The filter to search for the Protein to update in case it exists.
     * 
    **/
    where: ProteinWhereUniqueInput
    /**
     * In case the Protein found by the `where` argument doesn't exist, create a new Protein with this data.
     * 
    **/
    create: XOR<ProteinCreateInput, ProteinUncheckedCreateInput>
    /**
     * In case the Protein was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProteinUpdateInput, ProteinUncheckedUpdateInput>
  }


  /**
   * Protein delete
   */
  export type ProteinDeleteArgs = {
    /**
     * Select specific fields to fetch from the Protein
     * 
    **/
    select?: ProteinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProteinInclude | null
    /**
     * Filter which Protein to delete.
     * 
    **/
    where: ProteinWhereUniqueInput
  }


  /**
   * Protein deleteMany
   */
  export type ProteinDeleteManyArgs = {
    /**
     * Filter which Proteins to delete
     * 
    **/
    where?: ProteinWhereInput
  }


  /**
   * Protein without action
   */
  export type ProteinArgs = {
    /**
     * Select specific fields to fetch from the Protein
     * 
    **/
    select?: ProteinSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProteinInclude | null
  }



  /**
   * Model Cholesterol
   */


  export type AggregateCholesterol = {
    _count: CholesterolCountAggregateOutputType | null
    _avg: CholesterolAvgAggregateOutputType | null
    _sum: CholesterolSumAggregateOutputType | null
    _min: CholesterolMinAggregateOutputType | null
    _max: CholesterolMaxAggregateOutputType | null
  }

  export type CholesterolAvgAggregateOutputType = {
    id: number | null
  }

  export type CholesterolSumAggregateOutputType = {
    id: number | null
  }

  export type CholesterolMinAggregateOutputType = {
    id: number | null
  }

  export type CholesterolMaxAggregateOutputType = {
    id: number | null
  }

  export type CholesterolCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type CholesterolAvgAggregateInputType = {
    id?: true
  }

  export type CholesterolSumAggregateInputType = {
    id?: true
  }

  export type CholesterolMinAggregateInputType = {
    id?: true
  }

  export type CholesterolMaxAggregateInputType = {
    id?: true
  }

  export type CholesterolCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type CholesterolAggregateArgs = {
    /**
     * Filter which Cholesterol to aggregate.
     * 
    **/
    where?: CholesterolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cholesterols to fetch.
     * 
    **/
    orderBy?: Enumerable<CholesterolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: CholesterolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cholesterols from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cholesterols.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Cholesterols
    **/
    _count?: true | CholesterolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CholesterolAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CholesterolSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CholesterolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CholesterolMaxAggregateInputType
  }

  export type GetCholesterolAggregateType<T extends CholesterolAggregateArgs> = {
        [P in keyof T & keyof AggregateCholesterol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCholesterol[P]>
      : GetScalarType<T[P], AggregateCholesterol[P]>
  }




  export type CholesterolGroupByArgs = {
    where?: CholesterolWhereInput
    orderBy?: Enumerable<CholesterolOrderByWithAggregationInput>
    by: Array<CholesterolScalarFieldEnum>
    having?: CholesterolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CholesterolCountAggregateInputType | true
    _avg?: CholesterolAvgAggregateInputType
    _sum?: CholesterolSumAggregateInputType
    _min?: CholesterolMinAggregateInputType
    _max?: CholesterolMaxAggregateInputType
  }


  export type CholesterolGroupByOutputType = {
    id: number
    _count: CholesterolCountAggregateOutputType | null
    _avg: CholesterolAvgAggregateOutputType | null
    _sum: CholesterolSumAggregateOutputType | null
    _min: CholesterolMinAggregateOutputType | null
    _max: CholesterolMaxAggregateOutputType | null
  }

  type GetCholesterolGroupByPayload<T extends CholesterolGroupByArgs> = PrismaPromise<
    Array<
      PickArray<CholesterolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CholesterolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CholesterolGroupByOutputType[P]>
            : GetScalarType<T[P], CholesterolGroupByOutputType[P]>
        }
      >
    >


  export type CholesterolSelect = {
    id?: boolean
    measurements?: boolean | MeasurementFindManyArgs
    NutritionFact?: boolean | NutritionFactFindManyArgs
    _count?: boolean | CholesterolCountOutputTypeArgs
  }

  export type CholesterolInclude = {
    measurements?: boolean | MeasurementFindManyArgs
    NutritionFact?: boolean | NutritionFactFindManyArgs
    _count?: boolean | CholesterolCountOutputTypeArgs
  }

  export type CholesterolGetPayload<
    S extends boolean | null | undefined | CholesterolArgs,
    U = keyof S
      > = S extends true
        ? Cholesterol
    : S extends undefined
    ? never
    : S extends CholesterolArgs | CholesterolFindManyArgs
    ?'include' extends U
    ? Cholesterol  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurements' ? Array < MeasurementGetPayload<S['include'][P]>>  :
        P extends 'NutritionFact' ? Array < NutritionFactGetPayload<S['include'][P]>>  :
        P extends '_count' ? CholesterolCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurements' ? Array < MeasurementGetPayload<S['select'][P]>>  :
        P extends 'NutritionFact' ? Array < NutritionFactGetPayload<S['select'][P]>>  :
        P extends '_count' ? CholesterolCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Cholesterol ? Cholesterol[P] : never
  } 
    : Cholesterol
  : Cholesterol


  type CholesterolCountArgs = Merge<
    Omit<CholesterolFindManyArgs, 'select' | 'include'> & {
      select?: CholesterolCountAggregateInputType | true
    }
  >

  export interface CholesterolDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Cholesterol that matches the filter.
     * @param {CholesterolFindUniqueArgs} args - Arguments to find a Cholesterol
     * @example
     * // Get one Cholesterol
     * const cholesterol = await prisma.cholesterol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends CholesterolFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, CholesterolFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Cholesterol'> extends True ? CheckSelect<T, Prisma__CholesterolClient<Cholesterol>, Prisma__CholesterolClient<CholesterolGetPayload<T>>> : CheckSelect<T, Prisma__CholesterolClient<Cholesterol | null >, Prisma__CholesterolClient<CholesterolGetPayload<T> | null >>

    /**
     * Find the first Cholesterol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CholesterolFindFirstArgs} args - Arguments to find a Cholesterol
     * @example
     * // Get one Cholesterol
     * const cholesterol = await prisma.cholesterol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends CholesterolFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, CholesterolFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Cholesterol'> extends True ? CheckSelect<T, Prisma__CholesterolClient<Cholesterol>, Prisma__CholesterolClient<CholesterolGetPayload<T>>> : CheckSelect<T, Prisma__CholesterolClient<Cholesterol | null >, Prisma__CholesterolClient<CholesterolGetPayload<T> | null >>

    /**
     * Find zero or more Cholesterols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CholesterolFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cholesterols
     * const cholesterols = await prisma.cholesterol.findMany()
     * 
     * // Get first 10 Cholesterols
     * const cholesterols = await prisma.cholesterol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cholesterolWithIdOnly = await prisma.cholesterol.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends CholesterolFindManyArgs>(
      args?: SelectSubset<T, CholesterolFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Cholesterol>>, PrismaPromise<Array<CholesterolGetPayload<T>>>>

    /**
     * Create a Cholesterol.
     * @param {CholesterolCreateArgs} args - Arguments to create a Cholesterol.
     * @example
     * // Create one Cholesterol
     * const Cholesterol = await prisma.cholesterol.create({
     *   data: {
     *     // ... data to create a Cholesterol
     *   }
     * })
     * 
    **/
    create<T extends CholesterolCreateArgs>(
      args: SelectSubset<T, CholesterolCreateArgs>
    ): CheckSelect<T, Prisma__CholesterolClient<Cholesterol>, Prisma__CholesterolClient<CholesterolGetPayload<T>>>

    /**
     * Create many Cholesterols.
     *     @param {CholesterolCreateManyArgs} args - Arguments to create many Cholesterols.
     *     @example
     *     // Create many Cholesterols
     *     const cholesterol = await prisma.cholesterol.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends CholesterolCreateManyArgs>(
      args?: SelectSubset<T, CholesterolCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Cholesterol.
     * @param {CholesterolDeleteArgs} args - Arguments to delete one Cholesterol.
     * @example
     * // Delete one Cholesterol
     * const Cholesterol = await prisma.cholesterol.delete({
     *   where: {
     *     // ... filter to delete one Cholesterol
     *   }
     * })
     * 
    **/
    delete<T extends CholesterolDeleteArgs>(
      args: SelectSubset<T, CholesterolDeleteArgs>
    ): CheckSelect<T, Prisma__CholesterolClient<Cholesterol>, Prisma__CholesterolClient<CholesterolGetPayload<T>>>

    /**
     * Update one Cholesterol.
     * @param {CholesterolUpdateArgs} args - Arguments to update one Cholesterol.
     * @example
     * // Update one Cholesterol
     * const cholesterol = await prisma.cholesterol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends CholesterolUpdateArgs>(
      args: SelectSubset<T, CholesterolUpdateArgs>
    ): CheckSelect<T, Prisma__CholesterolClient<Cholesterol>, Prisma__CholesterolClient<CholesterolGetPayload<T>>>

    /**
     * Delete zero or more Cholesterols.
     * @param {CholesterolDeleteManyArgs} args - Arguments to filter Cholesterols to delete.
     * @example
     * // Delete a few Cholesterols
     * const { count } = await prisma.cholesterol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends CholesterolDeleteManyArgs>(
      args?: SelectSubset<T, CholesterolDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cholesterols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CholesterolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cholesterols
     * const cholesterol = await prisma.cholesterol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends CholesterolUpdateManyArgs>(
      args: SelectSubset<T, CholesterolUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Cholesterol.
     * @param {CholesterolUpsertArgs} args - Arguments to update or create a Cholesterol.
     * @example
     * // Update or create a Cholesterol
     * const cholesterol = await prisma.cholesterol.upsert({
     *   create: {
     *     // ... data to create a Cholesterol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cholesterol we want to update
     *   }
     * })
    **/
    upsert<T extends CholesterolUpsertArgs>(
      args: SelectSubset<T, CholesterolUpsertArgs>
    ): CheckSelect<T, Prisma__CholesterolClient<Cholesterol>, Prisma__CholesterolClient<CholesterolGetPayload<T>>>

    /**
     * Count the number of Cholesterols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CholesterolCountArgs} args - Arguments to filter Cholesterols to count.
     * @example
     * // Count the number of Cholesterols
     * const count = await prisma.cholesterol.count({
     *   where: {
     *     // ... the filter for the Cholesterols we want to count
     *   }
     * })
    **/
    count<T extends CholesterolCountArgs>(
      args?: Subset<T, CholesterolCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CholesterolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cholesterol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CholesterolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CholesterolAggregateArgs>(args: Subset<T, CholesterolAggregateArgs>): PrismaPromise<GetCholesterolAggregateType<T>>

    /**
     * Group by Cholesterol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CholesterolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CholesterolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CholesterolGroupByArgs['orderBy'] }
        : { orderBy?: CholesterolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CholesterolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCholesterolGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Cholesterol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__CholesterolClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurements<T extends MeasurementFindManyArgs = {}>(args?: Subset<T, MeasurementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Measurement>>, PrismaPromise<Array<MeasurementGetPayload<T>>>>;

    NutritionFact<T extends NutritionFactFindManyArgs = {}>(args?: Subset<T, NutritionFactFindManyArgs>): CheckSelect<T, PrismaPromise<Array<NutritionFact>>, PrismaPromise<Array<NutritionFactGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Cholesterol findUnique
   */
  export type CholesterolFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Cholesterol
     * 
    **/
    select?: CholesterolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CholesterolInclude | null
    /**
     * Throw an Error if a Cholesterol can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Cholesterol to fetch.
     * 
    **/
    where: CholesterolWhereUniqueInput
  }


  /**
   * Cholesterol findFirst
   */
  export type CholesterolFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Cholesterol
     * 
    **/
    select?: CholesterolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CholesterolInclude | null
    /**
     * Throw an Error if a Cholesterol can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Cholesterol to fetch.
     * 
    **/
    where?: CholesterolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cholesterols to fetch.
     * 
    **/
    orderBy?: Enumerable<CholesterolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Cholesterols.
     * 
    **/
    cursor?: CholesterolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cholesterols from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cholesterols.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Cholesterols.
     * 
    **/
    distinct?: Enumerable<CholesterolScalarFieldEnum>
  }


  /**
   * Cholesterol findMany
   */
  export type CholesterolFindManyArgs = {
    /**
     * Select specific fields to fetch from the Cholesterol
     * 
    **/
    select?: CholesterolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CholesterolInclude | null
    /**
     * Filter, which Cholesterols to fetch.
     * 
    **/
    where?: CholesterolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Cholesterols to fetch.
     * 
    **/
    orderBy?: Enumerable<CholesterolOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Cholesterols.
     * 
    **/
    cursor?: CholesterolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Cholesterols from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Cholesterols.
     * 
    **/
    skip?: number
    distinct?: Enumerable<CholesterolScalarFieldEnum>
  }


  /**
   * Cholesterol create
   */
  export type CholesterolCreateArgs = {
    /**
     * Select specific fields to fetch from the Cholesterol
     * 
    **/
    select?: CholesterolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CholesterolInclude | null
    /**
     * The data needed to create a Cholesterol.
     * 
    **/
    data: XOR<CholesterolCreateInput, CholesterolUncheckedCreateInput>
  }


  /**
   * Cholesterol createMany
   */
  export type CholesterolCreateManyArgs = {
    /**
     * The data used to create many Cholesterols.
     * 
    **/
    data: Enumerable<CholesterolCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Cholesterol update
   */
  export type CholesterolUpdateArgs = {
    /**
     * Select specific fields to fetch from the Cholesterol
     * 
    **/
    select?: CholesterolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CholesterolInclude | null
    /**
     * The data needed to update a Cholesterol.
     * 
    **/
    data: XOR<CholesterolUpdateInput, CholesterolUncheckedUpdateInput>
    /**
     * Choose, which Cholesterol to update.
     * 
    **/
    where: CholesterolWhereUniqueInput
  }


  /**
   * Cholesterol updateMany
   */
  export type CholesterolUpdateManyArgs = {
    /**
     * The data used to update Cholesterols.
     * 
    **/
    data: XOR<CholesterolUpdateManyMutationInput, CholesterolUncheckedUpdateManyInput>
    /**
     * Filter which Cholesterols to update
     * 
    **/
    where?: CholesterolWhereInput
  }


  /**
   * Cholesterol upsert
   */
  export type CholesterolUpsertArgs = {
    /**
     * Select specific fields to fetch from the Cholesterol
     * 
    **/
    select?: CholesterolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CholesterolInclude | null
    /**
     * The filter to search for the Cholesterol to update in case it exists.
     * 
    **/
    where: CholesterolWhereUniqueInput
    /**
     * In case the Cholesterol found by the `where` argument doesn't exist, create a new Cholesterol with this data.
     * 
    **/
    create: XOR<CholesterolCreateInput, CholesterolUncheckedCreateInput>
    /**
     * In case the Cholesterol was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<CholesterolUpdateInput, CholesterolUncheckedUpdateInput>
  }


  /**
   * Cholesterol delete
   */
  export type CholesterolDeleteArgs = {
    /**
     * Select specific fields to fetch from the Cholesterol
     * 
    **/
    select?: CholesterolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CholesterolInclude | null
    /**
     * Filter which Cholesterol to delete.
     * 
    **/
    where: CholesterolWhereUniqueInput
  }


  /**
   * Cholesterol deleteMany
   */
  export type CholesterolDeleteManyArgs = {
    /**
     * Filter which Cholesterols to delete
     * 
    **/
    where?: CholesterolWhereInput
  }


  /**
   * Cholesterol without action
   */
  export type CholesterolArgs = {
    /**
     * Select specific fields to fetch from the Cholesterol
     * 
    **/
    select?: CholesterolSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: CholesterolInclude | null
  }



  /**
   * Model Fiber
   */


  export type AggregateFiber = {
    _count: FiberCountAggregateOutputType | null
    _avg: FiberAvgAggregateOutputType | null
    _sum: FiberSumAggregateOutputType | null
    _min: FiberMinAggregateOutputType | null
    _max: FiberMaxAggregateOutputType | null
  }

  export type FiberAvgAggregateOutputType = {
    id: number | null
  }

  export type FiberSumAggregateOutputType = {
    id: number | null
  }

  export type FiberMinAggregateOutputType = {
    id: number | null
  }

  export type FiberMaxAggregateOutputType = {
    id: number | null
  }

  export type FiberCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type FiberAvgAggregateInputType = {
    id?: true
  }

  export type FiberSumAggregateInputType = {
    id?: true
  }

  export type FiberMinAggregateInputType = {
    id?: true
  }

  export type FiberMaxAggregateInputType = {
    id?: true
  }

  export type FiberCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type FiberAggregateArgs = {
    /**
     * Filter which Fiber to aggregate.
     * 
    **/
    where?: FiberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fibers to fetch.
     * 
    **/
    orderBy?: Enumerable<FiberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: FiberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fibers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fibers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fibers
    **/
    _count?: true | FiberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FiberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FiberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FiberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FiberMaxAggregateInputType
  }

  export type GetFiberAggregateType<T extends FiberAggregateArgs> = {
        [P in keyof T & keyof AggregateFiber]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFiber[P]>
      : GetScalarType<T[P], AggregateFiber[P]>
  }




  export type FiberGroupByArgs = {
    where?: FiberWhereInput
    orderBy?: Enumerable<FiberOrderByWithAggregationInput>
    by: Array<FiberScalarFieldEnum>
    having?: FiberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FiberCountAggregateInputType | true
    _avg?: FiberAvgAggregateInputType
    _sum?: FiberSumAggregateInputType
    _min?: FiberMinAggregateInputType
    _max?: FiberMaxAggregateInputType
  }


  export type FiberGroupByOutputType = {
    id: number
    _count: FiberCountAggregateOutputType | null
    _avg: FiberAvgAggregateOutputType | null
    _sum: FiberSumAggregateOutputType | null
    _min: FiberMinAggregateOutputType | null
    _max: FiberMaxAggregateOutputType | null
  }

  type GetFiberGroupByPayload<T extends FiberGroupByArgs> = PrismaPromise<
    Array<
      PickArray<FiberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FiberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FiberGroupByOutputType[P]>
            : GetScalarType<T[P], FiberGroupByOutputType[P]>
        }
      >
    >


  export type FiberSelect = {
    id?: boolean
    measurements?: boolean | MeasurementFindManyArgs
    NutritionFact?: boolean | NutritionFactFindManyArgs
    _count?: boolean | FiberCountOutputTypeArgs
  }

  export type FiberInclude = {
    measurements?: boolean | MeasurementFindManyArgs
    NutritionFact?: boolean | NutritionFactFindManyArgs
    _count?: boolean | FiberCountOutputTypeArgs
  }

  export type FiberGetPayload<
    S extends boolean | null | undefined | FiberArgs,
    U = keyof S
      > = S extends true
        ? Fiber
    : S extends undefined
    ? never
    : S extends FiberArgs | FiberFindManyArgs
    ?'include' extends U
    ? Fiber  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurements' ? Array < MeasurementGetPayload<S['include'][P]>>  :
        P extends 'NutritionFact' ? Array < NutritionFactGetPayload<S['include'][P]>>  :
        P extends '_count' ? FiberCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurements' ? Array < MeasurementGetPayload<S['select'][P]>>  :
        P extends 'NutritionFact' ? Array < NutritionFactGetPayload<S['select'][P]>>  :
        P extends '_count' ? FiberCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Fiber ? Fiber[P] : never
  } 
    : Fiber
  : Fiber


  type FiberCountArgs = Merge<
    Omit<FiberFindManyArgs, 'select' | 'include'> & {
      select?: FiberCountAggregateInputType | true
    }
  >

  export interface FiberDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Fiber that matches the filter.
     * @param {FiberFindUniqueArgs} args - Arguments to find a Fiber
     * @example
     * // Get one Fiber
     * const fiber = await prisma.fiber.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends FiberFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, FiberFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Fiber'> extends True ? CheckSelect<T, Prisma__FiberClient<Fiber>, Prisma__FiberClient<FiberGetPayload<T>>> : CheckSelect<T, Prisma__FiberClient<Fiber | null >, Prisma__FiberClient<FiberGetPayload<T> | null >>

    /**
     * Find the first Fiber that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiberFindFirstArgs} args - Arguments to find a Fiber
     * @example
     * // Get one Fiber
     * const fiber = await prisma.fiber.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends FiberFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, FiberFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Fiber'> extends True ? CheckSelect<T, Prisma__FiberClient<Fiber>, Prisma__FiberClient<FiberGetPayload<T>>> : CheckSelect<T, Prisma__FiberClient<Fiber | null >, Prisma__FiberClient<FiberGetPayload<T> | null >>

    /**
     * Find zero or more Fibers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fibers
     * const fibers = await prisma.fiber.findMany()
     * 
     * // Get first 10 Fibers
     * const fibers = await prisma.fiber.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fiberWithIdOnly = await prisma.fiber.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends FiberFindManyArgs>(
      args?: SelectSubset<T, FiberFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Fiber>>, PrismaPromise<Array<FiberGetPayload<T>>>>

    /**
     * Create a Fiber.
     * @param {FiberCreateArgs} args - Arguments to create a Fiber.
     * @example
     * // Create one Fiber
     * const Fiber = await prisma.fiber.create({
     *   data: {
     *     // ... data to create a Fiber
     *   }
     * })
     * 
    **/
    create<T extends FiberCreateArgs>(
      args: SelectSubset<T, FiberCreateArgs>
    ): CheckSelect<T, Prisma__FiberClient<Fiber>, Prisma__FiberClient<FiberGetPayload<T>>>

    /**
     * Create many Fibers.
     *     @param {FiberCreateManyArgs} args - Arguments to create many Fibers.
     *     @example
     *     // Create many Fibers
     *     const fiber = await prisma.fiber.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends FiberCreateManyArgs>(
      args?: SelectSubset<T, FiberCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Fiber.
     * @param {FiberDeleteArgs} args - Arguments to delete one Fiber.
     * @example
     * // Delete one Fiber
     * const Fiber = await prisma.fiber.delete({
     *   where: {
     *     // ... filter to delete one Fiber
     *   }
     * })
     * 
    **/
    delete<T extends FiberDeleteArgs>(
      args: SelectSubset<T, FiberDeleteArgs>
    ): CheckSelect<T, Prisma__FiberClient<Fiber>, Prisma__FiberClient<FiberGetPayload<T>>>

    /**
     * Update one Fiber.
     * @param {FiberUpdateArgs} args - Arguments to update one Fiber.
     * @example
     * // Update one Fiber
     * const fiber = await prisma.fiber.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends FiberUpdateArgs>(
      args: SelectSubset<T, FiberUpdateArgs>
    ): CheckSelect<T, Prisma__FiberClient<Fiber>, Prisma__FiberClient<FiberGetPayload<T>>>

    /**
     * Delete zero or more Fibers.
     * @param {FiberDeleteManyArgs} args - Arguments to filter Fibers to delete.
     * @example
     * // Delete a few Fibers
     * const { count } = await prisma.fiber.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends FiberDeleteManyArgs>(
      args?: SelectSubset<T, FiberDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fibers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fibers
     * const fiber = await prisma.fiber.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends FiberUpdateManyArgs>(
      args: SelectSubset<T, FiberUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Fiber.
     * @param {FiberUpsertArgs} args - Arguments to update or create a Fiber.
     * @example
     * // Update or create a Fiber
     * const fiber = await prisma.fiber.upsert({
     *   create: {
     *     // ... data to create a Fiber
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fiber we want to update
     *   }
     * })
    **/
    upsert<T extends FiberUpsertArgs>(
      args: SelectSubset<T, FiberUpsertArgs>
    ): CheckSelect<T, Prisma__FiberClient<Fiber>, Prisma__FiberClient<FiberGetPayload<T>>>

    /**
     * Count the number of Fibers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiberCountArgs} args - Arguments to filter Fibers to count.
     * @example
     * // Count the number of Fibers
     * const count = await prisma.fiber.count({
     *   where: {
     *     // ... the filter for the Fibers we want to count
     *   }
     * })
    **/
    count<T extends FiberCountArgs>(
      args?: Subset<T, FiberCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FiberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fiber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FiberAggregateArgs>(args: Subset<T, FiberAggregateArgs>): PrismaPromise<GetFiberAggregateType<T>>

    /**
     * Group by Fiber.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FiberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FiberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FiberGroupByArgs['orderBy'] }
        : { orderBy?: FiberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FiberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFiberGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fiber.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__FiberClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurements<T extends MeasurementFindManyArgs = {}>(args?: Subset<T, MeasurementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Measurement>>, PrismaPromise<Array<MeasurementGetPayload<T>>>>;

    NutritionFact<T extends NutritionFactFindManyArgs = {}>(args?: Subset<T, NutritionFactFindManyArgs>): CheckSelect<T, PrismaPromise<Array<NutritionFact>>, PrismaPromise<Array<NutritionFactGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Fiber findUnique
   */
  export type FiberFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Fiber
     * 
    **/
    select?: FiberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FiberInclude | null
    /**
     * Throw an Error if a Fiber can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Fiber to fetch.
     * 
    **/
    where: FiberWhereUniqueInput
  }


  /**
   * Fiber findFirst
   */
  export type FiberFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Fiber
     * 
    **/
    select?: FiberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FiberInclude | null
    /**
     * Throw an Error if a Fiber can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Fiber to fetch.
     * 
    **/
    where?: FiberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fibers to fetch.
     * 
    **/
    orderBy?: Enumerable<FiberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fibers.
     * 
    **/
    cursor?: FiberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fibers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fibers.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fibers.
     * 
    **/
    distinct?: Enumerable<FiberScalarFieldEnum>
  }


  /**
   * Fiber findMany
   */
  export type FiberFindManyArgs = {
    /**
     * Select specific fields to fetch from the Fiber
     * 
    **/
    select?: FiberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FiberInclude | null
    /**
     * Filter, which Fibers to fetch.
     * 
    **/
    where?: FiberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fibers to fetch.
     * 
    **/
    orderBy?: Enumerable<FiberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fibers.
     * 
    **/
    cursor?: FiberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fibers from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fibers.
     * 
    **/
    skip?: number
    distinct?: Enumerable<FiberScalarFieldEnum>
  }


  /**
   * Fiber create
   */
  export type FiberCreateArgs = {
    /**
     * Select specific fields to fetch from the Fiber
     * 
    **/
    select?: FiberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FiberInclude | null
    /**
     * The data needed to create a Fiber.
     * 
    **/
    data: XOR<FiberCreateInput, FiberUncheckedCreateInput>
  }


  /**
   * Fiber createMany
   */
  export type FiberCreateManyArgs = {
    /**
     * The data used to create many Fibers.
     * 
    **/
    data: Enumerable<FiberCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Fiber update
   */
  export type FiberUpdateArgs = {
    /**
     * Select specific fields to fetch from the Fiber
     * 
    **/
    select?: FiberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FiberInclude | null
    /**
     * The data needed to update a Fiber.
     * 
    **/
    data: XOR<FiberUpdateInput, FiberUncheckedUpdateInput>
    /**
     * Choose, which Fiber to update.
     * 
    **/
    where: FiberWhereUniqueInput
  }


  /**
   * Fiber updateMany
   */
  export type FiberUpdateManyArgs = {
    /**
     * The data used to update Fibers.
     * 
    **/
    data: XOR<FiberUpdateManyMutationInput, FiberUncheckedUpdateManyInput>
    /**
     * Filter which Fibers to update
     * 
    **/
    where?: FiberWhereInput
  }


  /**
   * Fiber upsert
   */
  export type FiberUpsertArgs = {
    /**
     * Select specific fields to fetch from the Fiber
     * 
    **/
    select?: FiberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FiberInclude | null
    /**
     * The filter to search for the Fiber to update in case it exists.
     * 
    **/
    where: FiberWhereUniqueInput
    /**
     * In case the Fiber found by the `where` argument doesn't exist, create a new Fiber with this data.
     * 
    **/
    create: XOR<FiberCreateInput, FiberUncheckedCreateInput>
    /**
     * In case the Fiber was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<FiberUpdateInput, FiberUncheckedUpdateInput>
  }


  /**
   * Fiber delete
   */
  export type FiberDeleteArgs = {
    /**
     * Select specific fields to fetch from the Fiber
     * 
    **/
    select?: FiberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FiberInclude | null
    /**
     * Filter which Fiber to delete.
     * 
    **/
    where: FiberWhereUniqueInput
  }


  /**
   * Fiber deleteMany
   */
  export type FiberDeleteManyArgs = {
    /**
     * Filter which Fibers to delete
     * 
    **/
    where?: FiberWhereInput
  }


  /**
   * Fiber without action
   */
  export type FiberArgs = {
    /**
     * Select specific fields to fetch from the Fiber
     * 
    **/
    select?: FiberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: FiberInclude | null
  }



  /**
   * Model Water
   */


  export type AggregateWater = {
    _count: WaterCountAggregateOutputType | null
    _avg: WaterAvgAggregateOutputType | null
    _sum: WaterSumAggregateOutputType | null
    _min: WaterMinAggregateOutputType | null
    _max: WaterMaxAggregateOutputType | null
  }

  export type WaterAvgAggregateOutputType = {
    id: number | null
  }

  export type WaterSumAggregateOutputType = {
    id: number | null
  }

  export type WaterMinAggregateOutputType = {
    id: number | null
  }

  export type WaterMaxAggregateOutputType = {
    id: number | null
  }

  export type WaterCountAggregateOutputType = {
    id: number
    _all: number
  }


  export type WaterAvgAggregateInputType = {
    id?: true
  }

  export type WaterSumAggregateInputType = {
    id?: true
  }

  export type WaterMinAggregateInputType = {
    id?: true
  }

  export type WaterMaxAggregateInputType = {
    id?: true
  }

  export type WaterCountAggregateInputType = {
    id?: true
    _all?: true
  }

  export type WaterAggregateArgs = {
    /**
     * Filter which Water to aggregate.
     * 
    **/
    where?: WaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Waters to fetch.
     * 
    **/
    orderBy?: Enumerable<WaterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: WaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Waters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Waters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Waters
    **/
    _count?: true | WaterCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WaterAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WaterSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WaterMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WaterMaxAggregateInputType
  }

  export type GetWaterAggregateType<T extends WaterAggregateArgs> = {
        [P in keyof T & keyof AggregateWater]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWater[P]>
      : GetScalarType<T[P], AggregateWater[P]>
  }




  export type WaterGroupByArgs = {
    where?: WaterWhereInput
    orderBy?: Enumerable<WaterOrderByWithAggregationInput>
    by: Array<WaterScalarFieldEnum>
    having?: WaterScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WaterCountAggregateInputType | true
    _avg?: WaterAvgAggregateInputType
    _sum?: WaterSumAggregateInputType
    _min?: WaterMinAggregateInputType
    _max?: WaterMaxAggregateInputType
  }


  export type WaterGroupByOutputType = {
    id: number
    _count: WaterCountAggregateOutputType | null
    _avg: WaterAvgAggregateOutputType | null
    _sum: WaterSumAggregateOutputType | null
    _min: WaterMinAggregateOutputType | null
    _max: WaterMaxAggregateOutputType | null
  }

  type GetWaterGroupByPayload<T extends WaterGroupByArgs> = PrismaPromise<
    Array<
      PickArray<WaterGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WaterGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WaterGroupByOutputType[P]>
            : GetScalarType<T[P], WaterGroupByOutputType[P]>
        }
      >
    >


  export type WaterSelect = {
    id?: boolean
    measurements?: boolean | MeasurementFindManyArgs
    NutritionFact?: boolean | NutritionFactFindManyArgs
    _count?: boolean | WaterCountOutputTypeArgs
  }

  export type WaterInclude = {
    measurements?: boolean | MeasurementFindManyArgs
    NutritionFact?: boolean | NutritionFactFindManyArgs
    _count?: boolean | WaterCountOutputTypeArgs
  }

  export type WaterGetPayload<
    S extends boolean | null | undefined | WaterArgs,
    U = keyof S
      > = S extends true
        ? Water
    : S extends undefined
    ? never
    : S extends WaterArgs | WaterFindManyArgs
    ?'include' extends U
    ? Water  & {
    [P in TrueKeys<S['include']>]:
        P extends 'measurements' ? Array < MeasurementGetPayload<S['include'][P]>>  :
        P extends 'NutritionFact' ? Array < NutritionFactGetPayload<S['include'][P]>>  :
        P extends '_count' ? WaterCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'measurements' ? Array < MeasurementGetPayload<S['select'][P]>>  :
        P extends 'NutritionFact' ? Array < NutritionFactGetPayload<S['select'][P]>>  :
        P extends '_count' ? WaterCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Water ? Water[P] : never
  } 
    : Water
  : Water


  type WaterCountArgs = Merge<
    Omit<WaterFindManyArgs, 'select' | 'include'> & {
      select?: WaterCountAggregateInputType | true
    }
  >

  export interface WaterDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Water that matches the filter.
     * @param {WaterFindUniqueArgs} args - Arguments to find a Water
     * @example
     * // Get one Water
     * const water = await prisma.water.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends WaterFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, WaterFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Water'> extends True ? CheckSelect<T, Prisma__WaterClient<Water>, Prisma__WaterClient<WaterGetPayload<T>>> : CheckSelect<T, Prisma__WaterClient<Water | null >, Prisma__WaterClient<WaterGetPayload<T> | null >>

    /**
     * Find the first Water that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterFindFirstArgs} args - Arguments to find a Water
     * @example
     * // Get one Water
     * const water = await prisma.water.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends WaterFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, WaterFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Water'> extends True ? CheckSelect<T, Prisma__WaterClient<Water>, Prisma__WaterClient<WaterGetPayload<T>>> : CheckSelect<T, Prisma__WaterClient<Water | null >, Prisma__WaterClient<WaterGetPayload<T> | null >>

    /**
     * Find zero or more Waters that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Waters
     * const waters = await prisma.water.findMany()
     * 
     * // Get first 10 Waters
     * const waters = await prisma.water.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const waterWithIdOnly = await prisma.water.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends WaterFindManyArgs>(
      args?: SelectSubset<T, WaterFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Water>>, PrismaPromise<Array<WaterGetPayload<T>>>>

    /**
     * Create a Water.
     * @param {WaterCreateArgs} args - Arguments to create a Water.
     * @example
     * // Create one Water
     * const Water = await prisma.water.create({
     *   data: {
     *     // ... data to create a Water
     *   }
     * })
     * 
    **/
    create<T extends WaterCreateArgs>(
      args: SelectSubset<T, WaterCreateArgs>
    ): CheckSelect<T, Prisma__WaterClient<Water>, Prisma__WaterClient<WaterGetPayload<T>>>

    /**
     * Create many Waters.
     *     @param {WaterCreateManyArgs} args - Arguments to create many Waters.
     *     @example
     *     // Create many Waters
     *     const water = await prisma.water.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends WaterCreateManyArgs>(
      args?: SelectSubset<T, WaterCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Water.
     * @param {WaterDeleteArgs} args - Arguments to delete one Water.
     * @example
     * // Delete one Water
     * const Water = await prisma.water.delete({
     *   where: {
     *     // ... filter to delete one Water
     *   }
     * })
     * 
    **/
    delete<T extends WaterDeleteArgs>(
      args: SelectSubset<T, WaterDeleteArgs>
    ): CheckSelect<T, Prisma__WaterClient<Water>, Prisma__WaterClient<WaterGetPayload<T>>>

    /**
     * Update one Water.
     * @param {WaterUpdateArgs} args - Arguments to update one Water.
     * @example
     * // Update one Water
     * const water = await prisma.water.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends WaterUpdateArgs>(
      args: SelectSubset<T, WaterUpdateArgs>
    ): CheckSelect<T, Prisma__WaterClient<Water>, Prisma__WaterClient<WaterGetPayload<T>>>

    /**
     * Delete zero or more Waters.
     * @param {WaterDeleteManyArgs} args - Arguments to filter Waters to delete.
     * @example
     * // Delete a few Waters
     * const { count } = await prisma.water.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends WaterDeleteManyArgs>(
      args?: SelectSubset<T, WaterDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Waters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Waters
     * const water = await prisma.water.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends WaterUpdateManyArgs>(
      args: SelectSubset<T, WaterUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Water.
     * @param {WaterUpsertArgs} args - Arguments to update or create a Water.
     * @example
     * // Update or create a Water
     * const water = await prisma.water.upsert({
     *   create: {
     *     // ... data to create a Water
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Water we want to update
     *   }
     * })
    **/
    upsert<T extends WaterUpsertArgs>(
      args: SelectSubset<T, WaterUpsertArgs>
    ): CheckSelect<T, Prisma__WaterClient<Water>, Prisma__WaterClient<WaterGetPayload<T>>>

    /**
     * Count the number of Waters.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterCountArgs} args - Arguments to filter Waters to count.
     * @example
     * // Count the number of Waters
     * const count = await prisma.water.count({
     *   where: {
     *     // ... the filter for the Waters we want to count
     *   }
     * })
    **/
    count<T extends WaterCountArgs>(
      args?: Subset<T, WaterCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WaterCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Water.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WaterAggregateArgs>(args: Subset<T, WaterAggregateArgs>): PrismaPromise<GetWaterAggregateType<T>>

    /**
     * Group by Water.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WaterGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WaterGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WaterGroupByArgs['orderBy'] }
        : { orderBy?: WaterGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WaterGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWaterGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Water.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__WaterClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    measurements<T extends MeasurementFindManyArgs = {}>(args?: Subset<T, MeasurementFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Measurement>>, PrismaPromise<Array<MeasurementGetPayload<T>>>>;

    NutritionFact<T extends NutritionFactFindManyArgs = {}>(args?: Subset<T, NutritionFactFindManyArgs>): CheckSelect<T, PrismaPromise<Array<NutritionFact>>, PrismaPromise<Array<NutritionFactGetPayload<T>>>>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Water findUnique
   */
  export type WaterFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Water
     * 
    **/
    select?: WaterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WaterInclude | null
    /**
     * Throw an Error if a Water can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Water to fetch.
     * 
    **/
    where: WaterWhereUniqueInput
  }


  /**
   * Water findFirst
   */
  export type WaterFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Water
     * 
    **/
    select?: WaterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WaterInclude | null
    /**
     * Throw an Error if a Water can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Water to fetch.
     * 
    **/
    where?: WaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Waters to fetch.
     * 
    **/
    orderBy?: Enumerable<WaterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Waters.
     * 
    **/
    cursor?: WaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Waters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Waters.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Waters.
     * 
    **/
    distinct?: Enumerable<WaterScalarFieldEnum>
  }


  /**
   * Water findMany
   */
  export type WaterFindManyArgs = {
    /**
     * Select specific fields to fetch from the Water
     * 
    **/
    select?: WaterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WaterInclude | null
    /**
     * Filter, which Waters to fetch.
     * 
    **/
    where?: WaterWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Waters to fetch.
     * 
    **/
    orderBy?: Enumerable<WaterOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Waters.
     * 
    **/
    cursor?: WaterWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Waters from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Waters.
     * 
    **/
    skip?: number
    distinct?: Enumerable<WaterScalarFieldEnum>
  }


  /**
   * Water create
   */
  export type WaterCreateArgs = {
    /**
     * Select specific fields to fetch from the Water
     * 
    **/
    select?: WaterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WaterInclude | null
    /**
     * The data needed to create a Water.
     * 
    **/
    data: XOR<WaterCreateInput, WaterUncheckedCreateInput>
  }


  /**
   * Water createMany
   */
  export type WaterCreateManyArgs = {
    /**
     * The data used to create many Waters.
     * 
    **/
    data: Enumerable<WaterCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Water update
   */
  export type WaterUpdateArgs = {
    /**
     * Select specific fields to fetch from the Water
     * 
    **/
    select?: WaterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WaterInclude | null
    /**
     * The data needed to update a Water.
     * 
    **/
    data: XOR<WaterUpdateInput, WaterUncheckedUpdateInput>
    /**
     * Choose, which Water to update.
     * 
    **/
    where: WaterWhereUniqueInput
  }


  /**
   * Water updateMany
   */
  export type WaterUpdateManyArgs = {
    /**
     * The data used to update Waters.
     * 
    **/
    data: XOR<WaterUpdateManyMutationInput, WaterUncheckedUpdateManyInput>
    /**
     * Filter which Waters to update
     * 
    **/
    where?: WaterWhereInput
  }


  /**
   * Water upsert
   */
  export type WaterUpsertArgs = {
    /**
     * Select specific fields to fetch from the Water
     * 
    **/
    select?: WaterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WaterInclude | null
    /**
     * The filter to search for the Water to update in case it exists.
     * 
    **/
    where: WaterWhereUniqueInput
    /**
     * In case the Water found by the `where` argument doesn't exist, create a new Water with this data.
     * 
    **/
    create: XOR<WaterCreateInput, WaterUncheckedCreateInput>
    /**
     * In case the Water was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<WaterUpdateInput, WaterUncheckedUpdateInput>
  }


  /**
   * Water delete
   */
  export type WaterDeleteArgs = {
    /**
     * Select specific fields to fetch from the Water
     * 
    **/
    select?: WaterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WaterInclude | null
    /**
     * Filter which Water to delete.
     * 
    **/
    where: WaterWhereUniqueInput
  }


  /**
   * Water deleteMany
   */
  export type WaterDeleteManyArgs = {
    /**
     * Filter which Waters to delete
     * 
    **/
    where?: WaterWhereInput
  }


  /**
   * Water without action
   */
  export type WaterArgs = {
    /**
     * Select specific fields to fetch from the Water
     * 
    **/
    select?: WaterSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: WaterInclude | null
  }



  /**
   * Model NutritionFact
   */


  export type AggregateNutritionFact = {
    _count: NutritionFactCountAggregateOutputType | null
    _avg: NutritionFactAvgAggregateOutputType | null
    _sum: NutritionFactSumAggregateOutputType | null
    _min: NutritionFactMinAggregateOutputType | null
    _max: NutritionFactMaxAggregateOutputType | null
  }

  export type NutritionFactAvgAggregateOutputType = {
    id: number | null
    proteinId: number | null
    fatId: number | null
    carbohydrateId: number | null
    fiberId: number | null
    vitaminId: number | null
    mineralId: number | null
    cholesterolId: number | null
    waterId: number | null
    productId: number | null
  }

  export type NutritionFactSumAggregateOutputType = {
    id: number | null
    proteinId: number | null
    fatId: number | null
    carbohydrateId: number | null
    fiberId: number | null
    vitaminId: number | null
    mineralId: number | null
    cholesterolId: number | null
    waterId: number | null
    productId: number | null
  }

  export type NutritionFactMinAggregateOutputType = {
    id: number | null
    proteinId: number | null
    fatId: number | null
    carbohydrateId: number | null
    fiberId: number | null
    vitaminId: number | null
    mineralId: number | null
    cholesterolId: number | null
    waterId: number | null
    productId: number | null
  }

  export type NutritionFactMaxAggregateOutputType = {
    id: number | null
    proteinId: number | null
    fatId: number | null
    carbohydrateId: number | null
    fiberId: number | null
    vitaminId: number | null
    mineralId: number | null
    cholesterolId: number | null
    waterId: number | null
    productId: number | null
  }

  export type NutritionFactCountAggregateOutputType = {
    id: number
    proteinId: number
    fatId: number
    carbohydrateId: number
    fiberId: number
    vitaminId: number
    mineralId: number
    cholesterolId: number
    waterId: number
    productId: number
    _all: number
  }


  export type NutritionFactAvgAggregateInputType = {
    id?: true
    proteinId?: true
    fatId?: true
    carbohydrateId?: true
    fiberId?: true
    vitaminId?: true
    mineralId?: true
    cholesterolId?: true
    waterId?: true
    productId?: true
  }

  export type NutritionFactSumAggregateInputType = {
    id?: true
    proteinId?: true
    fatId?: true
    carbohydrateId?: true
    fiberId?: true
    vitaminId?: true
    mineralId?: true
    cholesterolId?: true
    waterId?: true
    productId?: true
  }

  export type NutritionFactMinAggregateInputType = {
    id?: true
    proteinId?: true
    fatId?: true
    carbohydrateId?: true
    fiberId?: true
    vitaminId?: true
    mineralId?: true
    cholesterolId?: true
    waterId?: true
    productId?: true
  }

  export type NutritionFactMaxAggregateInputType = {
    id?: true
    proteinId?: true
    fatId?: true
    carbohydrateId?: true
    fiberId?: true
    vitaminId?: true
    mineralId?: true
    cholesterolId?: true
    waterId?: true
    productId?: true
  }

  export type NutritionFactCountAggregateInputType = {
    id?: true
    proteinId?: true
    fatId?: true
    carbohydrateId?: true
    fiberId?: true
    vitaminId?: true
    mineralId?: true
    cholesterolId?: true
    waterId?: true
    productId?: true
    _all?: true
  }

  export type NutritionFactAggregateArgs = {
    /**
     * Filter which NutritionFact to aggregate.
     * 
    **/
    where?: NutritionFactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionFacts to fetch.
     * 
    **/
    orderBy?: Enumerable<NutritionFactOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: NutritionFactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionFacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionFacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned NutritionFacts
    **/
    _count?: true | NutritionFactCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NutritionFactAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NutritionFactSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NutritionFactMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NutritionFactMaxAggregateInputType
  }

  export type GetNutritionFactAggregateType<T extends NutritionFactAggregateArgs> = {
        [P in keyof T & keyof AggregateNutritionFact]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNutritionFact[P]>
      : GetScalarType<T[P], AggregateNutritionFact[P]>
  }




  export type NutritionFactGroupByArgs = {
    where?: NutritionFactWhereInput
    orderBy?: Enumerable<NutritionFactOrderByWithAggregationInput>
    by: Array<NutritionFactScalarFieldEnum>
    having?: NutritionFactScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NutritionFactCountAggregateInputType | true
    _avg?: NutritionFactAvgAggregateInputType
    _sum?: NutritionFactSumAggregateInputType
    _min?: NutritionFactMinAggregateInputType
    _max?: NutritionFactMaxAggregateInputType
  }


  export type NutritionFactGroupByOutputType = {
    id: number
    proteinId: number | null
    fatId: number | null
    carbohydrateId: number | null
    fiberId: number | null
    vitaminId: number | null
    mineralId: number | null
    cholesterolId: number | null
    waterId: number | null
    productId: number | null
    _count: NutritionFactCountAggregateOutputType | null
    _avg: NutritionFactAvgAggregateOutputType | null
    _sum: NutritionFactSumAggregateOutputType | null
    _min: NutritionFactMinAggregateOutputType | null
    _max: NutritionFactMaxAggregateOutputType | null
  }

  type GetNutritionFactGroupByPayload<T extends NutritionFactGroupByArgs> = PrismaPromise<
    Array<
      PickArray<NutritionFactGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NutritionFactGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NutritionFactGroupByOutputType[P]>
            : GetScalarType<T[P], NutritionFactGroupByOutputType[P]>
        }
      >
    >


  export type NutritionFactSelect = {
    id?: boolean
    energy?: boolean | EnergyFindManyArgs
    protein?: boolean | ProteinArgs
    proteinId?: boolean
    fats?: boolean | FatArgs
    fatId?: boolean
    carbohydrate?: boolean | CarbohydrateArgs
    carbohydrateId?: boolean
    fiber?: boolean | FiberArgs
    fiberId?: boolean
    water?: boolean | WaterArgs
    vitamins?: boolean | VitaminArgs
    vitaminId?: boolean
    minerals?: boolean | MineralArgs
    mineralId?: boolean
    cholesterol?: boolean | CholesterolArgs
    cholesterolId?: boolean
    waterId?: boolean
    product?: boolean | ProductArgs
    productId?: boolean
    _count?: boolean | NutritionFactCountOutputTypeArgs
  }

  export type NutritionFactInclude = {
    energy?: boolean | EnergyFindManyArgs
    protein?: boolean | ProteinArgs
    fats?: boolean | FatArgs
    carbohydrate?: boolean | CarbohydrateArgs
    fiber?: boolean | FiberArgs
    water?: boolean | WaterArgs
    vitamins?: boolean | VitaminArgs
    minerals?: boolean | MineralArgs
    cholesterol?: boolean | CholesterolArgs
    product?: boolean | ProductArgs
    _count?: boolean | NutritionFactCountOutputTypeArgs
  }

  export type NutritionFactGetPayload<
    S extends boolean | null | undefined | NutritionFactArgs,
    U = keyof S
      > = S extends true
        ? NutritionFact
    : S extends undefined
    ? never
    : S extends NutritionFactArgs | NutritionFactFindManyArgs
    ?'include' extends U
    ? NutritionFact  & {
    [P in TrueKeys<S['include']>]:
        P extends 'energy' ? Array < EnergyGetPayload<S['include'][P]>>  :
        P extends 'protein' ? ProteinGetPayload<S['include'][P]> | null :
        P extends 'fats' ? FatGetPayload<S['include'][P]> | null :
        P extends 'carbohydrate' ? CarbohydrateGetPayload<S['include'][P]> | null :
        P extends 'fiber' ? FiberGetPayload<S['include'][P]> | null :
        P extends 'water' ? WaterGetPayload<S['include'][P]> | null :
        P extends 'vitamins' ? VitaminGetPayload<S['include'][P]> | null :
        P extends 'minerals' ? MineralGetPayload<S['include'][P]> | null :
        P extends 'cholesterol' ? CholesterolGetPayload<S['include'][P]> | null :
        P extends 'product' ? ProductGetPayload<S['include'][P]> | null :
        P extends '_count' ? NutritionFactCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'energy' ? Array < EnergyGetPayload<S['select'][P]>>  :
        P extends 'protein' ? ProteinGetPayload<S['select'][P]> | null :
        P extends 'fats' ? FatGetPayload<S['select'][P]> | null :
        P extends 'carbohydrate' ? CarbohydrateGetPayload<S['select'][P]> | null :
        P extends 'fiber' ? FiberGetPayload<S['select'][P]> | null :
        P extends 'water' ? WaterGetPayload<S['select'][P]> | null :
        P extends 'vitamins' ? VitaminGetPayload<S['select'][P]> | null :
        P extends 'minerals' ? MineralGetPayload<S['select'][P]> | null :
        P extends 'cholesterol' ? CholesterolGetPayload<S['select'][P]> | null :
        P extends 'product' ? ProductGetPayload<S['select'][P]> | null :
        P extends '_count' ? NutritionFactCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof NutritionFact ? NutritionFact[P] : never
  } 
    : NutritionFact
  : NutritionFact


  type NutritionFactCountArgs = Merge<
    Omit<NutritionFactFindManyArgs, 'select' | 'include'> & {
      select?: NutritionFactCountAggregateInputType | true
    }
  >

  export interface NutritionFactDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one NutritionFact that matches the filter.
     * @param {NutritionFactFindUniqueArgs} args - Arguments to find a NutritionFact
     * @example
     * // Get one NutritionFact
     * const nutritionFact = await prisma.nutritionFact.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends NutritionFactFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, NutritionFactFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'NutritionFact'> extends True ? CheckSelect<T, Prisma__NutritionFactClient<NutritionFact>, Prisma__NutritionFactClient<NutritionFactGetPayload<T>>> : CheckSelect<T, Prisma__NutritionFactClient<NutritionFact | null >, Prisma__NutritionFactClient<NutritionFactGetPayload<T> | null >>

    /**
     * Find the first NutritionFact that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionFactFindFirstArgs} args - Arguments to find a NutritionFact
     * @example
     * // Get one NutritionFact
     * const nutritionFact = await prisma.nutritionFact.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends NutritionFactFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, NutritionFactFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'NutritionFact'> extends True ? CheckSelect<T, Prisma__NutritionFactClient<NutritionFact>, Prisma__NutritionFactClient<NutritionFactGetPayload<T>>> : CheckSelect<T, Prisma__NutritionFactClient<NutritionFact | null >, Prisma__NutritionFactClient<NutritionFactGetPayload<T> | null >>

    /**
     * Find zero or more NutritionFacts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionFactFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all NutritionFacts
     * const nutritionFacts = await prisma.nutritionFact.findMany()
     * 
     * // Get first 10 NutritionFacts
     * const nutritionFacts = await prisma.nutritionFact.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const nutritionFactWithIdOnly = await prisma.nutritionFact.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends NutritionFactFindManyArgs>(
      args?: SelectSubset<T, NutritionFactFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<NutritionFact>>, PrismaPromise<Array<NutritionFactGetPayload<T>>>>

    /**
     * Create a NutritionFact.
     * @param {NutritionFactCreateArgs} args - Arguments to create a NutritionFact.
     * @example
     * // Create one NutritionFact
     * const NutritionFact = await prisma.nutritionFact.create({
     *   data: {
     *     // ... data to create a NutritionFact
     *   }
     * })
     * 
    **/
    create<T extends NutritionFactCreateArgs>(
      args: SelectSubset<T, NutritionFactCreateArgs>
    ): CheckSelect<T, Prisma__NutritionFactClient<NutritionFact>, Prisma__NutritionFactClient<NutritionFactGetPayload<T>>>

    /**
     * Create many NutritionFacts.
     *     @param {NutritionFactCreateManyArgs} args - Arguments to create many NutritionFacts.
     *     @example
     *     // Create many NutritionFacts
     *     const nutritionFact = await prisma.nutritionFact.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends NutritionFactCreateManyArgs>(
      args?: SelectSubset<T, NutritionFactCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a NutritionFact.
     * @param {NutritionFactDeleteArgs} args - Arguments to delete one NutritionFact.
     * @example
     * // Delete one NutritionFact
     * const NutritionFact = await prisma.nutritionFact.delete({
     *   where: {
     *     // ... filter to delete one NutritionFact
     *   }
     * })
     * 
    **/
    delete<T extends NutritionFactDeleteArgs>(
      args: SelectSubset<T, NutritionFactDeleteArgs>
    ): CheckSelect<T, Prisma__NutritionFactClient<NutritionFact>, Prisma__NutritionFactClient<NutritionFactGetPayload<T>>>

    /**
     * Update one NutritionFact.
     * @param {NutritionFactUpdateArgs} args - Arguments to update one NutritionFact.
     * @example
     * // Update one NutritionFact
     * const nutritionFact = await prisma.nutritionFact.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends NutritionFactUpdateArgs>(
      args: SelectSubset<T, NutritionFactUpdateArgs>
    ): CheckSelect<T, Prisma__NutritionFactClient<NutritionFact>, Prisma__NutritionFactClient<NutritionFactGetPayload<T>>>

    /**
     * Delete zero or more NutritionFacts.
     * @param {NutritionFactDeleteManyArgs} args - Arguments to filter NutritionFacts to delete.
     * @example
     * // Delete a few NutritionFacts
     * const { count } = await prisma.nutritionFact.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends NutritionFactDeleteManyArgs>(
      args?: SelectSubset<T, NutritionFactDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more NutritionFacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionFactUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many NutritionFacts
     * const nutritionFact = await prisma.nutritionFact.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends NutritionFactUpdateManyArgs>(
      args: SelectSubset<T, NutritionFactUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one NutritionFact.
     * @param {NutritionFactUpsertArgs} args - Arguments to update or create a NutritionFact.
     * @example
     * // Update or create a NutritionFact
     * const nutritionFact = await prisma.nutritionFact.upsert({
     *   create: {
     *     // ... data to create a NutritionFact
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the NutritionFact we want to update
     *   }
     * })
    **/
    upsert<T extends NutritionFactUpsertArgs>(
      args: SelectSubset<T, NutritionFactUpsertArgs>
    ): CheckSelect<T, Prisma__NutritionFactClient<NutritionFact>, Prisma__NutritionFactClient<NutritionFactGetPayload<T>>>

    /**
     * Count the number of NutritionFacts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionFactCountArgs} args - Arguments to filter NutritionFacts to count.
     * @example
     * // Count the number of NutritionFacts
     * const count = await prisma.nutritionFact.count({
     *   where: {
     *     // ... the filter for the NutritionFacts we want to count
     *   }
     * })
    **/
    count<T extends NutritionFactCountArgs>(
      args?: Subset<T, NutritionFactCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NutritionFactCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a NutritionFact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionFactAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NutritionFactAggregateArgs>(args: Subset<T, NutritionFactAggregateArgs>): PrismaPromise<GetNutritionFactAggregateType<T>>

    /**
     * Group by NutritionFact.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NutritionFactGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NutritionFactGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NutritionFactGroupByArgs['orderBy'] }
        : { orderBy?: NutritionFactGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NutritionFactGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNutritionFactGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for NutritionFact.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__NutritionFactClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    energy<T extends EnergyFindManyArgs = {}>(args?: Subset<T, EnergyFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Energy>>, PrismaPromise<Array<EnergyGetPayload<T>>>>;

    protein<T extends ProteinArgs = {}>(args?: Subset<T, ProteinArgs>): CheckSelect<T, Prisma__ProteinClient<Protein | null >, Prisma__ProteinClient<ProteinGetPayload<T> | null >>;

    fats<T extends FatArgs = {}>(args?: Subset<T, FatArgs>): CheckSelect<T, Prisma__FatClient<Fat | null >, Prisma__FatClient<FatGetPayload<T> | null >>;

    carbohydrate<T extends CarbohydrateArgs = {}>(args?: Subset<T, CarbohydrateArgs>): CheckSelect<T, Prisma__CarbohydrateClient<Carbohydrate | null >, Prisma__CarbohydrateClient<CarbohydrateGetPayload<T> | null >>;

    fiber<T extends FiberArgs = {}>(args?: Subset<T, FiberArgs>): CheckSelect<T, Prisma__FiberClient<Fiber | null >, Prisma__FiberClient<FiberGetPayload<T> | null >>;

    water<T extends WaterArgs = {}>(args?: Subset<T, WaterArgs>): CheckSelect<T, Prisma__WaterClient<Water | null >, Prisma__WaterClient<WaterGetPayload<T> | null >>;

    vitamins<T extends VitaminArgs = {}>(args?: Subset<T, VitaminArgs>): CheckSelect<T, Prisma__VitaminClient<Vitamin | null >, Prisma__VitaminClient<VitaminGetPayload<T> | null >>;

    minerals<T extends MineralArgs = {}>(args?: Subset<T, MineralArgs>): CheckSelect<T, Prisma__MineralClient<Mineral | null >, Prisma__MineralClient<MineralGetPayload<T> | null >>;

    cholesterol<T extends CholesterolArgs = {}>(args?: Subset<T, CholesterolArgs>): CheckSelect<T, Prisma__CholesterolClient<Cholesterol | null >, Prisma__CholesterolClient<CholesterolGetPayload<T> | null >>;

    product<T extends ProductArgs = {}>(args?: Subset<T, ProductArgs>): CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * NutritionFact findUnique
   */
  export type NutritionFactFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the NutritionFact
     * 
    **/
    select?: NutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NutritionFactInclude | null
    /**
     * Throw an Error if a NutritionFact can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which NutritionFact to fetch.
     * 
    **/
    where: NutritionFactWhereUniqueInput
  }


  /**
   * NutritionFact findFirst
   */
  export type NutritionFactFindFirstArgs = {
    /**
     * Select specific fields to fetch from the NutritionFact
     * 
    **/
    select?: NutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NutritionFactInclude | null
    /**
     * Throw an Error if a NutritionFact can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which NutritionFact to fetch.
     * 
    **/
    where?: NutritionFactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionFacts to fetch.
     * 
    **/
    orderBy?: Enumerable<NutritionFactOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for NutritionFacts.
     * 
    **/
    cursor?: NutritionFactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionFacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionFacts.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of NutritionFacts.
     * 
    **/
    distinct?: Enumerable<NutritionFactScalarFieldEnum>
  }


  /**
   * NutritionFact findMany
   */
  export type NutritionFactFindManyArgs = {
    /**
     * Select specific fields to fetch from the NutritionFact
     * 
    **/
    select?: NutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NutritionFactInclude | null
    /**
     * Filter, which NutritionFacts to fetch.
     * 
    **/
    where?: NutritionFactWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of NutritionFacts to fetch.
     * 
    **/
    orderBy?: Enumerable<NutritionFactOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing NutritionFacts.
     * 
    **/
    cursor?: NutritionFactWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` NutritionFacts from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` NutritionFacts.
     * 
    **/
    skip?: number
    distinct?: Enumerable<NutritionFactScalarFieldEnum>
  }


  /**
   * NutritionFact create
   */
  export type NutritionFactCreateArgs = {
    /**
     * Select specific fields to fetch from the NutritionFact
     * 
    **/
    select?: NutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NutritionFactInclude | null
    /**
     * The data needed to create a NutritionFact.
     * 
    **/
    data: XOR<NutritionFactCreateInput, NutritionFactUncheckedCreateInput>
  }


  /**
   * NutritionFact createMany
   */
  export type NutritionFactCreateManyArgs = {
    /**
     * The data used to create many NutritionFacts.
     * 
    **/
    data: Enumerable<NutritionFactCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * NutritionFact update
   */
  export type NutritionFactUpdateArgs = {
    /**
     * Select specific fields to fetch from the NutritionFact
     * 
    **/
    select?: NutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NutritionFactInclude | null
    /**
     * The data needed to update a NutritionFact.
     * 
    **/
    data: XOR<NutritionFactUpdateInput, NutritionFactUncheckedUpdateInput>
    /**
     * Choose, which NutritionFact to update.
     * 
    **/
    where: NutritionFactWhereUniqueInput
  }


  /**
   * NutritionFact updateMany
   */
  export type NutritionFactUpdateManyArgs = {
    /**
     * The data used to update NutritionFacts.
     * 
    **/
    data: XOR<NutritionFactUpdateManyMutationInput, NutritionFactUncheckedUpdateManyInput>
    /**
     * Filter which NutritionFacts to update
     * 
    **/
    where?: NutritionFactWhereInput
  }


  /**
   * NutritionFact upsert
   */
  export type NutritionFactUpsertArgs = {
    /**
     * Select specific fields to fetch from the NutritionFact
     * 
    **/
    select?: NutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NutritionFactInclude | null
    /**
     * The filter to search for the NutritionFact to update in case it exists.
     * 
    **/
    where: NutritionFactWhereUniqueInput
    /**
     * In case the NutritionFact found by the `where` argument doesn't exist, create a new NutritionFact with this data.
     * 
    **/
    create: XOR<NutritionFactCreateInput, NutritionFactUncheckedCreateInput>
    /**
     * In case the NutritionFact was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<NutritionFactUpdateInput, NutritionFactUncheckedUpdateInput>
  }


  /**
   * NutritionFact delete
   */
  export type NutritionFactDeleteArgs = {
    /**
     * Select specific fields to fetch from the NutritionFact
     * 
    **/
    select?: NutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NutritionFactInclude | null
    /**
     * Filter which NutritionFact to delete.
     * 
    **/
    where: NutritionFactWhereUniqueInput
  }


  /**
   * NutritionFact deleteMany
   */
  export type NutritionFactDeleteManyArgs = {
    /**
     * Filter which NutritionFacts to delete
     * 
    **/
    where?: NutritionFactWhereInput
  }


  /**
   * NutritionFact without action
   */
  export type NutritionFactArgs = {
    /**
     * Select specific fields to fetch from the NutritionFact
     * 
    **/
    select?: NutritionFactSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: NutritionFactInclude | null
  }



  /**
   * Model Product
   */


  export type AggregateProduct = {
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  export type ProductAvgAggregateOutputType = {
    id: number | null
    servingId: number | null
    nutritionFactId: number | null
  }

  export type ProductSumAggregateOutputType = {
    id: number | null
    servingId: number | null
    nutritionFactId: number | null
  }

  export type ProductMinAggregateOutputType = {
    id: number | null
    name: string | null
    ean: string | null
    manufacturer: string | null
    group: string | null
    servingId: number | null
    nutritionFactId: number | null
  }

  export type ProductMaxAggregateOutputType = {
    id: number | null
    name: string | null
    ean: string | null
    manufacturer: string | null
    group: string | null
    servingId: number | null
    nutritionFactId: number | null
  }

  export type ProductCountAggregateOutputType = {
    id: number
    name: number
    ean: number
    manufacturer: number
    group: number
    servingId: number
    nutritionFactId: number
    _all: number
  }


  export type ProductAvgAggregateInputType = {
    id?: true
    servingId?: true
    nutritionFactId?: true
  }

  export type ProductSumAggregateInputType = {
    id?: true
    servingId?: true
    nutritionFactId?: true
  }

  export type ProductMinAggregateInputType = {
    id?: true
    name?: true
    ean?: true
    manufacturer?: true
    group?: true
    servingId?: true
    nutritionFactId?: true
  }

  export type ProductMaxAggregateInputType = {
    id?: true
    name?: true
    ean?: true
    manufacturer?: true
    group?: true
    servingId?: true
    nutritionFactId?: true
  }

  export type ProductCountAggregateInputType = {
    id?: true
    name?: true
    ean?: true
    manufacturer?: true
    group?: true
    servingId?: true
    nutritionFactId?: true
    _all?: true
  }

  export type ProductAggregateArgs = {
    /**
     * Filter which Product to aggregate.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Products
    **/
    _count?: true | ProductCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProductAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProductSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProductMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProductMaxAggregateInputType
  }

  export type GetProductAggregateType<T extends ProductAggregateArgs> = {
        [P in keyof T & keyof AggregateProduct]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProduct[P]>
      : GetScalarType<T[P], AggregateProduct[P]>
  }




  export type ProductGroupByArgs = {
    where?: ProductWhereInput
    orderBy?: Enumerable<ProductOrderByWithAggregationInput>
    by: Array<ProductScalarFieldEnum>
    having?: ProductScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProductCountAggregateInputType | true
    _avg?: ProductAvgAggregateInputType
    _sum?: ProductSumAggregateInputType
    _min?: ProductMinAggregateInputType
    _max?: ProductMaxAggregateInputType
  }


  export type ProductGroupByOutputType = {
    id: number
    name: string
    ean: string | null
    manufacturer: string
    group: string
    servingId: number
    nutritionFactId: number | null
    _count: ProductCountAggregateOutputType | null
    _avg: ProductAvgAggregateOutputType | null
    _sum: ProductSumAggregateOutputType | null
    _min: ProductMinAggregateOutputType | null
    _max: ProductMaxAggregateOutputType | null
  }

  type GetProductGroupByPayload<T extends ProductGroupByArgs> = PrismaPromise<
    Array<
      PickArray<ProductGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProductGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProductGroupByOutputType[P]>
            : GetScalarType<T[P], ProductGroupByOutputType[P]>
        }
      >
    >


  export type ProductSelect = {
    id?: boolean
    name?: boolean
    labels?: boolean | LabelFindManyArgs
    ean?: boolean
    manufacturer?: boolean
    group?: boolean
    serving?: boolean | ServingArgs
    servingId?: boolean
    nutritionFact?: boolean | NutritionFactArgs
    nutritionFactId?: boolean
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductInclude = {
    labels?: boolean | LabelFindManyArgs
    serving?: boolean | ServingArgs
    nutritionFact?: boolean | NutritionFactArgs
    _count?: boolean | ProductCountOutputTypeArgs
  }

  export type ProductGetPayload<
    S extends boolean | null | undefined | ProductArgs,
    U = keyof S
      > = S extends true
        ? Product
    : S extends undefined
    ? never
    : S extends ProductArgs | ProductFindManyArgs
    ?'include' extends U
    ? Product  & {
    [P in TrueKeys<S['include']>]:
        P extends 'labels' ? Array < LabelGetPayload<S['include'][P]>>  :
        P extends 'serving' ? ServingGetPayload<S['include'][P]> :
        P extends 'nutritionFact' ? NutritionFactGetPayload<S['include'][P]> | null :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : 'select' extends U
    ? {
    [P in TrueKeys<S['select']>]:
        P extends 'labels' ? Array < LabelGetPayload<S['select'][P]>>  :
        P extends 'serving' ? ServingGetPayload<S['select'][P]> :
        P extends 'nutritionFact' ? NutritionFactGetPayload<S['select'][P]> | null :
        P extends '_count' ? ProductCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof Product ? Product[P] : never
  } 
    : Product
  : Product


  type ProductCountArgs = Merge<
    Omit<ProductFindManyArgs, 'select' | 'include'> & {
      select?: ProductCountAggregateInputType | true
    }
  >

  export interface ProductDelegate<GlobalRejectSettings> {
    /**
     * Find zero or one Product that matches the filter.
     * @param {ProductFindUniqueArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ProductFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, ProductFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find the first Product that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindFirstArgs} args - Arguments to find a Product
     * @example
     * // Get one Product
     * const product = await prisma.product.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ProductFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, ProductFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'Product'> extends True ? CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>> : CheckSelect<T, Prisma__ProductClient<Product | null >, Prisma__ProductClient<ProductGetPayload<T> | null >>

    /**
     * Find zero or more Products that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Products
     * const products = await prisma.product.findMany()
     * 
     * // Get first 10 Products
     * const products = await prisma.product.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const productWithIdOnly = await prisma.product.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends ProductFindManyArgs>(
      args?: SelectSubset<T, ProductFindManyArgs>
    ): CheckSelect<T, PrismaPromise<Array<Product>>, PrismaPromise<Array<ProductGetPayload<T>>>>

    /**
     * Create a Product.
     * @param {ProductCreateArgs} args - Arguments to create a Product.
     * @example
     * // Create one Product
     * const Product = await prisma.product.create({
     *   data: {
     *     // ... data to create a Product
     *   }
     * })
     * 
    **/
    create<T extends ProductCreateArgs>(
      args: SelectSubset<T, ProductCreateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Create many Products.
     *     @param {ProductCreateManyArgs} args - Arguments to create many Products.
     *     @example
     *     // Create many Products
     *     const product = await prisma.product.createMany({
     *       data: {
     *         // ... provide data here
     *       }
     *     })
     *     
    **/
    createMany<T extends ProductCreateManyArgs>(
      args?: SelectSubset<T, ProductCreateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Delete a Product.
     * @param {ProductDeleteArgs} args - Arguments to delete one Product.
     * @example
     * // Delete one Product
     * const Product = await prisma.product.delete({
     *   where: {
     *     // ... filter to delete one Product
     *   }
     * })
     * 
    **/
    delete<T extends ProductDeleteArgs>(
      args: SelectSubset<T, ProductDeleteArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Update one Product.
     * @param {ProductUpdateArgs} args - Arguments to update one Product.
     * @example
     * // Update one Product
     * const product = await prisma.product.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ProductUpdateArgs>(
      args: SelectSubset<T, ProductUpdateArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Delete zero or more Products.
     * @param {ProductDeleteManyArgs} args - Arguments to filter Products to delete.
     * @example
     * // Delete a few Products
     * const { count } = await prisma.product.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ProductDeleteManyArgs>(
      args?: SelectSubset<T, ProductDeleteManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Update zero or more Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Products
     * const product = await prisma.product.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ProductUpdateManyArgs>(
      args: SelectSubset<T, ProductUpdateManyArgs>
    ): PrismaPromise<BatchPayload>

    /**
     * Create or update one Product.
     * @param {ProductUpsertArgs} args - Arguments to update or create a Product.
     * @example
     * // Update or create a Product
     * const product = await prisma.product.upsert({
     *   create: {
     *     // ... data to create a Product
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Product we want to update
     *   }
     * })
    **/
    upsert<T extends ProductUpsertArgs>(
      args: SelectSubset<T, ProductUpsertArgs>
    ): CheckSelect<T, Prisma__ProductClient<Product>, Prisma__ProductClient<ProductGetPayload<T>>>

    /**
     * Count the number of Products.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductCountArgs} args - Arguments to filter Products to count.
     * @example
     * // Count the number of Products
     * const count = await prisma.product.count({
     *   where: {
     *     // ... the filter for the Products we want to count
     *   }
     * })
    **/
    count<T extends ProductCountArgs>(
      args?: Subset<T, ProductCountArgs>,
    ): PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProductCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProductAggregateArgs>(args: Subset<T, ProductAggregateArgs>): PrismaPromise<GetProductAggregateType<T>>

    /**
     * Group by Product.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProductGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProductGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProductGroupByArgs['orderBy'] }
        : { orderBy?: ProductGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProductGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProductGroupByPayload<T> : PrismaPromise<InputErrors>
  }

  /**
   * The delegate class that acts as a "Promise-like" for Product.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__ProductClient<T> implements PrismaPromise<T> {
    [prisma]: true;
    private readonly _dmmf;
    private readonly _fetcher;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    constructor(_dmmf: runtime.DMMFClass, _fetcher: PrismaClientFetcher, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);
    readonly [Symbol.toStringTag]: 'PrismaClientPromise';

    labels<T extends LabelFindManyArgs = {}>(args?: Subset<T, LabelFindManyArgs>): CheckSelect<T, PrismaPromise<Array<Label>>, PrismaPromise<Array<LabelGetPayload<T>>>>;

    serving<T extends ServingArgs = {}>(args?: Subset<T, ServingArgs>): CheckSelect<T, Prisma__ServingClient<Serving | null >, Prisma__ServingClient<ServingGetPayload<T> | null >>;

    nutritionFact<T extends NutritionFactArgs = {}>(args?: Subset<T, NutritionFactArgs>): CheckSelect<T, Prisma__NutritionFactClient<NutritionFact | null >, Prisma__NutritionFactClient<NutritionFactGetPayload<T> | null >>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }

  // Custom InputTypes

  /**
   * Product findUnique
   */
  export type ProductFindUniqueArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product findFirst
   */
  export type ProductFindFirstArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Throw an Error if a Product can't be found
     * 
    **/
    rejectOnNotFound?: RejectOnNotFound
    /**
     * Filter, which Product to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Products.
     * 
    **/
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product findMany
   */
  export type ProductFindManyArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter, which Products to fetch.
     * 
    **/
    where?: ProductWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Products to fetch.
     * 
    **/
    orderBy?: Enumerable<ProductOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Products.
     * 
    **/
    cursor?: ProductWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Products from the position of the cursor.
     * 
    **/
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Products.
     * 
    **/
    skip?: number
    distinct?: Enumerable<ProductScalarFieldEnum>
  }


  /**
   * Product create
   */
  export type ProductCreateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to create a Product.
     * 
    **/
    data: XOR<ProductCreateInput, ProductUncheckedCreateInput>
  }


  /**
   * Product createMany
   */
  export type ProductCreateManyArgs = {
    /**
     * The data used to create many Products.
     * 
    **/
    data: Enumerable<ProductCreateManyInput>
    skipDuplicates?: boolean
  }


  /**
   * Product update
   */
  export type ProductUpdateArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The data needed to update a Product.
     * 
    **/
    data: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
    /**
     * Choose, which Product to update.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product updateMany
   */
  export type ProductUpdateManyArgs = {
    /**
     * The data used to update Products.
     * 
    **/
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyInput>
    /**
     * Filter which Products to update
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product upsert
   */
  export type ProductUpsertArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * The filter to search for the Product to update in case it exists.
     * 
    **/
    where: ProductWhereUniqueInput
    /**
     * In case the Product found by the `where` argument doesn't exist, create a new Product with this data.
     * 
    **/
    create: XOR<ProductCreateInput, ProductUncheckedCreateInput>
    /**
     * In case the Product was found with the provided `where` argument, update it with this data.
     * 
    **/
    update: XOR<ProductUpdateInput, ProductUncheckedUpdateInput>
  }


  /**
   * Product delete
   */
  export type ProductDeleteArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
    /**
     * Filter which Product to delete.
     * 
    **/
    where: ProductWhereUniqueInput
  }


  /**
   * Product deleteMany
   */
  export type ProductDeleteManyArgs = {
    /**
     * Filter which Products to delete
     * 
    **/
    where?: ProductWhereInput
  }


  /**
   * Product without action
   */
  export type ProductArgs = {
    /**
     * Select specific fields to fetch from the Product
     * 
    **/
    select?: ProductSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     * 
    **/
    include?: ProductInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const ResourceScalarFieldEnum: {
    id: 'id',
    displayName: 'displayName',
    slug: 'slug'
  };

  export type ResourceScalarFieldEnum = (typeof ResourceScalarFieldEnum)[keyof typeof ResourceScalarFieldEnum]


  export const LabelScalarFieldEnum: {
    id: 'id',
    name: 'name'
  };

  export type LabelScalarFieldEnum = (typeof LabelScalarFieldEnum)[keyof typeof LabelScalarFieldEnum]


  export const FatScalarFieldEnum: {
    id: 'id',
    totalFatId: 'totalFatId',
    saturatedFatId: 'saturatedFatId',
    monosaturatedFatId: 'monosaturatedFatId',
    polyunsaturatedFatId: 'polyunsaturatedFatId',
    transFatId: 'transFatId'
  };

  export type FatScalarFieldEnum = (typeof FatScalarFieldEnum)[keyof typeof FatScalarFieldEnum]


  export const TotalFatScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type TotalFatScalarFieldEnum = (typeof TotalFatScalarFieldEnum)[keyof typeof TotalFatScalarFieldEnum]


  export const SaturatedFatScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type SaturatedFatScalarFieldEnum = (typeof SaturatedFatScalarFieldEnum)[keyof typeof SaturatedFatScalarFieldEnum]


  export const MonosaturatedFatScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type MonosaturatedFatScalarFieldEnum = (typeof MonosaturatedFatScalarFieldEnum)[keyof typeof MonosaturatedFatScalarFieldEnum]


  export const PolyunsaturatedFatScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type PolyunsaturatedFatScalarFieldEnum = (typeof PolyunsaturatedFatScalarFieldEnum)[keyof typeof PolyunsaturatedFatScalarFieldEnum]


  export const TransFatScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type TransFatScalarFieldEnum = (typeof TransFatScalarFieldEnum)[keyof typeof TransFatScalarFieldEnum]


  export const CarbohydrateScalarFieldEnum: {
    id: 'id',
    totalCarbohydrateId: 'totalCarbohydrateId',
    sugarCarbohydrateId: 'sugarCarbohydrateId'
  };

  export type CarbohydrateScalarFieldEnum = (typeof CarbohydrateScalarFieldEnum)[keyof typeof CarbohydrateScalarFieldEnum]


  export const TotalCarbohydrateScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type TotalCarbohydrateScalarFieldEnum = (typeof TotalCarbohydrateScalarFieldEnum)[keyof typeof TotalCarbohydrateScalarFieldEnum]


  export const SugarCarbohydrateScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type SugarCarbohydrateScalarFieldEnum = (typeof SugarCarbohydrateScalarFieldEnum)[keyof typeof SugarCarbohydrateScalarFieldEnum]


  export const VitaminScalarFieldEnum: {
    id: 'id',
    vitaminCId: 'vitaminCId',
    vitaminAId: 'vitaminAId',
    vitaminDId: 'vitaminDId',
    vitaminEId: 'vitaminEId',
    vitaminB1Id: 'vitaminB1Id',
    vitaminB2Id: 'vitaminB2Id',
    vitaminB6Id: 'vitaminB6Id',
    vitaminB12Id: 'vitaminB12Id'
  };

  export type VitaminScalarFieldEnum = (typeof VitaminScalarFieldEnum)[keyof typeof VitaminScalarFieldEnum]


  export const VitaminCScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type VitaminCScalarFieldEnum = (typeof VitaminCScalarFieldEnum)[keyof typeof VitaminCScalarFieldEnum]


  export const VitaminAScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type VitaminAScalarFieldEnum = (typeof VitaminAScalarFieldEnum)[keyof typeof VitaminAScalarFieldEnum]


  export const VitaminDScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type VitaminDScalarFieldEnum = (typeof VitaminDScalarFieldEnum)[keyof typeof VitaminDScalarFieldEnum]


  export const VitaminEScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type VitaminEScalarFieldEnum = (typeof VitaminEScalarFieldEnum)[keyof typeof VitaminEScalarFieldEnum]


  export const VitaminB1ScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type VitaminB1ScalarFieldEnum = (typeof VitaminB1ScalarFieldEnum)[keyof typeof VitaminB1ScalarFieldEnum]


  export const VitaminB2ScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type VitaminB2ScalarFieldEnum = (typeof VitaminB2ScalarFieldEnum)[keyof typeof VitaminB2ScalarFieldEnum]


  export const VitaminB6ScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type VitaminB6ScalarFieldEnum = (typeof VitaminB6ScalarFieldEnum)[keyof typeof VitaminB6ScalarFieldEnum]


  export const VitaminB12ScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type VitaminB12ScalarFieldEnum = (typeof VitaminB12ScalarFieldEnum)[keyof typeof VitaminB12ScalarFieldEnum]


  export const SaltScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type SaltScalarFieldEnum = (typeof SaltScalarFieldEnum)[keyof typeof SaltScalarFieldEnum]


  export const ZincScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type ZincScalarFieldEnum = (typeof ZincScalarFieldEnum)[keyof typeof ZincScalarFieldEnum]


  export const IronScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type IronScalarFieldEnum = (typeof IronScalarFieldEnum)[keyof typeof IronScalarFieldEnum]


  export const MagnesiumScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type MagnesiumScalarFieldEnum = (typeof MagnesiumScalarFieldEnum)[keyof typeof MagnesiumScalarFieldEnum]


  export const ChlorideScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type ChlorideScalarFieldEnum = (typeof ChlorideScalarFieldEnum)[keyof typeof ChlorideScalarFieldEnum]


  export const ManganeseScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type ManganeseScalarFieldEnum = (typeof ManganeseScalarFieldEnum)[keyof typeof ManganeseScalarFieldEnum]


  export const SulfurScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type SulfurScalarFieldEnum = (typeof SulfurScalarFieldEnum)[keyof typeof SulfurScalarFieldEnum]


  export const PotassiumScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type PotassiumScalarFieldEnum = (typeof PotassiumScalarFieldEnum)[keyof typeof PotassiumScalarFieldEnum]


  export const FluorideScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type FluorideScalarFieldEnum = (typeof FluorideScalarFieldEnum)[keyof typeof FluorideScalarFieldEnum]


  export const PhosphorousScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type PhosphorousScalarFieldEnum = (typeof PhosphorousScalarFieldEnum)[keyof typeof PhosphorousScalarFieldEnum]


  export const CopperScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type CopperScalarFieldEnum = (typeof CopperScalarFieldEnum)[keyof typeof CopperScalarFieldEnum]


  export const IodineScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type IodineScalarFieldEnum = (typeof IodineScalarFieldEnum)[keyof typeof IodineScalarFieldEnum]


  export const CalciumScalarFieldEnum: {
    id: 'id',
    measurementId: 'measurementId'
  };

  export type CalciumScalarFieldEnum = (typeof CalciumScalarFieldEnum)[keyof typeof CalciumScalarFieldEnum]


  export const MineralScalarFieldEnum: {
    id: 'id',
    saltId: 'saltId',
    ironId: 'ironId',
    zincId: 'zincId',
    magnesiumId: 'magnesiumId',
    chlorideId: 'chlorideId',
    manganeseId: 'manganeseId',
    sulfurId: 'sulfurId',
    potassiumId: 'potassiumId',
    fluorideId: 'fluorideId',
    phosphorousId: 'phosphorousId',
    copperId: 'copperId',
    iodineId: 'iodineId',
    calciumId: 'calciumId'
  };

  export type MineralScalarFieldEnum = (typeof MineralScalarFieldEnum)[keyof typeof MineralScalarFieldEnum]


  export const UnitScalarFieldEnum: {
    id: 'id',
    name: 'name',
    abbreviation: 'abbreviation'
  };

  export type UnitScalarFieldEnum = (typeof UnitScalarFieldEnum)[keyof typeof UnitScalarFieldEnum]


  export const MeasurementScalarFieldEnum: {
    id: 'id',
    value: 'value',
    unitId: 'unitId',
    proteinId: 'proteinId',
    cholesterolId: 'cholesterolId',
    fiberId: 'fiberId',
    waterId: 'waterId'
  };

  export type MeasurementScalarFieldEnum = (typeof MeasurementScalarFieldEnum)[keyof typeof MeasurementScalarFieldEnum]


  export const ServingScalarFieldEnum: {
    id: 'id',
    name: 'name',
    measurementId: 'measurementId'
  };

  export type ServingScalarFieldEnum = (typeof ServingScalarFieldEnum)[keyof typeof ServingScalarFieldEnum]


  export const EnergyScalarFieldEnum: {
    id: 'id',
    nutritionFactId: 'nutritionFactId'
  };

  export type EnergyScalarFieldEnum = (typeof EnergyScalarFieldEnum)[keyof typeof EnergyScalarFieldEnum]


  export const ProteinScalarFieldEnum: {
    id: 'id'
  };

  export type ProteinScalarFieldEnum = (typeof ProteinScalarFieldEnum)[keyof typeof ProteinScalarFieldEnum]


  export const CholesterolScalarFieldEnum: {
    id: 'id'
  };

  export type CholesterolScalarFieldEnum = (typeof CholesterolScalarFieldEnum)[keyof typeof CholesterolScalarFieldEnum]


  export const FiberScalarFieldEnum: {
    id: 'id'
  };

  export type FiberScalarFieldEnum = (typeof FiberScalarFieldEnum)[keyof typeof FiberScalarFieldEnum]


  export const WaterScalarFieldEnum: {
    id: 'id'
  };

  export type WaterScalarFieldEnum = (typeof WaterScalarFieldEnum)[keyof typeof WaterScalarFieldEnum]


  export const NutritionFactScalarFieldEnum: {
    id: 'id',
    proteinId: 'proteinId',
    fatId: 'fatId',
    carbohydrateId: 'carbohydrateId',
    fiberId: 'fiberId',
    vitaminId: 'vitaminId',
    mineralId: 'mineralId',
    cholesterolId: 'cholesterolId',
    waterId: 'waterId',
    productId: 'productId'
  };

  export type NutritionFactScalarFieldEnum = (typeof NutritionFactScalarFieldEnum)[keyof typeof NutritionFactScalarFieldEnum]


  export const ProductScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ean: 'ean',
    manufacturer: 'manufacturer',
    group: 'group',
    servingId: 'servingId',
    nutritionFactId: 'nutritionFactId'
  };

  export type ProductScalarFieldEnum = (typeof ProductScalarFieldEnum)[keyof typeof ProductScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  /**
   * Deep Input Types
   */


  export type ResourceWhereInput = {
    AND?: Enumerable<ResourceWhereInput>
    OR?: Enumerable<ResourceWhereInput>
    NOT?: Enumerable<ResourceWhereInput>
    id?: IntFilter | number
    displayName?: StringFilter | string
    slug?: StringFilter | string
  }

  export type ResourceOrderByWithRelationInput = {
    id?: SortOrder
    displayName?: SortOrder
    slug?: SortOrder
  }

  export type ResourceWhereUniqueInput = {
    id?: number
    slug?: string
  }

  export type ResourceOrderByWithAggregationInput = {
    id?: SortOrder
    displayName?: SortOrder
    slug?: SortOrder
    _count?: ResourceCountOrderByAggregateInput
    _avg?: ResourceAvgOrderByAggregateInput
    _max?: ResourceMaxOrderByAggregateInput
    _min?: ResourceMinOrderByAggregateInput
    _sum?: ResourceSumOrderByAggregateInput
  }

  export type ResourceScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ResourceScalarWhereWithAggregatesInput>
    OR?: Enumerable<ResourceScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ResourceScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    displayName?: StringWithAggregatesFilter | string
    slug?: StringWithAggregatesFilter | string
  }

  export type LabelWhereInput = {
    AND?: Enumerable<LabelWhereInput>
    OR?: Enumerable<LabelWhereInput>
    NOT?: Enumerable<LabelWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    products?: ProductListRelationFilter
  }

  export type LabelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type LabelWhereUniqueInput = {
    id?: number
    name?: string
  }

  export type LabelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    _count?: LabelCountOrderByAggregateInput
    _avg?: LabelAvgOrderByAggregateInput
    _max?: LabelMaxOrderByAggregateInput
    _min?: LabelMinOrderByAggregateInput
    _sum?: LabelSumOrderByAggregateInput
  }

  export type LabelScalarWhereWithAggregatesInput = {
    AND?: Enumerable<LabelScalarWhereWithAggregatesInput>
    OR?: Enumerable<LabelScalarWhereWithAggregatesInput>
    NOT?: Enumerable<LabelScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
  }

  export type FatWhereInput = {
    AND?: Enumerable<FatWhereInput>
    OR?: Enumerable<FatWhereInput>
    NOT?: Enumerable<FatWhereInput>
    id?: IntFilter | number
    total?: XOR<TotalFatRelationFilter, TotalFatWhereInput> | null
    totalFatId?: IntFilter | number
    saturated?: XOR<SaturatedFatRelationFilter, SaturatedFatWhereInput> | null
    saturatedFatId?: IntNullableFilter | number | null
    monounsaturated?: XOR<MonosaturatedFatRelationFilter, MonosaturatedFatWhereInput> | null
    monosaturatedFatId?: IntNullableFilter | number | null
    polyunsaturated?: XOR<PolyunsaturatedFatRelationFilter, PolyunsaturatedFatWhereInput> | null
    polyunsaturatedFatId?: IntNullableFilter | number | null
    trans?: XOR<TransFatRelationFilter, TransFatWhereInput> | null
    transFatId?: IntNullableFilter | number | null
    nutritionFacts?: NutritionFactListRelationFilter
  }

  export type FatOrderByWithRelationInput = {
    id?: SortOrder
    total?: TotalFatOrderByWithRelationInput
    totalFatId?: SortOrder
    saturated?: SaturatedFatOrderByWithRelationInput
    saturatedFatId?: SortOrder
    monounsaturated?: MonosaturatedFatOrderByWithRelationInput
    monosaturatedFatId?: SortOrder
    polyunsaturated?: PolyunsaturatedFatOrderByWithRelationInput
    polyunsaturatedFatId?: SortOrder
    trans?: TransFatOrderByWithRelationInput
    transFatId?: SortOrder
    nutritionFacts?: NutritionFactOrderByRelationAggregateInput
  }

  export type FatWhereUniqueInput = {
    id?: number
    totalFatId?: number
    saturatedFatId?: number
    monosaturatedFatId?: number
    polyunsaturatedFatId?: number
    transFatId?: number
  }

  export type FatOrderByWithAggregationInput = {
    id?: SortOrder
    totalFatId?: SortOrder
    saturatedFatId?: SortOrder
    monosaturatedFatId?: SortOrder
    polyunsaturatedFatId?: SortOrder
    transFatId?: SortOrder
    _count?: FatCountOrderByAggregateInput
    _avg?: FatAvgOrderByAggregateInput
    _max?: FatMaxOrderByAggregateInput
    _min?: FatMinOrderByAggregateInput
    _sum?: FatSumOrderByAggregateInput
  }

  export type FatScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FatScalarWhereWithAggregatesInput>
    OR?: Enumerable<FatScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FatScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    totalFatId?: IntWithAggregatesFilter | number
    saturatedFatId?: IntNullableWithAggregatesFilter | number | null
    monosaturatedFatId?: IntNullableWithAggregatesFilter | number | null
    polyunsaturatedFatId?: IntNullableWithAggregatesFilter | number | null
    transFatId?: IntNullableWithAggregatesFilter | number | null
  }

  export type TotalFatWhereInput = {
    AND?: Enumerable<TotalFatWhereInput>
    OR?: Enumerable<TotalFatWhereInput>
    NOT?: Enumerable<TotalFatWhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput> | null
    fat?: XOR<FatRelationFilter, FatWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type TotalFatOrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    fat?: FatOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type TotalFatWhereUniqueInput = {
    id?: number
  }

  export type TotalFatOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: TotalFatCountOrderByAggregateInput
    _avg?: TotalFatAvgOrderByAggregateInput
    _max?: TotalFatMaxOrderByAggregateInput
    _min?: TotalFatMinOrderByAggregateInput
    _sum?: TotalFatSumOrderByAggregateInput
  }

  export type TotalFatScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TotalFatScalarWhereWithAggregatesInput>
    OR?: Enumerable<TotalFatScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TotalFatScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type SaturatedFatWhereInput = {
    AND?: Enumerable<SaturatedFatWhereInput>
    OR?: Enumerable<SaturatedFatWhereInput>
    NOT?: Enumerable<SaturatedFatWhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    fat?: XOR<FatRelationFilter, FatWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type SaturatedFatOrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    fat?: FatOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type SaturatedFatWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type SaturatedFatOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: SaturatedFatCountOrderByAggregateInput
    _avg?: SaturatedFatAvgOrderByAggregateInput
    _max?: SaturatedFatMaxOrderByAggregateInput
    _min?: SaturatedFatMinOrderByAggregateInput
    _sum?: SaturatedFatSumOrderByAggregateInput
  }

  export type SaturatedFatScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SaturatedFatScalarWhereWithAggregatesInput>
    OR?: Enumerable<SaturatedFatScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SaturatedFatScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type MonosaturatedFatWhereInput = {
    AND?: Enumerable<MonosaturatedFatWhereInput>
    OR?: Enumerable<MonosaturatedFatWhereInput>
    NOT?: Enumerable<MonosaturatedFatWhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    fat?: XOR<FatRelationFilter, FatWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type MonosaturatedFatOrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    fat?: FatOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type MonosaturatedFatWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type MonosaturatedFatOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: MonosaturatedFatCountOrderByAggregateInput
    _avg?: MonosaturatedFatAvgOrderByAggregateInput
    _max?: MonosaturatedFatMaxOrderByAggregateInput
    _min?: MonosaturatedFatMinOrderByAggregateInput
    _sum?: MonosaturatedFatSumOrderByAggregateInput
  }

  export type MonosaturatedFatScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MonosaturatedFatScalarWhereWithAggregatesInput>
    OR?: Enumerable<MonosaturatedFatScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MonosaturatedFatScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type PolyunsaturatedFatWhereInput = {
    AND?: Enumerable<PolyunsaturatedFatWhereInput>
    OR?: Enumerable<PolyunsaturatedFatWhereInput>
    NOT?: Enumerable<PolyunsaturatedFatWhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    fat?: XOR<FatRelationFilter, FatWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type PolyunsaturatedFatOrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    fat?: FatOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type PolyunsaturatedFatWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type PolyunsaturatedFatOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: PolyunsaturatedFatCountOrderByAggregateInput
    _avg?: PolyunsaturatedFatAvgOrderByAggregateInput
    _max?: PolyunsaturatedFatMaxOrderByAggregateInput
    _min?: PolyunsaturatedFatMinOrderByAggregateInput
    _sum?: PolyunsaturatedFatSumOrderByAggregateInput
  }

  export type PolyunsaturatedFatScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PolyunsaturatedFatScalarWhereWithAggregatesInput>
    OR?: Enumerable<PolyunsaturatedFatScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PolyunsaturatedFatScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type TransFatWhereInput = {
    AND?: Enumerable<TransFatWhereInput>
    OR?: Enumerable<TransFatWhereInput>
    NOT?: Enumerable<TransFatWhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    fat?: XOR<FatRelationFilter, FatWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type TransFatOrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    fat?: FatOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type TransFatWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type TransFatOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: TransFatCountOrderByAggregateInput
    _avg?: TransFatAvgOrderByAggregateInput
    _max?: TransFatMaxOrderByAggregateInput
    _min?: TransFatMinOrderByAggregateInput
    _sum?: TransFatSumOrderByAggregateInput
  }

  export type TransFatScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TransFatScalarWhereWithAggregatesInput>
    OR?: Enumerable<TransFatScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TransFatScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type CarbohydrateWhereInput = {
    AND?: Enumerable<CarbohydrateWhereInput>
    OR?: Enumerable<CarbohydrateWhereInput>
    NOT?: Enumerable<CarbohydrateWhereInput>
    id?: IntFilter | number
    total?: XOR<TotalCarbohydrateRelationFilter, TotalCarbohydrateWhereInput> | null
    totalCarbohydrateId?: IntNullableFilter | number | null
    sugar?: XOR<SugarCarbohydrateRelationFilter, SugarCarbohydrateWhereInput> | null
    sugarCarbohydrateId?: IntNullableFilter | number | null
    nutritionFacts?: NutritionFactListRelationFilter
  }

  export type CarbohydrateOrderByWithRelationInput = {
    id?: SortOrder
    total?: TotalCarbohydrateOrderByWithRelationInput
    totalCarbohydrateId?: SortOrder
    sugar?: SugarCarbohydrateOrderByWithRelationInput
    sugarCarbohydrateId?: SortOrder
    nutritionFacts?: NutritionFactOrderByRelationAggregateInput
  }

  export type CarbohydrateWhereUniqueInput = {
    id?: number
    totalCarbohydrateId?: number
    sugarCarbohydrateId?: number
  }

  export type CarbohydrateOrderByWithAggregationInput = {
    id?: SortOrder
    totalCarbohydrateId?: SortOrder
    sugarCarbohydrateId?: SortOrder
    _count?: CarbohydrateCountOrderByAggregateInput
    _avg?: CarbohydrateAvgOrderByAggregateInput
    _max?: CarbohydrateMaxOrderByAggregateInput
    _min?: CarbohydrateMinOrderByAggregateInput
    _sum?: CarbohydrateSumOrderByAggregateInput
  }

  export type CarbohydrateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CarbohydrateScalarWhereWithAggregatesInput>
    OR?: Enumerable<CarbohydrateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CarbohydrateScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    totalCarbohydrateId?: IntNullableWithAggregatesFilter | number | null
    sugarCarbohydrateId?: IntNullableWithAggregatesFilter | number | null
  }

  export type TotalCarbohydrateWhereInput = {
    AND?: Enumerable<TotalCarbohydrateWhereInput>
    OR?: Enumerable<TotalCarbohydrateWhereInput>
    NOT?: Enumerable<TotalCarbohydrateWhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    carbohydrate?: XOR<CarbohydrateRelationFilter, CarbohydrateWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type TotalCarbohydrateOrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    carbohydrate?: CarbohydrateOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type TotalCarbohydrateWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type TotalCarbohydrateOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: TotalCarbohydrateCountOrderByAggregateInput
    _avg?: TotalCarbohydrateAvgOrderByAggregateInput
    _max?: TotalCarbohydrateMaxOrderByAggregateInput
    _min?: TotalCarbohydrateMinOrderByAggregateInput
    _sum?: TotalCarbohydrateSumOrderByAggregateInput
  }

  export type TotalCarbohydrateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<TotalCarbohydrateScalarWhereWithAggregatesInput>
    OR?: Enumerable<TotalCarbohydrateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<TotalCarbohydrateScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type SugarCarbohydrateWhereInput = {
    AND?: Enumerable<SugarCarbohydrateWhereInput>
    OR?: Enumerable<SugarCarbohydrateWhereInput>
    NOT?: Enumerable<SugarCarbohydrateWhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    carbohydrate?: XOR<CarbohydrateRelationFilter, CarbohydrateWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type SugarCarbohydrateOrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    carbohydrate?: CarbohydrateOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type SugarCarbohydrateWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type SugarCarbohydrateOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: SugarCarbohydrateCountOrderByAggregateInput
    _avg?: SugarCarbohydrateAvgOrderByAggregateInput
    _max?: SugarCarbohydrateMaxOrderByAggregateInput
    _min?: SugarCarbohydrateMinOrderByAggregateInput
    _sum?: SugarCarbohydrateSumOrderByAggregateInput
  }

  export type SugarCarbohydrateScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SugarCarbohydrateScalarWhereWithAggregatesInput>
    OR?: Enumerable<SugarCarbohydrateScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SugarCarbohydrateScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type VitaminWhereInput = {
    AND?: Enumerable<VitaminWhereInput>
    OR?: Enumerable<VitaminWhereInput>
    NOT?: Enumerable<VitaminWhereInput>
    id?: IntFilter | number
    C?: XOR<VitaminCRelationFilter, VitaminCWhereInput> | null
    A?: XOR<VitaminARelationFilter, VitaminAWhereInput> | null
    D?: XOR<VitaminDRelationFilter, VitaminDWhereInput> | null
    E?: XOR<VitaminERelationFilter, VitaminEWhereInput> | null
    B1?: XOR<VitaminB1RelationFilter, VitaminB1WhereInput> | null
    B2?: XOR<VitaminB2RelationFilter, VitaminB2WhereInput> | null
    B6?: XOR<VitaminB6RelationFilter, VitaminB6WhereInput> | null
    B12?: XOR<VitaminB12RelationFilter, VitaminB12WhereInput> | null
    nutritionFacts?: NutritionFactListRelationFilter
    vitaminCId?: IntNullableFilter | number | null
    vitaminAId?: IntNullableFilter | number | null
    vitaminDId?: IntNullableFilter | number | null
    vitaminEId?: IntNullableFilter | number | null
    vitaminB1Id?: IntNullableFilter | number | null
    vitaminB2Id?: IntNullableFilter | number | null
    vitaminB6Id?: IntNullableFilter | number | null
    vitaminB12Id?: IntNullableFilter | number | null
    measurements?: MeasurementListRelationFilter
  }

  export type VitaminOrderByWithRelationInput = {
    id?: SortOrder
    C?: VitaminCOrderByWithRelationInput
    A?: VitaminAOrderByWithRelationInput
    D?: VitaminDOrderByWithRelationInput
    E?: VitaminEOrderByWithRelationInput
    B1?: VitaminB1OrderByWithRelationInput
    B2?: VitaminB2OrderByWithRelationInput
    B6?: VitaminB6OrderByWithRelationInput
    B12?: VitaminB12OrderByWithRelationInput
    nutritionFacts?: NutritionFactOrderByRelationAggregateInput
    vitaminCId?: SortOrder
    vitaminAId?: SortOrder
    vitaminDId?: SortOrder
    vitaminEId?: SortOrder
    vitaminB1Id?: SortOrder
    vitaminB2Id?: SortOrder
    vitaminB6Id?: SortOrder
    vitaminB12Id?: SortOrder
    measurements?: MeasurementOrderByRelationAggregateInput
  }

  export type VitaminWhereUniqueInput = {
    id?: number
    vitaminCId?: number
    vitaminAId?: number
    vitaminDId?: number
    vitaminEId?: number
    vitaminB1Id?: number
    vitaminB2Id?: number
    vitaminB6Id?: number
    vitaminB12Id?: number
  }

  export type VitaminOrderByWithAggregationInput = {
    id?: SortOrder
    vitaminCId?: SortOrder
    vitaminAId?: SortOrder
    vitaminDId?: SortOrder
    vitaminEId?: SortOrder
    vitaminB1Id?: SortOrder
    vitaminB2Id?: SortOrder
    vitaminB6Id?: SortOrder
    vitaminB12Id?: SortOrder
    _count?: VitaminCountOrderByAggregateInput
    _avg?: VitaminAvgOrderByAggregateInput
    _max?: VitaminMaxOrderByAggregateInput
    _min?: VitaminMinOrderByAggregateInput
    _sum?: VitaminSumOrderByAggregateInput
  }

  export type VitaminScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VitaminScalarWhereWithAggregatesInput>
    OR?: Enumerable<VitaminScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VitaminScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    vitaminCId?: IntNullableWithAggregatesFilter | number | null
    vitaminAId?: IntNullableWithAggregatesFilter | number | null
    vitaminDId?: IntNullableWithAggregatesFilter | number | null
    vitaminEId?: IntNullableWithAggregatesFilter | number | null
    vitaminB1Id?: IntNullableWithAggregatesFilter | number | null
    vitaminB2Id?: IntNullableWithAggregatesFilter | number | null
    vitaminB6Id?: IntNullableWithAggregatesFilter | number | null
    vitaminB12Id?: IntNullableWithAggregatesFilter | number | null
  }

  export type VitaminCWhereInput = {
    AND?: Enumerable<VitaminCWhereInput>
    OR?: Enumerable<VitaminCWhereInput>
    NOT?: Enumerable<VitaminCWhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    vitamin?: XOR<VitaminRelationFilter, VitaminWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type VitaminCOrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    vitamin?: VitaminOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type VitaminCWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type VitaminCOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: VitaminCCountOrderByAggregateInput
    _avg?: VitaminCAvgOrderByAggregateInput
    _max?: VitaminCMaxOrderByAggregateInput
    _min?: VitaminCMinOrderByAggregateInput
    _sum?: VitaminCSumOrderByAggregateInput
  }

  export type VitaminCScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VitaminCScalarWhereWithAggregatesInput>
    OR?: Enumerable<VitaminCScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VitaminCScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type VitaminAWhereInput = {
    AND?: Enumerable<VitaminAWhereInput>
    OR?: Enumerable<VitaminAWhereInput>
    NOT?: Enumerable<VitaminAWhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    vitamin?: XOR<VitaminRelationFilter, VitaminWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type VitaminAOrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    vitamin?: VitaminOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type VitaminAWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type VitaminAOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: VitaminACountOrderByAggregateInput
    _avg?: VitaminAAvgOrderByAggregateInput
    _max?: VitaminAMaxOrderByAggregateInput
    _min?: VitaminAMinOrderByAggregateInput
    _sum?: VitaminASumOrderByAggregateInput
  }

  export type VitaminAScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VitaminAScalarWhereWithAggregatesInput>
    OR?: Enumerable<VitaminAScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VitaminAScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type VitaminDWhereInput = {
    AND?: Enumerable<VitaminDWhereInput>
    OR?: Enumerable<VitaminDWhereInput>
    NOT?: Enumerable<VitaminDWhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    vitamin?: XOR<VitaminRelationFilter, VitaminWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type VitaminDOrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    vitamin?: VitaminOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type VitaminDWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type VitaminDOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: VitaminDCountOrderByAggregateInput
    _avg?: VitaminDAvgOrderByAggregateInput
    _max?: VitaminDMaxOrderByAggregateInput
    _min?: VitaminDMinOrderByAggregateInput
    _sum?: VitaminDSumOrderByAggregateInput
  }

  export type VitaminDScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VitaminDScalarWhereWithAggregatesInput>
    OR?: Enumerable<VitaminDScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VitaminDScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type VitaminEWhereInput = {
    AND?: Enumerable<VitaminEWhereInput>
    OR?: Enumerable<VitaminEWhereInput>
    NOT?: Enumerable<VitaminEWhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    vitamin?: XOR<VitaminRelationFilter, VitaminWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type VitaminEOrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    vitamin?: VitaminOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type VitaminEWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type VitaminEOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: VitaminECountOrderByAggregateInput
    _avg?: VitaminEAvgOrderByAggregateInput
    _max?: VitaminEMaxOrderByAggregateInput
    _min?: VitaminEMinOrderByAggregateInput
    _sum?: VitaminESumOrderByAggregateInput
  }

  export type VitaminEScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VitaminEScalarWhereWithAggregatesInput>
    OR?: Enumerable<VitaminEScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VitaminEScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type VitaminB1WhereInput = {
    AND?: Enumerable<VitaminB1WhereInput>
    OR?: Enumerable<VitaminB1WhereInput>
    NOT?: Enumerable<VitaminB1WhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    vitamin?: XOR<VitaminRelationFilter, VitaminWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type VitaminB1OrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    vitamin?: VitaminOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type VitaminB1WhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type VitaminB1OrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: VitaminB1CountOrderByAggregateInput
    _avg?: VitaminB1AvgOrderByAggregateInput
    _max?: VitaminB1MaxOrderByAggregateInput
    _min?: VitaminB1MinOrderByAggregateInput
    _sum?: VitaminB1SumOrderByAggregateInput
  }

  export type VitaminB1ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VitaminB1ScalarWhereWithAggregatesInput>
    OR?: Enumerable<VitaminB1ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VitaminB1ScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type VitaminB2WhereInput = {
    AND?: Enumerable<VitaminB2WhereInput>
    OR?: Enumerable<VitaminB2WhereInput>
    NOT?: Enumerable<VitaminB2WhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    vitamin?: XOR<VitaminRelationFilter, VitaminWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type VitaminB2OrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    vitamin?: VitaminOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type VitaminB2WhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type VitaminB2OrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: VitaminB2CountOrderByAggregateInput
    _avg?: VitaminB2AvgOrderByAggregateInput
    _max?: VitaminB2MaxOrderByAggregateInput
    _min?: VitaminB2MinOrderByAggregateInput
    _sum?: VitaminB2SumOrderByAggregateInput
  }

  export type VitaminB2ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VitaminB2ScalarWhereWithAggregatesInput>
    OR?: Enumerable<VitaminB2ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VitaminB2ScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type VitaminB6WhereInput = {
    AND?: Enumerable<VitaminB6WhereInput>
    OR?: Enumerable<VitaminB6WhereInput>
    NOT?: Enumerable<VitaminB6WhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    vitamin?: XOR<VitaminRelationFilter, VitaminWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type VitaminB6OrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    vitamin?: VitaminOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type VitaminB6WhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type VitaminB6OrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: VitaminB6CountOrderByAggregateInput
    _avg?: VitaminB6AvgOrderByAggregateInput
    _max?: VitaminB6MaxOrderByAggregateInput
    _min?: VitaminB6MinOrderByAggregateInput
    _sum?: VitaminB6SumOrderByAggregateInput
  }

  export type VitaminB6ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VitaminB6ScalarWhereWithAggregatesInput>
    OR?: Enumerable<VitaminB6ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VitaminB6ScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type VitaminB12WhereInput = {
    AND?: Enumerable<VitaminB12WhereInput>
    OR?: Enumerable<VitaminB12WhereInput>
    NOT?: Enumerable<VitaminB12WhereInput>
    id?: IntFilter | number
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    vitamin?: XOR<VitaminRelationFilter, VitaminWhereInput> | null
    measurementId?: IntFilter | number
  }

  export type VitaminB12OrderByWithRelationInput = {
    id?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    vitamin?: VitaminOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type VitaminB12WhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type VitaminB12OrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: VitaminB12CountOrderByAggregateInput
    _avg?: VitaminB12AvgOrderByAggregateInput
    _max?: VitaminB12MaxOrderByAggregateInput
    _min?: VitaminB12MinOrderByAggregateInput
    _sum?: VitaminB12SumOrderByAggregateInput
  }

  export type VitaminB12ScalarWhereWithAggregatesInput = {
    AND?: Enumerable<VitaminB12ScalarWhereWithAggregatesInput>
    OR?: Enumerable<VitaminB12ScalarWhereWithAggregatesInput>
    NOT?: Enumerable<VitaminB12ScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type SaltWhereInput = {
    AND?: Enumerable<SaltWhereInput>
    OR?: Enumerable<SaltWhereInput>
    NOT?: Enumerable<SaltWhereInput>
    id?: IntFilter | number
    minerals?: MineralListRelationFilter
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    measurementId?: IntFilter | number
  }

  export type SaltOrderByWithRelationInput = {
    id?: SortOrder
    minerals?: MineralOrderByRelationAggregateInput
    measurement?: MeasurementOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type SaltWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type SaltOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: SaltCountOrderByAggregateInput
    _avg?: SaltAvgOrderByAggregateInput
    _max?: SaltMaxOrderByAggregateInput
    _min?: SaltMinOrderByAggregateInput
    _sum?: SaltSumOrderByAggregateInput
  }

  export type SaltScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SaltScalarWhereWithAggregatesInput>
    OR?: Enumerable<SaltScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SaltScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type ZincWhereInput = {
    AND?: Enumerable<ZincWhereInput>
    OR?: Enumerable<ZincWhereInput>
    NOT?: Enumerable<ZincWhereInput>
    id?: IntFilter | number
    minerals?: MineralListRelationFilter
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    measurementId?: IntFilter | number
  }

  export type ZincOrderByWithRelationInput = {
    id?: SortOrder
    minerals?: MineralOrderByRelationAggregateInput
    measurement?: MeasurementOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type ZincWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type ZincOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: ZincCountOrderByAggregateInput
    _avg?: ZincAvgOrderByAggregateInput
    _max?: ZincMaxOrderByAggregateInput
    _min?: ZincMinOrderByAggregateInput
    _sum?: ZincSumOrderByAggregateInput
  }

  export type ZincScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ZincScalarWhereWithAggregatesInput>
    OR?: Enumerable<ZincScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ZincScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type IronWhereInput = {
    AND?: Enumerable<IronWhereInput>
    OR?: Enumerable<IronWhereInput>
    NOT?: Enumerable<IronWhereInput>
    id?: IntFilter | number
    minerals?: MineralListRelationFilter
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    measurementId?: IntFilter | number
  }

  export type IronOrderByWithRelationInput = {
    id?: SortOrder
    minerals?: MineralOrderByRelationAggregateInput
    measurement?: MeasurementOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type IronWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type IronOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: IronCountOrderByAggregateInput
    _avg?: IronAvgOrderByAggregateInput
    _max?: IronMaxOrderByAggregateInput
    _min?: IronMinOrderByAggregateInput
    _sum?: IronSumOrderByAggregateInput
  }

  export type IronScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IronScalarWhereWithAggregatesInput>
    OR?: Enumerable<IronScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IronScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type MagnesiumWhereInput = {
    AND?: Enumerable<MagnesiumWhereInput>
    OR?: Enumerable<MagnesiumWhereInput>
    NOT?: Enumerable<MagnesiumWhereInput>
    id?: IntFilter | number
    minerals?: MineralListRelationFilter
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    measurementId?: IntFilter | number
  }

  export type MagnesiumOrderByWithRelationInput = {
    id?: SortOrder
    minerals?: MineralOrderByRelationAggregateInput
    measurement?: MeasurementOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type MagnesiumWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type MagnesiumOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: MagnesiumCountOrderByAggregateInput
    _avg?: MagnesiumAvgOrderByAggregateInput
    _max?: MagnesiumMaxOrderByAggregateInput
    _min?: MagnesiumMinOrderByAggregateInput
    _sum?: MagnesiumSumOrderByAggregateInput
  }

  export type MagnesiumScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MagnesiumScalarWhereWithAggregatesInput>
    OR?: Enumerable<MagnesiumScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MagnesiumScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type ChlorideWhereInput = {
    AND?: Enumerable<ChlorideWhereInput>
    OR?: Enumerable<ChlorideWhereInput>
    NOT?: Enumerable<ChlorideWhereInput>
    id?: IntFilter | number
    minerals?: MineralListRelationFilter
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    measurementId?: IntFilter | number
  }

  export type ChlorideOrderByWithRelationInput = {
    id?: SortOrder
    minerals?: MineralOrderByRelationAggregateInput
    measurement?: MeasurementOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type ChlorideWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type ChlorideOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: ChlorideCountOrderByAggregateInput
    _avg?: ChlorideAvgOrderByAggregateInput
    _max?: ChlorideMaxOrderByAggregateInput
    _min?: ChlorideMinOrderByAggregateInput
    _sum?: ChlorideSumOrderByAggregateInput
  }

  export type ChlorideScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ChlorideScalarWhereWithAggregatesInput>
    OR?: Enumerable<ChlorideScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ChlorideScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type ManganeseWhereInput = {
    AND?: Enumerable<ManganeseWhereInput>
    OR?: Enumerable<ManganeseWhereInput>
    NOT?: Enumerable<ManganeseWhereInput>
    id?: IntFilter | number
    minerals?: MineralListRelationFilter
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    measurementId?: IntFilter | number
  }

  export type ManganeseOrderByWithRelationInput = {
    id?: SortOrder
    minerals?: MineralOrderByRelationAggregateInput
    measurement?: MeasurementOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type ManganeseWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type ManganeseOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: ManganeseCountOrderByAggregateInput
    _avg?: ManganeseAvgOrderByAggregateInput
    _max?: ManganeseMaxOrderByAggregateInput
    _min?: ManganeseMinOrderByAggregateInput
    _sum?: ManganeseSumOrderByAggregateInput
  }

  export type ManganeseScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ManganeseScalarWhereWithAggregatesInput>
    OR?: Enumerable<ManganeseScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ManganeseScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type SulfurWhereInput = {
    AND?: Enumerable<SulfurWhereInput>
    OR?: Enumerable<SulfurWhereInput>
    NOT?: Enumerable<SulfurWhereInput>
    id?: IntFilter | number
    minerals?: MineralListRelationFilter
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    measurementId?: IntFilter | number
  }

  export type SulfurOrderByWithRelationInput = {
    id?: SortOrder
    minerals?: MineralOrderByRelationAggregateInput
    measurement?: MeasurementOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type SulfurWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type SulfurOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: SulfurCountOrderByAggregateInput
    _avg?: SulfurAvgOrderByAggregateInput
    _max?: SulfurMaxOrderByAggregateInput
    _min?: SulfurMinOrderByAggregateInput
    _sum?: SulfurSumOrderByAggregateInput
  }

  export type SulfurScalarWhereWithAggregatesInput = {
    AND?: Enumerable<SulfurScalarWhereWithAggregatesInput>
    OR?: Enumerable<SulfurScalarWhereWithAggregatesInput>
    NOT?: Enumerable<SulfurScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type PotassiumWhereInput = {
    AND?: Enumerable<PotassiumWhereInput>
    OR?: Enumerable<PotassiumWhereInput>
    NOT?: Enumerable<PotassiumWhereInput>
    id?: IntFilter | number
    minerals?: MineralListRelationFilter
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    measurementId?: IntFilter | number
  }

  export type PotassiumOrderByWithRelationInput = {
    id?: SortOrder
    minerals?: MineralOrderByRelationAggregateInput
    measurement?: MeasurementOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type PotassiumWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type PotassiumOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: PotassiumCountOrderByAggregateInput
    _avg?: PotassiumAvgOrderByAggregateInput
    _max?: PotassiumMaxOrderByAggregateInput
    _min?: PotassiumMinOrderByAggregateInput
    _sum?: PotassiumSumOrderByAggregateInput
  }

  export type PotassiumScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PotassiumScalarWhereWithAggregatesInput>
    OR?: Enumerable<PotassiumScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PotassiumScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type FluorideWhereInput = {
    AND?: Enumerable<FluorideWhereInput>
    OR?: Enumerable<FluorideWhereInput>
    NOT?: Enumerable<FluorideWhereInput>
    id?: IntFilter | number
    minerals?: MineralListRelationFilter
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    measurementId?: IntFilter | number
  }

  export type FluorideOrderByWithRelationInput = {
    id?: SortOrder
    minerals?: MineralOrderByRelationAggregateInput
    measurement?: MeasurementOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type FluorideWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type FluorideOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: FluorideCountOrderByAggregateInput
    _avg?: FluorideAvgOrderByAggregateInput
    _max?: FluorideMaxOrderByAggregateInput
    _min?: FluorideMinOrderByAggregateInput
    _sum?: FluorideSumOrderByAggregateInput
  }

  export type FluorideScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FluorideScalarWhereWithAggregatesInput>
    OR?: Enumerable<FluorideScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FluorideScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type PhosphorousWhereInput = {
    AND?: Enumerable<PhosphorousWhereInput>
    OR?: Enumerable<PhosphorousWhereInput>
    NOT?: Enumerable<PhosphorousWhereInput>
    id?: IntFilter | number
    minerals?: MineralListRelationFilter
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    measurementId?: IntFilter | number
  }

  export type PhosphorousOrderByWithRelationInput = {
    id?: SortOrder
    minerals?: MineralOrderByRelationAggregateInput
    measurement?: MeasurementOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type PhosphorousWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type PhosphorousOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: PhosphorousCountOrderByAggregateInput
    _avg?: PhosphorousAvgOrderByAggregateInput
    _max?: PhosphorousMaxOrderByAggregateInput
    _min?: PhosphorousMinOrderByAggregateInput
    _sum?: PhosphorousSumOrderByAggregateInput
  }

  export type PhosphorousScalarWhereWithAggregatesInput = {
    AND?: Enumerable<PhosphorousScalarWhereWithAggregatesInput>
    OR?: Enumerable<PhosphorousScalarWhereWithAggregatesInput>
    NOT?: Enumerable<PhosphorousScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type CopperWhereInput = {
    AND?: Enumerable<CopperWhereInput>
    OR?: Enumerable<CopperWhereInput>
    NOT?: Enumerable<CopperWhereInput>
    id?: IntFilter | number
    minerals?: MineralListRelationFilter
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    measurementId?: IntFilter | number
  }

  export type CopperOrderByWithRelationInput = {
    id?: SortOrder
    minerals?: MineralOrderByRelationAggregateInput
    measurement?: MeasurementOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type CopperWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type CopperOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: CopperCountOrderByAggregateInput
    _avg?: CopperAvgOrderByAggregateInput
    _max?: CopperMaxOrderByAggregateInput
    _min?: CopperMinOrderByAggregateInput
    _sum?: CopperSumOrderByAggregateInput
  }

  export type CopperScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CopperScalarWhereWithAggregatesInput>
    OR?: Enumerable<CopperScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CopperScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type IodineWhereInput = {
    AND?: Enumerable<IodineWhereInput>
    OR?: Enumerable<IodineWhereInput>
    NOT?: Enumerable<IodineWhereInput>
    id?: IntFilter | number
    minerals?: MineralListRelationFilter
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    measurementId?: IntFilter | number
  }

  export type IodineOrderByWithRelationInput = {
    id?: SortOrder
    minerals?: MineralOrderByRelationAggregateInput
    measurement?: MeasurementOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type IodineWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type IodineOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: IodineCountOrderByAggregateInput
    _avg?: IodineAvgOrderByAggregateInput
    _max?: IodineMaxOrderByAggregateInput
    _min?: IodineMinOrderByAggregateInput
    _sum?: IodineSumOrderByAggregateInput
  }

  export type IodineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<IodineScalarWhereWithAggregatesInput>
    OR?: Enumerable<IodineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<IodineScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type CalciumWhereInput = {
    AND?: Enumerable<CalciumWhereInput>
    OR?: Enumerable<CalciumWhereInput>
    NOT?: Enumerable<CalciumWhereInput>
    id?: IntFilter | number
    minerals?: MineralListRelationFilter
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    measurementId?: IntFilter | number
  }

  export type CalciumOrderByWithRelationInput = {
    id?: SortOrder
    minerals?: MineralOrderByRelationAggregateInput
    measurement?: MeasurementOrderByWithRelationInput
    measurementId?: SortOrder
  }

  export type CalciumWhereUniqueInput = {
    id?: number
    measurementId?: number
  }

  export type CalciumOrderByWithAggregationInput = {
    id?: SortOrder
    measurementId?: SortOrder
    _count?: CalciumCountOrderByAggregateInput
    _avg?: CalciumAvgOrderByAggregateInput
    _max?: CalciumMaxOrderByAggregateInput
    _min?: CalciumMinOrderByAggregateInput
    _sum?: CalciumSumOrderByAggregateInput
  }

  export type CalciumScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CalciumScalarWhereWithAggregatesInput>
    OR?: Enumerable<CalciumScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CalciumScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    measurementId?: IntWithAggregatesFilter | number
  }

  export type MineralWhereInput = {
    AND?: Enumerable<MineralWhereInput>
    OR?: Enumerable<MineralWhereInput>
    NOT?: Enumerable<MineralWhereInput>
    id?: IntFilter | number
    salt?: XOR<SaltRelationFilter, SaltWhereInput> | null
    saltId?: IntNullableFilter | number | null
    nutritionFact?: NutritionFactListRelationFilter
    iron?: XOR<IronRelationFilter, IronWhereInput> | null
    ironId?: IntNullableFilter | number | null
    zinc?: XOR<ZincRelationFilter, ZincWhereInput> | null
    zincId?: IntNullableFilter | number | null
    magnesium?: XOR<MagnesiumRelationFilter, MagnesiumWhereInput> | null
    magnesiumId?: IntNullableFilter | number | null
    chloride?: XOR<ChlorideRelationFilter, ChlorideWhereInput> | null
    chlorideId?: IntNullableFilter | number | null
    manganese?: XOR<ManganeseRelationFilter, ManganeseWhereInput> | null
    manganeseId?: IntNullableFilter | number | null
    sulfur?: XOR<SulfurRelationFilter, SulfurWhereInput> | null
    sulfurId?: IntNullableFilter | number | null
    potassium?: XOR<PotassiumRelationFilter, PotassiumWhereInput> | null
    potassiumId?: IntNullableFilter | number | null
    fluoride?: XOR<FluorideRelationFilter, FluorideWhereInput> | null
    fluorideId?: IntNullableFilter | number | null
    phosphorous?: XOR<PhosphorousRelationFilter, PhosphorousWhereInput> | null
    phosphorousId?: IntNullableFilter | number | null
    copper?: XOR<CopperRelationFilter, CopperWhereInput> | null
    copperId?: IntNullableFilter | number | null
    iodine?: XOR<IodineRelationFilter, IodineWhereInput> | null
    iodineId?: IntNullableFilter | number | null
    calcium?: XOR<CalciumRelationFilter, CalciumWhereInput> | null
    calciumId?: IntNullableFilter | number | null
  }

  export type MineralOrderByWithRelationInput = {
    id?: SortOrder
    salt?: SaltOrderByWithRelationInput
    saltId?: SortOrder
    nutritionFact?: NutritionFactOrderByRelationAggregateInput
    iron?: IronOrderByWithRelationInput
    ironId?: SortOrder
    zinc?: ZincOrderByWithRelationInput
    zincId?: SortOrder
    magnesium?: MagnesiumOrderByWithRelationInput
    magnesiumId?: SortOrder
    chloride?: ChlorideOrderByWithRelationInput
    chlorideId?: SortOrder
    manganese?: ManganeseOrderByWithRelationInput
    manganeseId?: SortOrder
    sulfur?: SulfurOrderByWithRelationInput
    sulfurId?: SortOrder
    potassium?: PotassiumOrderByWithRelationInput
    potassiumId?: SortOrder
    fluoride?: FluorideOrderByWithRelationInput
    fluorideId?: SortOrder
    phosphorous?: PhosphorousOrderByWithRelationInput
    phosphorousId?: SortOrder
    copper?: CopperOrderByWithRelationInput
    copperId?: SortOrder
    iodine?: IodineOrderByWithRelationInput
    iodineId?: SortOrder
    calcium?: CalciumOrderByWithRelationInput
    calciumId?: SortOrder
  }

  export type MineralWhereUniqueInput = {
    id?: number
  }

  export type MineralOrderByWithAggregationInput = {
    id?: SortOrder
    saltId?: SortOrder
    ironId?: SortOrder
    zincId?: SortOrder
    magnesiumId?: SortOrder
    chlorideId?: SortOrder
    manganeseId?: SortOrder
    sulfurId?: SortOrder
    potassiumId?: SortOrder
    fluorideId?: SortOrder
    phosphorousId?: SortOrder
    copperId?: SortOrder
    iodineId?: SortOrder
    calciumId?: SortOrder
    _count?: MineralCountOrderByAggregateInput
    _avg?: MineralAvgOrderByAggregateInput
    _max?: MineralMaxOrderByAggregateInput
    _min?: MineralMinOrderByAggregateInput
    _sum?: MineralSumOrderByAggregateInput
  }

  export type MineralScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MineralScalarWhereWithAggregatesInput>
    OR?: Enumerable<MineralScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MineralScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    saltId?: IntNullableWithAggregatesFilter | number | null
    ironId?: IntNullableWithAggregatesFilter | number | null
    zincId?: IntNullableWithAggregatesFilter | number | null
    magnesiumId?: IntNullableWithAggregatesFilter | number | null
    chlorideId?: IntNullableWithAggregatesFilter | number | null
    manganeseId?: IntNullableWithAggregatesFilter | number | null
    sulfurId?: IntNullableWithAggregatesFilter | number | null
    potassiumId?: IntNullableWithAggregatesFilter | number | null
    fluorideId?: IntNullableWithAggregatesFilter | number | null
    phosphorousId?: IntNullableWithAggregatesFilter | number | null
    copperId?: IntNullableWithAggregatesFilter | number | null
    iodineId?: IntNullableWithAggregatesFilter | number | null
    calciumId?: IntNullableWithAggregatesFilter | number | null
  }

  export type UnitWhereInput = {
    AND?: Enumerable<UnitWhereInput>
    OR?: Enumerable<UnitWhereInput>
    NOT?: Enumerable<UnitWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    abbreviation?: StringFilter | string
    measurements?: MeasurementListRelationFilter
  }

  export type UnitOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    measurements?: MeasurementOrderByRelationAggregateInput
  }

  export type UnitWhereUniqueInput = {
    id?: number
    name?: string
    abbreviation?: string
  }

  export type UnitOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
    _count?: UnitCountOrderByAggregateInput
    _avg?: UnitAvgOrderByAggregateInput
    _max?: UnitMaxOrderByAggregateInput
    _min?: UnitMinOrderByAggregateInput
    _sum?: UnitSumOrderByAggregateInput
  }

  export type UnitScalarWhereWithAggregatesInput = {
    AND?: Enumerable<UnitScalarWhereWithAggregatesInput>
    OR?: Enumerable<UnitScalarWhereWithAggregatesInput>
    NOT?: Enumerable<UnitScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    abbreviation?: StringWithAggregatesFilter | string
  }

  export type MeasurementWhereInput = {
    AND?: Enumerable<MeasurementWhereInput>
    OR?: Enumerable<MeasurementWhereInput>
    NOT?: Enumerable<MeasurementWhereInput>
    id?: IntFilter | number
    value?: DecimalNullableFilter | Decimal | number | string | null
    unit?: XOR<UnitRelationFilter, UnitWhereInput>
    unitId?: IntFilter | number
    servings?: ServingListRelationFilter
    vitamin?: VitaminListRelationFilter
    salt?: SaltListRelationFilter
    zinc?: ZincListRelationFilter
    iron?: IronListRelationFilter
    magnesium?: MagnesiumListRelationFilter
    chloride?: ChlorideListRelationFilter
    manganese?: ManganeseListRelationFilter
    sulfur?: SulfurListRelationFilter
    potassium?: PotassiumListRelationFilter
    fluoride?: FluorideListRelationFilter
    phosphorous?: PhosphorousListRelationFilter
    copper?: CopperListRelationFilter
    iodine?: IodineListRelationFilter
    calcium?: CalciumListRelationFilter
    totalFat?: TotalFatListRelationFilter
    saturatedFat?: SaturatedFatListRelationFilter
    monosaturatedFat?: MonosaturatedFatListRelationFilter
    polyunsaturatedFat?: PolyunsaturatedFatListRelationFilter
    transFat?: TransFatListRelationFilter
    totalCarbohydrate?: TotalCarbohydrateListRelationFilter
    sugarCarbohydrate?: SugarCarbohydrateListRelationFilter
    vitaminC?: VitaminCListRelationFilter
    vitaminA?: VitaminAListRelationFilter
    vitaminD?: VitaminDListRelationFilter
    vitaminE?: VitaminEListRelationFilter
    vitaminB1?: VitaminB1ListRelationFilter
    vitaminB2?: VitaminB2ListRelationFilter
    vitaminB6?: VitaminB6ListRelationFilter
    vitaminB12?: VitaminB12ListRelationFilter
    energy?: EnergyListRelationFilter
    protein?: XOR<ProteinRelationFilter, ProteinWhereInput> | null
    proteinId?: IntNullableFilter | number | null
    cholesterol?: XOR<CholesterolRelationFilter, CholesterolWhereInput> | null
    cholesterolId?: IntNullableFilter | number | null
    ciber?: XOR<FiberRelationFilter, FiberWhereInput> | null
    fiberId?: IntNullableFilter | number | null
    cater?: XOR<WaterRelationFilter, WaterWhereInput> | null
    waterId?: IntNullableFilter | number | null
  }

  export type MeasurementOrderByWithRelationInput = {
    id?: SortOrder
    value?: SortOrder
    unit?: UnitOrderByWithRelationInput
    unitId?: SortOrder
    servings?: ServingOrderByRelationAggregateInput
    vitamin?: VitaminOrderByRelationAggregateInput
    salt?: SaltOrderByRelationAggregateInput
    zinc?: ZincOrderByRelationAggregateInput
    iron?: IronOrderByRelationAggregateInput
    magnesium?: MagnesiumOrderByRelationAggregateInput
    chloride?: ChlorideOrderByRelationAggregateInput
    manganese?: ManganeseOrderByRelationAggregateInput
    sulfur?: SulfurOrderByRelationAggregateInput
    potassium?: PotassiumOrderByRelationAggregateInput
    fluoride?: FluorideOrderByRelationAggregateInput
    phosphorous?: PhosphorousOrderByRelationAggregateInput
    copper?: CopperOrderByRelationAggregateInput
    iodine?: IodineOrderByRelationAggregateInput
    calcium?: CalciumOrderByRelationAggregateInput
    totalFat?: TotalFatOrderByRelationAggregateInput
    saturatedFat?: SaturatedFatOrderByRelationAggregateInput
    monosaturatedFat?: MonosaturatedFatOrderByRelationAggregateInput
    polyunsaturatedFat?: PolyunsaturatedFatOrderByRelationAggregateInput
    transFat?: TransFatOrderByRelationAggregateInput
    totalCarbohydrate?: TotalCarbohydrateOrderByRelationAggregateInput
    sugarCarbohydrate?: SugarCarbohydrateOrderByRelationAggregateInput
    vitaminC?: VitaminCOrderByRelationAggregateInput
    vitaminA?: VitaminAOrderByRelationAggregateInput
    vitaminD?: VitaminDOrderByRelationAggregateInput
    vitaminE?: VitaminEOrderByRelationAggregateInput
    vitaminB1?: VitaminB1OrderByRelationAggregateInput
    vitaminB2?: VitaminB2OrderByRelationAggregateInput
    vitaminB6?: VitaminB6OrderByRelationAggregateInput
    vitaminB12?: VitaminB12OrderByRelationAggregateInput
    energy?: EnergyOrderByRelationAggregateInput
    protein?: ProteinOrderByWithRelationInput
    proteinId?: SortOrder
    cholesterol?: CholesterolOrderByWithRelationInput
    cholesterolId?: SortOrder
    ciber?: FiberOrderByWithRelationInput
    fiberId?: SortOrder
    cater?: WaterOrderByWithRelationInput
    waterId?: SortOrder
  }

  export type MeasurementWhereUniqueInput = {
    id?: number
  }

  export type MeasurementOrderByWithAggregationInput = {
    id?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
    proteinId?: SortOrder
    cholesterolId?: SortOrder
    fiberId?: SortOrder
    waterId?: SortOrder
    _count?: MeasurementCountOrderByAggregateInput
    _avg?: MeasurementAvgOrderByAggregateInput
    _max?: MeasurementMaxOrderByAggregateInput
    _min?: MeasurementMinOrderByAggregateInput
    _sum?: MeasurementSumOrderByAggregateInput
  }

  export type MeasurementScalarWhereWithAggregatesInput = {
    AND?: Enumerable<MeasurementScalarWhereWithAggregatesInput>
    OR?: Enumerable<MeasurementScalarWhereWithAggregatesInput>
    NOT?: Enumerable<MeasurementScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    value?: DecimalNullableWithAggregatesFilter | Decimal | number | string | null
    unitId?: IntWithAggregatesFilter | number
    proteinId?: IntNullableWithAggregatesFilter | number | null
    cholesterolId?: IntNullableWithAggregatesFilter | number | null
    fiberId?: IntNullableWithAggregatesFilter | number | null
    waterId?: IntNullableWithAggregatesFilter | number | null
  }

  export type ServingWhereInput = {
    AND?: Enumerable<ServingWhereInput>
    OR?: Enumerable<ServingWhereInput>
    NOT?: Enumerable<ServingWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    measurement?: XOR<MeasurementRelationFilter, MeasurementWhereInput>
    measurementId?: IntFilter | number
    products?: ProductListRelationFilter
  }

  export type ServingOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    measurement?: MeasurementOrderByWithRelationInput
    measurementId?: SortOrder
    products?: ProductOrderByRelationAggregateInput
  }

  export type ServingWhereUniqueInput = {
    id?: number
  }

  export type ServingOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    measurementId?: SortOrder
    _count?: ServingCountOrderByAggregateInput
    _avg?: ServingAvgOrderByAggregateInput
    _max?: ServingMaxOrderByAggregateInput
    _min?: ServingMinOrderByAggregateInput
    _sum?: ServingSumOrderByAggregateInput
  }

  export type ServingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ServingScalarWhereWithAggregatesInput>
    OR?: Enumerable<ServingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ServingScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    measurementId?: IntWithAggregatesFilter | number
  }

  export type EnergyWhereInput = {
    AND?: Enumerable<EnergyWhereInput>
    OR?: Enumerable<EnergyWhereInput>
    NOT?: Enumerable<EnergyWhereInput>
    id?: IntFilter | number
    measurements?: MeasurementListRelationFilter
    nutritionFactId?: IntFilter | number
    nutritionFact?: XOR<NutritionFactRelationFilter, NutritionFactWhereInput>
  }

  export type EnergyOrderByWithRelationInput = {
    id?: SortOrder
    measurements?: MeasurementOrderByRelationAggregateInput
    nutritionFactId?: SortOrder
    nutritionFact?: NutritionFactOrderByWithRelationInput
  }

  export type EnergyWhereUniqueInput = {
    id?: number
    nutritionFactId?: number
  }

  export type EnergyOrderByWithAggregationInput = {
    id?: SortOrder
    nutritionFactId?: SortOrder
    _count?: EnergyCountOrderByAggregateInput
    _avg?: EnergyAvgOrderByAggregateInput
    _max?: EnergyMaxOrderByAggregateInput
    _min?: EnergyMinOrderByAggregateInput
    _sum?: EnergySumOrderByAggregateInput
  }

  export type EnergyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<EnergyScalarWhereWithAggregatesInput>
    OR?: Enumerable<EnergyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<EnergyScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    nutritionFactId?: IntWithAggregatesFilter | number
  }

  export type ProteinWhereInput = {
    AND?: Enumerable<ProteinWhereInput>
    OR?: Enumerable<ProteinWhereInput>
    NOT?: Enumerable<ProteinWhereInput>
    id?: IntFilter | number
    measurements?: MeasurementListRelationFilter
    NutritionFact?: NutritionFactListRelationFilter
  }

  export type ProteinOrderByWithRelationInput = {
    id?: SortOrder
    measurements?: MeasurementOrderByRelationAggregateInput
    NutritionFact?: NutritionFactOrderByRelationAggregateInput
  }

  export type ProteinWhereUniqueInput = {
    id?: number
  }

  export type ProteinOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: ProteinCountOrderByAggregateInput
    _avg?: ProteinAvgOrderByAggregateInput
    _max?: ProteinMaxOrderByAggregateInput
    _min?: ProteinMinOrderByAggregateInput
    _sum?: ProteinSumOrderByAggregateInput
  }

  export type ProteinScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProteinScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProteinScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProteinScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type CholesterolWhereInput = {
    AND?: Enumerable<CholesterolWhereInput>
    OR?: Enumerable<CholesterolWhereInput>
    NOT?: Enumerable<CholesterolWhereInput>
    id?: IntFilter | number
    measurements?: MeasurementListRelationFilter
    NutritionFact?: NutritionFactListRelationFilter
  }

  export type CholesterolOrderByWithRelationInput = {
    id?: SortOrder
    measurements?: MeasurementOrderByRelationAggregateInput
    NutritionFact?: NutritionFactOrderByRelationAggregateInput
  }

  export type CholesterolWhereUniqueInput = {
    id?: number
  }

  export type CholesterolOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: CholesterolCountOrderByAggregateInput
    _avg?: CholesterolAvgOrderByAggregateInput
    _max?: CholesterolMaxOrderByAggregateInput
    _min?: CholesterolMinOrderByAggregateInput
    _sum?: CholesterolSumOrderByAggregateInput
  }

  export type CholesterolScalarWhereWithAggregatesInput = {
    AND?: Enumerable<CholesterolScalarWhereWithAggregatesInput>
    OR?: Enumerable<CholesterolScalarWhereWithAggregatesInput>
    NOT?: Enumerable<CholesterolScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type FiberWhereInput = {
    AND?: Enumerable<FiberWhereInput>
    OR?: Enumerable<FiberWhereInput>
    NOT?: Enumerable<FiberWhereInput>
    id?: IntFilter | number
    measurements?: MeasurementListRelationFilter
    NutritionFact?: NutritionFactListRelationFilter
  }

  export type FiberOrderByWithRelationInput = {
    id?: SortOrder
    measurements?: MeasurementOrderByRelationAggregateInput
    NutritionFact?: NutritionFactOrderByRelationAggregateInput
  }

  export type FiberWhereUniqueInput = {
    id?: number
  }

  export type FiberOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: FiberCountOrderByAggregateInput
    _avg?: FiberAvgOrderByAggregateInput
    _max?: FiberMaxOrderByAggregateInput
    _min?: FiberMinOrderByAggregateInput
    _sum?: FiberSumOrderByAggregateInput
  }

  export type FiberScalarWhereWithAggregatesInput = {
    AND?: Enumerable<FiberScalarWhereWithAggregatesInput>
    OR?: Enumerable<FiberScalarWhereWithAggregatesInput>
    NOT?: Enumerable<FiberScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type WaterWhereInput = {
    AND?: Enumerable<WaterWhereInput>
    OR?: Enumerable<WaterWhereInput>
    NOT?: Enumerable<WaterWhereInput>
    id?: IntFilter | number
    measurements?: MeasurementListRelationFilter
    NutritionFact?: NutritionFactListRelationFilter
  }

  export type WaterOrderByWithRelationInput = {
    id?: SortOrder
    measurements?: MeasurementOrderByRelationAggregateInput
    NutritionFact?: NutritionFactOrderByRelationAggregateInput
  }

  export type WaterWhereUniqueInput = {
    id?: number
  }

  export type WaterOrderByWithAggregationInput = {
    id?: SortOrder
    _count?: WaterCountOrderByAggregateInput
    _avg?: WaterAvgOrderByAggregateInput
    _max?: WaterMaxOrderByAggregateInput
    _min?: WaterMinOrderByAggregateInput
    _sum?: WaterSumOrderByAggregateInput
  }

  export type WaterScalarWhereWithAggregatesInput = {
    AND?: Enumerable<WaterScalarWhereWithAggregatesInput>
    OR?: Enumerable<WaterScalarWhereWithAggregatesInput>
    NOT?: Enumerable<WaterScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
  }

  export type NutritionFactWhereInput = {
    AND?: Enumerable<NutritionFactWhereInput>
    OR?: Enumerable<NutritionFactWhereInput>
    NOT?: Enumerable<NutritionFactWhereInput>
    id?: IntFilter | number
    energy?: EnergyListRelationFilter
    protein?: XOR<ProteinRelationFilter, ProteinWhereInput> | null
    proteinId?: IntNullableFilter | number | null
    fats?: XOR<FatRelationFilter, FatWhereInput> | null
    fatId?: IntNullableFilter | number | null
    carbohydrate?: XOR<CarbohydrateRelationFilter, CarbohydrateWhereInput> | null
    carbohydrateId?: IntNullableFilter | number | null
    fiber?: XOR<FiberRelationFilter, FiberWhereInput> | null
    fiberId?: IntNullableFilter | number | null
    water?: XOR<WaterRelationFilter, WaterWhereInput> | null
    vitamins?: XOR<VitaminRelationFilter, VitaminWhereInput> | null
    vitaminId?: IntNullableFilter | number | null
    minerals?: XOR<MineralRelationFilter, MineralWhereInput> | null
    mineralId?: IntNullableFilter | number | null
    cholesterol?: XOR<CholesterolRelationFilter, CholesterolWhereInput> | null
    cholesterolId?: IntNullableFilter | number | null
    waterId?: IntNullableFilter | number | null
    product?: XOR<ProductRelationFilter, ProductWhereInput> | null
    productId?: IntNullableFilter | number | null
  }

  export type NutritionFactOrderByWithRelationInput = {
    id?: SortOrder
    energy?: EnergyOrderByRelationAggregateInput
    protein?: ProteinOrderByWithRelationInput
    proteinId?: SortOrder
    fats?: FatOrderByWithRelationInput
    fatId?: SortOrder
    carbohydrate?: CarbohydrateOrderByWithRelationInput
    carbohydrateId?: SortOrder
    fiber?: FiberOrderByWithRelationInput
    fiberId?: SortOrder
    water?: WaterOrderByWithRelationInput
    vitamins?: VitaminOrderByWithRelationInput
    vitaminId?: SortOrder
    minerals?: MineralOrderByWithRelationInput
    mineralId?: SortOrder
    cholesterol?: CholesterolOrderByWithRelationInput
    cholesterolId?: SortOrder
    waterId?: SortOrder
    product?: ProductOrderByWithRelationInput
    productId?: SortOrder
  }

  export type NutritionFactWhereUniqueInput = {
    id?: number
    productId?: number
  }

  export type NutritionFactOrderByWithAggregationInput = {
    id?: SortOrder
    proteinId?: SortOrder
    fatId?: SortOrder
    carbohydrateId?: SortOrder
    fiberId?: SortOrder
    vitaminId?: SortOrder
    mineralId?: SortOrder
    cholesterolId?: SortOrder
    waterId?: SortOrder
    productId?: SortOrder
    _count?: NutritionFactCountOrderByAggregateInput
    _avg?: NutritionFactAvgOrderByAggregateInput
    _max?: NutritionFactMaxOrderByAggregateInput
    _min?: NutritionFactMinOrderByAggregateInput
    _sum?: NutritionFactSumOrderByAggregateInput
  }

  export type NutritionFactScalarWhereWithAggregatesInput = {
    AND?: Enumerable<NutritionFactScalarWhereWithAggregatesInput>
    OR?: Enumerable<NutritionFactScalarWhereWithAggregatesInput>
    NOT?: Enumerable<NutritionFactScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    proteinId?: IntNullableWithAggregatesFilter | number | null
    fatId?: IntNullableWithAggregatesFilter | number | null
    carbohydrateId?: IntNullableWithAggregatesFilter | number | null
    fiberId?: IntNullableWithAggregatesFilter | number | null
    vitaminId?: IntNullableWithAggregatesFilter | number | null
    mineralId?: IntNullableWithAggregatesFilter | number | null
    cholesterolId?: IntNullableWithAggregatesFilter | number | null
    waterId?: IntNullableWithAggregatesFilter | number | null
    productId?: IntNullableWithAggregatesFilter | number | null
  }

  export type ProductWhereInput = {
    AND?: Enumerable<ProductWhereInput>
    OR?: Enumerable<ProductWhereInput>
    NOT?: Enumerable<ProductWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    labels?: LabelListRelationFilter
    ean?: StringNullableFilter | string | null
    manufacturer?: StringFilter | string
    group?: StringFilter | string
    serving?: XOR<ServingRelationFilter, ServingWhereInput>
    servingId?: IntFilter | number
    nutritionFact?: XOR<NutritionFactRelationFilter, NutritionFactWhereInput> | null
    nutritionFactId?: IntNullableFilter | number | null
  }

  export type ProductOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    labels?: LabelOrderByRelationAggregateInput
    ean?: SortOrder
    manufacturer?: SortOrder
    group?: SortOrder
    serving?: ServingOrderByWithRelationInput
    servingId?: SortOrder
    nutritionFact?: NutritionFactOrderByWithRelationInput
    nutritionFactId?: SortOrder
  }

  export type ProductWhereUniqueInput = {
    id?: number
  }

  export type ProductOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ean?: SortOrder
    manufacturer?: SortOrder
    group?: SortOrder
    servingId?: SortOrder
    nutritionFactId?: SortOrder
    _count?: ProductCountOrderByAggregateInput
    _avg?: ProductAvgOrderByAggregateInput
    _max?: ProductMaxOrderByAggregateInput
    _min?: ProductMinOrderByAggregateInput
    _sum?: ProductSumOrderByAggregateInput
  }

  export type ProductScalarWhereWithAggregatesInput = {
    AND?: Enumerable<ProductScalarWhereWithAggregatesInput>
    OR?: Enumerable<ProductScalarWhereWithAggregatesInput>
    NOT?: Enumerable<ProductScalarWhereWithAggregatesInput>
    id?: IntWithAggregatesFilter | number
    name?: StringWithAggregatesFilter | string
    ean?: StringNullableWithAggregatesFilter | string | null
    manufacturer?: StringWithAggregatesFilter | string
    group?: StringWithAggregatesFilter | string
    servingId?: IntWithAggregatesFilter | number
    nutritionFactId?: IntNullableWithAggregatesFilter | number | null
  }

  export type ResourceCreateInput = {
    displayName: string
    slug: string
  }

  export type ResourceUncheckedCreateInput = {
    id?: number
    displayName: string
    slug: string
  }

  export type ResourceUpdateInput = {
    displayName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    displayName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceCreateManyInput = {
    id?: number
    displayName: string
    slug: string
  }

  export type ResourceUpdateManyMutationInput = {
    displayName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type ResourceUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    displayName?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
  }

  export type LabelCreateInput = {
    name: string
    products?: ProductCreateNestedManyWithoutLabelsInput
  }

  export type LabelUncheckedCreateInput = {
    id?: number
    name: string
    products?: ProductUncheckedCreateNestedManyWithoutLabelsInput
  }

  export type LabelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutLabelsInput
  }

  export type LabelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutLabelsInput
  }

  export type LabelCreateManyInput = {
    id?: number
    name: string
  }

  export type LabelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LabelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type FatCreateInput = {
    total?: TotalFatCreateNestedOneWithoutFatInput
    saturated?: SaturatedFatCreateNestedOneWithoutFatInput
    monounsaturated?: MonosaturatedFatCreateNestedOneWithoutFatInput
    polyunsaturated?: PolyunsaturatedFatCreateNestedOneWithoutFatInput
    trans?: TransFatCreateNestedOneWithoutFatInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutFatsInput
  }

  export type FatUncheckedCreateInput = {
    id?: number
    totalFatId: number
    saturatedFatId?: number | null
    monosaturatedFatId?: number | null
    polyunsaturatedFatId?: number | null
    transFatId?: number | null
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutFatsInput
  }

  export type FatUpdateInput = {
    total?: TotalFatUpdateOneWithoutFatInput
    saturated?: SaturatedFatUpdateOneWithoutFatInput
    monounsaturated?: MonosaturatedFatUpdateOneWithoutFatInput
    polyunsaturated?: PolyunsaturatedFatUpdateOneWithoutFatInput
    trans?: TransFatUpdateOneWithoutFatInput
    nutritionFacts?: NutritionFactUpdateManyWithoutFatsInput
  }

  export type FatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalFatId?: IntFieldUpdateOperationsInput | number
    saturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    monosaturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    polyunsaturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    transFatId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutFatsInput
  }

  export type FatCreateManyInput = {
    id?: number
    totalFatId: number
    saturatedFatId?: number | null
    monosaturatedFatId?: number | null
    polyunsaturatedFatId?: number | null
    transFatId?: number | null
  }

  export type FatUpdateManyMutationInput = {

  }

  export type FatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalFatId?: IntFieldUpdateOperationsInput | number
    saturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    monosaturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    polyunsaturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    transFatId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TotalFatCreateInput = {
    measurement?: MeasurementCreateNestedOneWithoutTotalFatInput
    fat?: FatCreateNestedOneWithoutTotalInput
  }

  export type TotalFatUncheckedCreateInput = {
    id?: number
    fat?: FatUncheckedCreateNestedOneWithoutTotalInput
    measurementId: number
  }

  export type TotalFatUpdateInput = {
    measurement?: MeasurementUpdateOneWithoutTotalFatInput
    fat?: FatUpdateOneWithoutTotalInput
  }

  export type TotalFatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fat?: FatUncheckedUpdateOneWithoutTotalInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type TotalFatCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type TotalFatUpdateManyMutationInput = {

  }

  export type TotalFatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type SaturatedFatCreateInput = {
    measurement: MeasurementCreateNestedOneWithoutSaturatedFatInput
    fat?: FatCreateNestedOneWithoutSaturatedInput
  }

  export type SaturatedFatUncheckedCreateInput = {
    id?: number
    fat?: FatUncheckedCreateNestedOneWithoutSaturatedInput
    measurementId: number
  }

  export type SaturatedFatUpdateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutSaturatedFatInput
    fat?: FatUpdateOneWithoutSaturatedInput
  }

  export type SaturatedFatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fat?: FatUncheckedUpdateOneWithoutSaturatedInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type SaturatedFatCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type SaturatedFatUpdateManyMutationInput = {

  }

  export type SaturatedFatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type MonosaturatedFatCreateInput = {
    measurement: MeasurementCreateNestedOneWithoutMonosaturatedFatInput
    fat?: FatCreateNestedOneWithoutMonounsaturatedInput
  }

  export type MonosaturatedFatUncheckedCreateInput = {
    id?: number
    fat?: FatUncheckedCreateNestedOneWithoutMonounsaturatedInput
    measurementId: number
  }

  export type MonosaturatedFatUpdateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutMonosaturatedFatInput
    fat?: FatUpdateOneWithoutMonounsaturatedInput
  }

  export type MonosaturatedFatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fat?: FatUncheckedUpdateOneWithoutMonounsaturatedInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type MonosaturatedFatCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type MonosaturatedFatUpdateManyMutationInput = {

  }

  export type MonosaturatedFatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type PolyunsaturatedFatCreateInput = {
    measurement: MeasurementCreateNestedOneWithoutPolyunsaturatedFatInput
    fat?: FatCreateNestedOneWithoutPolyunsaturatedInput
  }

  export type PolyunsaturatedFatUncheckedCreateInput = {
    id?: number
    fat?: FatUncheckedCreateNestedOneWithoutPolyunsaturatedInput
    measurementId: number
  }

  export type PolyunsaturatedFatUpdateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutPolyunsaturatedFatInput
    fat?: FatUpdateOneWithoutPolyunsaturatedInput
  }

  export type PolyunsaturatedFatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fat?: FatUncheckedUpdateOneWithoutPolyunsaturatedInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type PolyunsaturatedFatCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type PolyunsaturatedFatUpdateManyMutationInput = {

  }

  export type PolyunsaturatedFatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type TransFatCreateInput = {
    measurement: MeasurementCreateNestedOneWithoutTransFatInput
    fat?: FatCreateNestedOneWithoutTransInput
  }

  export type TransFatUncheckedCreateInput = {
    id?: number
    fat?: FatUncheckedCreateNestedOneWithoutTransInput
    measurementId: number
  }

  export type TransFatUpdateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutTransFatInput
    fat?: FatUpdateOneWithoutTransInput
  }

  export type TransFatUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fat?: FatUncheckedUpdateOneWithoutTransInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type TransFatCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type TransFatUpdateManyMutationInput = {

  }

  export type TransFatUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type CarbohydrateCreateInput = {
    total?: TotalCarbohydrateCreateNestedOneWithoutCarbohydrateInput
    sugar?: SugarCarbohydrateCreateNestedOneWithoutCarbohydrateInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutCarbohydrateInput
  }

  export type CarbohydrateUncheckedCreateInput = {
    id?: number
    totalCarbohydrateId?: number | null
    sugarCarbohydrateId?: number | null
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutCarbohydrateInput
  }

  export type CarbohydrateUpdateInput = {
    total?: TotalCarbohydrateUpdateOneWithoutCarbohydrateInput
    sugar?: SugarCarbohydrateUpdateOneWithoutCarbohydrateInput
    nutritionFacts?: NutritionFactUpdateManyWithoutCarbohydrateInput
  }

  export type CarbohydrateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalCarbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    sugarCarbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutCarbohydrateInput
  }

  export type CarbohydrateCreateManyInput = {
    id?: number
    totalCarbohydrateId?: number | null
    sugarCarbohydrateId?: number | null
  }

  export type CarbohydrateUpdateManyMutationInput = {

  }

  export type CarbohydrateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalCarbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    sugarCarbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type TotalCarbohydrateCreateInput = {
    measurement: MeasurementCreateNestedOneWithoutTotalCarbohydrateInput
    carbohydrate?: CarbohydrateCreateNestedOneWithoutTotalInput
  }

  export type TotalCarbohydrateUncheckedCreateInput = {
    id?: number
    carbohydrate?: CarbohydrateUncheckedCreateNestedOneWithoutTotalInput
    measurementId: number
  }

  export type TotalCarbohydrateUpdateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutTotalCarbohydrateInput
    carbohydrate?: CarbohydrateUpdateOneWithoutTotalInput
  }

  export type TotalCarbohydrateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    carbohydrate?: CarbohydrateUncheckedUpdateOneWithoutTotalInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type TotalCarbohydrateCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type TotalCarbohydrateUpdateManyMutationInput = {

  }

  export type TotalCarbohydrateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type SugarCarbohydrateCreateInput = {
    measurement: MeasurementCreateNestedOneWithoutSugarCarbohydrateInput
    carbohydrate?: CarbohydrateCreateNestedOneWithoutSugarInput
  }

  export type SugarCarbohydrateUncheckedCreateInput = {
    id?: number
    carbohydrate?: CarbohydrateUncheckedCreateNestedOneWithoutSugarInput
    measurementId: number
  }

  export type SugarCarbohydrateUpdateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutSugarCarbohydrateInput
    carbohydrate?: CarbohydrateUpdateOneWithoutSugarInput
  }

  export type SugarCarbohydrateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    carbohydrate?: CarbohydrateUncheckedUpdateOneWithoutSugarInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type SugarCarbohydrateCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type SugarCarbohydrateUpdateManyMutationInput = {

  }

  export type SugarCarbohydrateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminCreateInput = {
    C?: VitaminCCreateNestedOneWithoutVitaminInput
    A?: VitaminACreateNestedOneWithoutVitaminInput
    D?: VitaminDCreateNestedOneWithoutVitaminInput
    E?: VitaminECreateNestedOneWithoutVitaminInput
    B1?: VitaminB1CreateNestedOneWithoutVitaminInput
    B2?: VitaminB2CreateNestedOneWithoutVitaminInput
    B6?: VitaminB6CreateNestedOneWithoutVitaminInput
    B12?: VitaminB12CreateNestedOneWithoutVitaminInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutVitaminsInput
    measurements?: MeasurementCreateNestedManyWithoutVitaminInput
  }

  export type VitaminUncheckedCreateInput = {
    id?: number
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutVitaminsInput
    vitaminCId?: number | null
    vitaminAId?: number | null
    vitaminDId?: number | null
    vitaminEId?: number | null
    vitaminB1Id?: number | null
    vitaminB2Id?: number | null
    vitaminB6Id?: number | null
    vitaminB12Id?: number | null
    measurements?: MeasurementUncheckedCreateNestedManyWithoutVitaminInput
  }

  export type VitaminUpdateInput = {
    C?: VitaminCUpdateOneWithoutVitaminInput
    A?: VitaminAUpdateOneWithoutVitaminInput
    D?: VitaminDUpdateOneWithoutVitaminInput
    E?: VitaminEUpdateOneWithoutVitaminInput
    B1?: VitaminB1UpdateOneWithoutVitaminInput
    B2?: VitaminB2UpdateOneWithoutVitaminInput
    B6?: VitaminB6UpdateOneWithoutVitaminInput
    B12?: VitaminB12UpdateOneWithoutVitaminInput
    nutritionFacts?: NutritionFactUpdateManyWithoutVitaminsInput
    measurements?: MeasurementUpdateManyWithoutVitaminInput
  }

  export type VitaminUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutVitaminsInput
    vitaminCId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminAId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminDId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminEId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB1Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB2Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB6Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB12Id?: NullableIntFieldUpdateOperationsInput | number | null
    measurements?: MeasurementUncheckedUpdateManyWithoutVitaminInput
  }

  export type VitaminCreateManyInput = {
    id?: number
    vitaminCId?: number | null
    vitaminAId?: number | null
    vitaminDId?: number | null
    vitaminEId?: number | null
    vitaminB1Id?: number | null
    vitaminB2Id?: number | null
    vitaminB6Id?: number | null
    vitaminB12Id?: number | null
  }

  export type VitaminUpdateManyMutationInput = {

  }

  export type VitaminUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitaminCId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminAId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminDId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminEId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB1Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB2Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB6Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB12Id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VitaminCCreateInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminCInput
    vitamin?: VitaminCreateNestedOneWithoutCInput
  }

  export type VitaminCUncheckedCreateInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutCInput
    measurementId: number
  }

  export type VitaminCUpdateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminCInput
    vitamin?: VitaminUpdateOneWithoutCInput
  }

  export type VitaminCUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutCInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminCCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type VitaminCUpdateManyMutationInput = {

  }

  export type VitaminCUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminACreateInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminAInput
    vitamin?: VitaminCreateNestedOneWithoutAInput
  }

  export type VitaminAUncheckedCreateInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutAInput
    measurementId: number
  }

  export type VitaminAUpdateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminAInput
    vitamin?: VitaminUpdateOneWithoutAInput
  }

  export type VitaminAUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutAInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminACreateManyInput = {
    id?: number
    measurementId: number
  }

  export type VitaminAUpdateManyMutationInput = {

  }

  export type VitaminAUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminDCreateInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminDInput
    vitamin?: VitaminCreateNestedOneWithoutDInput
  }

  export type VitaminDUncheckedCreateInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutDInput
    measurementId: number
  }

  export type VitaminDUpdateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminDInput
    vitamin?: VitaminUpdateOneWithoutDInput
  }

  export type VitaminDUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutDInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminDCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type VitaminDUpdateManyMutationInput = {

  }

  export type VitaminDUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminECreateInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminEInput
    vitamin?: VitaminCreateNestedOneWithoutEInput
  }

  export type VitaminEUncheckedCreateInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutEInput
    measurementId: number
  }

  export type VitaminEUpdateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminEInput
    vitamin?: VitaminUpdateOneWithoutEInput
  }

  export type VitaminEUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutEInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminECreateManyInput = {
    id?: number
    measurementId: number
  }

  export type VitaminEUpdateManyMutationInput = {

  }

  export type VitaminEUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB1CreateInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminB1Input
    vitamin?: VitaminCreateNestedOneWithoutB1Input
  }

  export type VitaminB1UncheckedCreateInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutB1Input
    measurementId: number
  }

  export type VitaminB1UpdateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminB1Input
    vitamin?: VitaminUpdateOneWithoutB1Input
  }

  export type VitaminB1UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutB1Input
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB1CreateManyInput = {
    id?: number
    measurementId: number
  }

  export type VitaminB1UpdateManyMutationInput = {

  }

  export type VitaminB1UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB2CreateInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminB2Input
    vitamin?: VitaminCreateNestedOneWithoutB2Input
  }

  export type VitaminB2UncheckedCreateInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutB2Input
    measurementId: number
  }

  export type VitaminB2UpdateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminB2Input
    vitamin?: VitaminUpdateOneWithoutB2Input
  }

  export type VitaminB2UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutB2Input
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB2CreateManyInput = {
    id?: number
    measurementId: number
  }

  export type VitaminB2UpdateManyMutationInput = {

  }

  export type VitaminB2UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB6CreateInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminB6Input
    vitamin?: VitaminCreateNestedOneWithoutB6Input
  }

  export type VitaminB6UncheckedCreateInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutB6Input
    measurementId: number
  }

  export type VitaminB6UpdateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminB6Input
    vitamin?: VitaminUpdateOneWithoutB6Input
  }

  export type VitaminB6UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutB6Input
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB6CreateManyInput = {
    id?: number
    measurementId: number
  }

  export type VitaminB6UpdateManyMutationInput = {

  }

  export type VitaminB6UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB12CreateInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminB12Input
    vitamin?: VitaminCreateNestedOneWithoutB12Input
  }

  export type VitaminB12UncheckedCreateInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutB12Input
    measurementId: number
  }

  export type VitaminB12UpdateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminB12Input
    vitamin?: VitaminUpdateOneWithoutB12Input
  }

  export type VitaminB12UncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutB12Input
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB12CreateManyInput = {
    id?: number
    measurementId: number
  }

  export type VitaminB12UpdateManyMutationInput = {

  }

  export type VitaminB12UncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type SaltCreateInput = {
    minerals?: MineralCreateNestedManyWithoutSaltInput
    measurement: MeasurementCreateNestedOneWithoutSaltInput
  }

  export type SaltUncheckedCreateInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutSaltInput
    measurementId: number
  }

  export type SaltUpdateInput = {
    minerals?: MineralUpdateManyWithoutSaltInput
    measurement?: MeasurementUpdateOneRequiredWithoutSaltInput
  }

  export type SaltUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutSaltInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type SaltCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type SaltUpdateManyMutationInput = {

  }

  export type SaltUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type ZincCreateInput = {
    minerals?: MineralCreateNestedManyWithoutZincInput
    measurement: MeasurementCreateNestedOneWithoutZincInput
  }

  export type ZincUncheckedCreateInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutZincInput
    measurementId: number
  }

  export type ZincUpdateInput = {
    minerals?: MineralUpdateManyWithoutZincInput
    measurement?: MeasurementUpdateOneRequiredWithoutZincInput
  }

  export type ZincUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutZincInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type ZincCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type ZincUpdateManyMutationInput = {

  }

  export type ZincUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type IronCreateInput = {
    minerals?: MineralCreateNestedManyWithoutIronInput
    measurement: MeasurementCreateNestedOneWithoutIronInput
  }

  export type IronUncheckedCreateInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutIronInput
    measurementId: number
  }

  export type IronUpdateInput = {
    minerals?: MineralUpdateManyWithoutIronInput
    measurement?: MeasurementUpdateOneRequiredWithoutIronInput
  }

  export type IronUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutIronInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type IronCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type IronUpdateManyMutationInput = {

  }

  export type IronUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type MagnesiumCreateInput = {
    minerals?: MineralCreateNestedManyWithoutMagnesiumInput
    measurement: MeasurementCreateNestedOneWithoutMagnesiumInput
  }

  export type MagnesiumUncheckedCreateInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutMagnesiumInput
    measurementId: number
  }

  export type MagnesiumUpdateInput = {
    minerals?: MineralUpdateManyWithoutMagnesiumInput
    measurement?: MeasurementUpdateOneRequiredWithoutMagnesiumInput
  }

  export type MagnesiumUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutMagnesiumInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type MagnesiumCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type MagnesiumUpdateManyMutationInput = {

  }

  export type MagnesiumUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type ChlorideCreateInput = {
    minerals?: MineralCreateNestedManyWithoutChlorideInput
    measurement: MeasurementCreateNestedOneWithoutChlorideInput
  }

  export type ChlorideUncheckedCreateInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutChlorideInput
    measurementId: number
  }

  export type ChlorideUpdateInput = {
    minerals?: MineralUpdateManyWithoutChlorideInput
    measurement?: MeasurementUpdateOneRequiredWithoutChlorideInput
  }

  export type ChlorideUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutChlorideInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type ChlorideCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type ChlorideUpdateManyMutationInput = {

  }

  export type ChlorideUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type ManganeseCreateInput = {
    minerals?: MineralCreateNestedManyWithoutManganeseInput
    measurement: MeasurementCreateNestedOneWithoutManganeseInput
  }

  export type ManganeseUncheckedCreateInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutManganeseInput
    measurementId: number
  }

  export type ManganeseUpdateInput = {
    minerals?: MineralUpdateManyWithoutManganeseInput
    measurement?: MeasurementUpdateOneRequiredWithoutManganeseInput
  }

  export type ManganeseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutManganeseInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type ManganeseCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type ManganeseUpdateManyMutationInput = {

  }

  export type ManganeseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type SulfurCreateInput = {
    minerals?: MineralCreateNestedManyWithoutSulfurInput
    measurement: MeasurementCreateNestedOneWithoutSulfurInput
  }

  export type SulfurUncheckedCreateInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutSulfurInput
    measurementId: number
  }

  export type SulfurUpdateInput = {
    minerals?: MineralUpdateManyWithoutSulfurInput
    measurement?: MeasurementUpdateOneRequiredWithoutSulfurInput
  }

  export type SulfurUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutSulfurInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type SulfurCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type SulfurUpdateManyMutationInput = {

  }

  export type SulfurUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type PotassiumCreateInput = {
    minerals?: MineralCreateNestedManyWithoutPotassiumInput
    measurement: MeasurementCreateNestedOneWithoutPotassiumInput
  }

  export type PotassiumUncheckedCreateInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutPotassiumInput
    measurementId: number
  }

  export type PotassiumUpdateInput = {
    minerals?: MineralUpdateManyWithoutPotassiumInput
    measurement?: MeasurementUpdateOneRequiredWithoutPotassiumInput
  }

  export type PotassiumUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutPotassiumInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type PotassiumCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type PotassiumUpdateManyMutationInput = {

  }

  export type PotassiumUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type FluorideCreateInput = {
    minerals?: MineralCreateNestedManyWithoutFluorideInput
    measurement: MeasurementCreateNestedOneWithoutFluorideInput
  }

  export type FluorideUncheckedCreateInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutFluorideInput
    measurementId: number
  }

  export type FluorideUpdateInput = {
    minerals?: MineralUpdateManyWithoutFluorideInput
    measurement?: MeasurementUpdateOneRequiredWithoutFluorideInput
  }

  export type FluorideUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutFluorideInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type FluorideCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type FluorideUpdateManyMutationInput = {

  }

  export type FluorideUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type PhosphorousCreateInput = {
    minerals?: MineralCreateNestedManyWithoutPhosphorousInput
    measurement: MeasurementCreateNestedOneWithoutPhosphorousInput
  }

  export type PhosphorousUncheckedCreateInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutPhosphorousInput
    measurementId: number
  }

  export type PhosphorousUpdateInput = {
    minerals?: MineralUpdateManyWithoutPhosphorousInput
    measurement?: MeasurementUpdateOneRequiredWithoutPhosphorousInput
  }

  export type PhosphorousUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutPhosphorousInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type PhosphorousCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type PhosphorousUpdateManyMutationInput = {

  }

  export type PhosphorousUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type CopperCreateInput = {
    minerals?: MineralCreateNestedManyWithoutCopperInput
    measurement: MeasurementCreateNestedOneWithoutCopperInput
  }

  export type CopperUncheckedCreateInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutCopperInput
    measurementId: number
  }

  export type CopperUpdateInput = {
    minerals?: MineralUpdateManyWithoutCopperInput
    measurement?: MeasurementUpdateOneRequiredWithoutCopperInput
  }

  export type CopperUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutCopperInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type CopperCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type CopperUpdateManyMutationInput = {

  }

  export type CopperUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type IodineCreateInput = {
    minerals?: MineralCreateNestedManyWithoutIodineInput
    measurement: MeasurementCreateNestedOneWithoutIodineInput
  }

  export type IodineUncheckedCreateInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutIodineInput
    measurementId: number
  }

  export type IodineUpdateInput = {
    minerals?: MineralUpdateManyWithoutIodineInput
    measurement?: MeasurementUpdateOneRequiredWithoutIodineInput
  }

  export type IodineUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutIodineInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type IodineCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type IodineUpdateManyMutationInput = {

  }

  export type IodineUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type CalciumCreateInput = {
    minerals?: MineralCreateNestedManyWithoutCalciumInput
    measurement: MeasurementCreateNestedOneWithoutCalciumInput
  }

  export type CalciumUncheckedCreateInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutCalciumInput
    measurementId: number
  }

  export type CalciumUpdateInput = {
    minerals?: MineralUpdateManyWithoutCalciumInput
    measurement?: MeasurementUpdateOneRequiredWithoutCalciumInput
  }

  export type CalciumUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutCalciumInput
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type CalciumCreateManyInput = {
    id?: number
    measurementId: number
  }

  export type CalciumUpdateManyMutationInput = {

  }

  export type CalciumUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type MineralCreateInput = {
    salt?: SaltCreateNestedOneWithoutMineralsInput
    nutritionFact?: NutritionFactCreateNestedManyWithoutMineralsInput
    iron?: IronCreateNestedOneWithoutMineralsInput
    zinc?: ZincCreateNestedOneWithoutMineralsInput
    magnesium?: MagnesiumCreateNestedOneWithoutMineralsInput
    chloride?: ChlorideCreateNestedOneWithoutMineralsInput
    manganese?: ManganeseCreateNestedOneWithoutMineralsInput
    sulfur?: SulfurCreateNestedOneWithoutMineralsInput
    potassium?: PotassiumCreateNestedOneWithoutMineralsInput
    fluoride?: FluorideCreateNestedOneWithoutMineralsInput
    phosphorous?: PhosphorousCreateNestedOneWithoutMineralsInput
    copper?: CopperCreateNestedOneWithoutMineralsInput
    iodine?: IodineCreateNestedOneWithoutMineralsInput
    calcium?: CalciumCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateInput = {
    id?: number
    saltId?: number | null
    nutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutMineralsInput
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralUpdateInput = {
    salt?: SaltUpdateOneWithoutMineralsInput
    nutritionFact?: NutritionFactUpdateManyWithoutMineralsInput
    iron?: IronUpdateOneWithoutMineralsInput
    zinc?: ZincUpdateOneWithoutMineralsInput
    magnesium?: MagnesiumUpdateOneWithoutMineralsInput
    chloride?: ChlorideUpdateOneWithoutMineralsInput
    manganese?: ManganeseUpdateOneWithoutMineralsInput
    sulfur?: SulfurUpdateOneWithoutMineralsInput
    potassium?: PotassiumUpdateOneWithoutMineralsInput
    fluoride?: FluorideUpdateOneWithoutMineralsInput
    phosphorous?: PhosphorousUpdateOneWithoutMineralsInput
    copper?: CopperUpdateOneWithoutMineralsInput
    iodine?: IodineUpdateOneWithoutMineralsInput
    calcium?: CalciumUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFact?: NutritionFactUncheckedUpdateManyWithoutMineralsInput
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateManyInput = {
    id?: number
    saltId?: number | null
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralUpdateManyMutationInput = {

  }

  export type MineralUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type UnitCreateInput = {
    name: string
    abbreviation: string
    measurements?: MeasurementCreateNestedManyWithoutUnitInput
  }

  export type UnitUncheckedCreateInput = {
    id?: number
    name: string
    abbreviation: string
    measurements?: MeasurementUncheckedCreateNestedManyWithoutUnitInput
  }

  export type UnitUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    measurements?: MeasurementUpdateManyWithoutUnitInput
  }

  export type UnitUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
    measurements?: MeasurementUncheckedUpdateManyWithoutUnitInput
  }

  export type UnitCreateManyInput = {
    id?: number
    name: string
    abbreviation: string
  }

  export type UnitUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type UnitUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type MeasurementCreateInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementUpdateInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasurementCreateManyInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementUpdateManyMutationInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
  }

  export type MeasurementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServingCreateInput = {
    name: string
    measurement: MeasurementCreateNestedOneWithoutServingsInput
    products?: ProductCreateNestedManyWithoutServingInput
  }

  export type ServingUncheckedCreateInput = {
    id?: number
    name: string
    measurementId: number
    products?: ProductUncheckedCreateNestedManyWithoutServingInput
  }

  export type ServingUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    measurement?: MeasurementUpdateOneRequiredWithoutServingsInput
    products?: ProductUpdateManyWithoutServingInput
  }

  export type ServingUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    measurementId?: IntFieldUpdateOperationsInput | number
    products?: ProductUncheckedUpdateManyWithoutServingInput
  }

  export type ServingCreateManyInput = {
    id?: number
    name: string
    measurementId: number
  }

  export type ServingUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type ServingUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type EnergyCreateInput = {
    measurements?: MeasurementCreateNestedManyWithoutEnergyInput
    nutritionFact: NutritionFactCreateNestedOneWithoutEnergyInput
  }

  export type EnergyUncheckedCreateInput = {
    id?: number
    measurements?: MeasurementUncheckedCreateNestedManyWithoutEnergyInput
    nutritionFactId: number
  }

  export type EnergyUpdateInput = {
    measurements?: MeasurementUpdateManyWithoutEnergyInput
    nutritionFact?: NutritionFactUpdateOneRequiredWithoutEnergyInput
  }

  export type EnergyUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurements?: MeasurementUncheckedUpdateManyWithoutEnergyInput
    nutritionFactId?: IntFieldUpdateOperationsInput | number
  }

  export type EnergyCreateManyInput = {
    id?: number
    nutritionFactId: number
  }

  export type EnergyUpdateManyMutationInput = {

  }

  export type EnergyUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nutritionFactId?: IntFieldUpdateOperationsInput | number
  }

  export type ProteinCreateInput = {
    measurements?: MeasurementCreateNestedManyWithoutProteinInput
    NutritionFact?: NutritionFactCreateNestedManyWithoutProteinInput
  }

  export type ProteinUncheckedCreateInput = {
    id?: number
    measurements?: MeasurementUncheckedCreateNestedManyWithoutProteinInput
    NutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutProteinInput
  }

  export type ProteinUpdateInput = {
    measurements?: MeasurementUpdateManyWithoutProteinInput
    NutritionFact?: NutritionFactUpdateManyWithoutProteinInput
  }

  export type ProteinUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurements?: MeasurementUncheckedUpdateManyWithoutProteinInput
    NutritionFact?: NutritionFactUncheckedUpdateManyWithoutProteinInput
  }

  export type ProteinCreateManyInput = {
    id?: number
  }

  export type ProteinUpdateManyMutationInput = {

  }

  export type ProteinUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type CholesterolCreateInput = {
    measurements?: MeasurementCreateNestedManyWithoutCholesterolInput
    NutritionFact?: NutritionFactCreateNestedManyWithoutCholesterolInput
  }

  export type CholesterolUncheckedCreateInput = {
    id?: number
    measurements?: MeasurementUncheckedCreateNestedManyWithoutCholesterolInput
    NutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutCholesterolInput
  }

  export type CholesterolUpdateInput = {
    measurements?: MeasurementUpdateManyWithoutCholesterolInput
    NutritionFact?: NutritionFactUpdateManyWithoutCholesterolInput
  }

  export type CholesterolUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurements?: MeasurementUncheckedUpdateManyWithoutCholesterolInput
    NutritionFact?: NutritionFactUncheckedUpdateManyWithoutCholesterolInput
  }

  export type CholesterolCreateManyInput = {
    id?: number
  }

  export type CholesterolUpdateManyMutationInput = {

  }

  export type CholesterolUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type FiberCreateInput = {
    measurements?: MeasurementCreateNestedManyWithoutCiberInput
    NutritionFact?: NutritionFactCreateNestedManyWithoutFiberInput
  }

  export type FiberUncheckedCreateInput = {
    id?: number
    measurements?: MeasurementUncheckedCreateNestedManyWithoutCiberInput
    NutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutFiberInput
  }

  export type FiberUpdateInput = {
    measurements?: MeasurementUpdateManyWithoutCiberInput
    NutritionFact?: NutritionFactUpdateManyWithoutFiberInput
  }

  export type FiberUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurements?: MeasurementUncheckedUpdateManyWithoutCiberInput
    NutritionFact?: NutritionFactUncheckedUpdateManyWithoutFiberInput
  }

  export type FiberCreateManyInput = {
    id?: number
  }

  export type FiberUpdateManyMutationInput = {

  }

  export type FiberUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type WaterCreateInput = {
    measurements?: MeasurementCreateNestedManyWithoutCaterInput
    NutritionFact?: NutritionFactCreateNestedManyWithoutWaterInput
  }

  export type WaterUncheckedCreateInput = {
    id?: number
    measurements?: MeasurementUncheckedCreateNestedManyWithoutCaterInput
    NutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutWaterInput
  }

  export type WaterUpdateInput = {
    measurements?: MeasurementUpdateManyWithoutCaterInput
    NutritionFact?: NutritionFactUpdateManyWithoutWaterInput
  }

  export type WaterUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurements?: MeasurementUncheckedUpdateManyWithoutCaterInput
    NutritionFact?: NutritionFactUncheckedUpdateManyWithoutWaterInput
  }

  export type WaterCreateManyInput = {
    id?: number
  }

  export type WaterUpdateManyMutationInput = {

  }

  export type WaterUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type NutritionFactCreateInput = {
    energy?: EnergyCreateNestedManyWithoutNutritionFactInput
    protein?: ProteinCreateNestedOneWithoutNutritionFactInput
    fats?: FatCreateNestedOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateCreateNestedOneWithoutNutritionFactsInput
    fiber?: FiberCreateNestedOneWithoutNutritionFactInput
    water?: WaterCreateNestedOneWithoutNutritionFactInput
    vitamins?: VitaminCreateNestedOneWithoutNutritionFactsInput
    minerals?: MineralCreateNestedOneWithoutNutritionFactInput
    cholesterol?: CholesterolCreateNestedOneWithoutNutritionFactInput
    product?: ProductCreateNestedOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedCreateInput = {
    id?: number
    energy?: EnergyUncheckedCreateNestedManyWithoutNutritionFactInput
    proteinId?: number | null
    fatId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type NutritionFactUpdateInput = {
    energy?: EnergyUpdateManyWithoutNutritionFactInput
    protein?: ProteinUpdateOneWithoutNutritionFactInput
    fats?: FatUpdateOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateUpdateOneWithoutNutritionFactsInput
    fiber?: FiberUpdateOneWithoutNutritionFactInput
    water?: WaterUpdateOneWithoutNutritionFactInput
    vitamins?: VitaminUpdateOneWithoutNutritionFactsInput
    minerals?: MineralUpdateOneWithoutNutritionFactInput
    cholesterol?: CholesterolUpdateOneWithoutNutritionFactInput
    product?: ProductUpdateOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    energy?: EnergyUncheckedUpdateManyWithoutNutritionFactInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    fatId?: NullableIntFieldUpdateOperationsInput | number | null
    carbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminId?: NullableIntFieldUpdateOperationsInput | number | null
    mineralId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NutritionFactCreateManyInput = {
    id?: number
    proteinId?: number | null
    fatId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type NutritionFactUpdateManyMutationInput = {

  }

  export type NutritionFactUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    fatId?: NullableIntFieldUpdateOperationsInput | number | null
    carbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminId?: NullableIntFieldUpdateOperationsInput | number | null
    mineralId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductCreateInput = {
    name: string
    labels?: LabelCreateNestedManyWithoutProductsInput
    ean?: string | null
    manufacturer: string
    group: string
    serving: ServingCreateNestedOneWithoutProductsInput
    nutritionFact?: NutritionFactCreateNestedOneWithoutProductInput
    nutritionFactId?: number | null
  }

  export type ProductUncheckedCreateInput = {
    id?: number
    name: string
    labels?: LabelUncheckedCreateNestedManyWithoutProductsInput
    ean?: string | null
    manufacturer: string
    group: string
    servingId: number
    nutritionFact?: NutritionFactUncheckedCreateNestedOneWithoutProductInput
    nutritionFactId?: number | null
  }

  export type ProductUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    labels?: LabelUpdateManyWithoutProductsInput
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    serving?: ServingUpdateOneRequiredWithoutProductsInput
    nutritionFact?: NutritionFactUpdateOneWithoutProductInput
    nutritionFactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    labels?: LabelUncheckedUpdateManyWithoutProductsInput
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    servingId?: IntFieldUpdateOperationsInput | number
    nutritionFact?: NutritionFactUncheckedUpdateOneWithoutProductInput
    nutritionFactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductCreateManyInput = {
    id?: number
    name: string
    ean?: string | null
    manufacturer: string
    group: string
    servingId: number
    nutritionFactId?: number | null
  }

  export type ProductUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    nutritionFactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    servingId?: IntFieldUpdateOperationsInput | number
    nutritionFactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type ResourceCountOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    slug?: SortOrder
  }

  export type ResourceAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ResourceMaxOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    slug?: SortOrder
  }

  export type ResourceMinOrderByAggregateInput = {
    id?: SortOrder
    displayName?: SortOrder
    slug?: SortOrder
  }

  export type ResourceSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type ProductListRelationFilter = {
    every?: ProductWhereInput
    some?: ProductWhereInput
    none?: ProductWhereInput
  }

  export type ProductOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LabelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type LabelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LabelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
  }

  export type LabelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TotalFatRelationFilter = {
    is?: TotalFatWhereInput | null
    isNot?: TotalFatWhereInput | null
  }

  export type SaturatedFatRelationFilter = {
    is?: SaturatedFatWhereInput | null
    isNot?: SaturatedFatWhereInput | null
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type MonosaturatedFatRelationFilter = {
    is?: MonosaturatedFatWhereInput | null
    isNot?: MonosaturatedFatWhereInput | null
  }

  export type PolyunsaturatedFatRelationFilter = {
    is?: PolyunsaturatedFatWhereInput | null
    isNot?: PolyunsaturatedFatWhereInput | null
  }

  export type TransFatRelationFilter = {
    is?: TransFatWhereInput | null
    isNot?: TransFatWhereInput | null
  }

  export type NutritionFactListRelationFilter = {
    every?: NutritionFactWhereInput
    some?: NutritionFactWhereInput
    none?: NutritionFactWhereInput
  }

  export type NutritionFactOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FatCountOrderByAggregateInput = {
    id?: SortOrder
    totalFatId?: SortOrder
    saturatedFatId?: SortOrder
    monosaturatedFatId?: SortOrder
    polyunsaturatedFatId?: SortOrder
    transFatId?: SortOrder
  }

  export type FatAvgOrderByAggregateInput = {
    id?: SortOrder
    totalFatId?: SortOrder
    saturatedFatId?: SortOrder
    monosaturatedFatId?: SortOrder
    polyunsaturatedFatId?: SortOrder
    transFatId?: SortOrder
  }

  export type FatMaxOrderByAggregateInput = {
    id?: SortOrder
    totalFatId?: SortOrder
    saturatedFatId?: SortOrder
    monosaturatedFatId?: SortOrder
    polyunsaturatedFatId?: SortOrder
    transFatId?: SortOrder
  }

  export type FatMinOrderByAggregateInput = {
    id?: SortOrder
    totalFatId?: SortOrder
    saturatedFatId?: SortOrder
    monosaturatedFatId?: SortOrder
    polyunsaturatedFatId?: SortOrder
    transFatId?: SortOrder
  }

  export type FatSumOrderByAggregateInput = {
    id?: SortOrder
    totalFatId?: SortOrder
    saturatedFatId?: SortOrder
    monosaturatedFatId?: SortOrder
    polyunsaturatedFatId?: SortOrder
    transFatId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type MeasurementRelationFilter = {
    is?: MeasurementWhereInput
    isNot?: MeasurementWhereInput
  }

  export type FatRelationFilter = {
    is?: FatWhereInput | null
    isNot?: FatWhereInput | null
  }

  export type TotalFatCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type TotalFatAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type TotalFatMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type TotalFatMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type TotalFatSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SaturatedFatCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SaturatedFatAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SaturatedFatMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SaturatedFatMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SaturatedFatSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type MonosaturatedFatCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type MonosaturatedFatAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type MonosaturatedFatMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type MonosaturatedFatMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type MonosaturatedFatSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PolyunsaturatedFatCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PolyunsaturatedFatAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PolyunsaturatedFatMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PolyunsaturatedFatMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PolyunsaturatedFatSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type TransFatCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type TransFatAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type TransFatMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type TransFatMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type TransFatSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type TotalCarbohydrateRelationFilter = {
    is?: TotalCarbohydrateWhereInput | null
    isNot?: TotalCarbohydrateWhereInput | null
  }

  export type SugarCarbohydrateRelationFilter = {
    is?: SugarCarbohydrateWhereInput | null
    isNot?: SugarCarbohydrateWhereInput | null
  }

  export type CarbohydrateCountOrderByAggregateInput = {
    id?: SortOrder
    totalCarbohydrateId?: SortOrder
    sugarCarbohydrateId?: SortOrder
  }

  export type CarbohydrateAvgOrderByAggregateInput = {
    id?: SortOrder
    totalCarbohydrateId?: SortOrder
    sugarCarbohydrateId?: SortOrder
  }

  export type CarbohydrateMaxOrderByAggregateInput = {
    id?: SortOrder
    totalCarbohydrateId?: SortOrder
    sugarCarbohydrateId?: SortOrder
  }

  export type CarbohydrateMinOrderByAggregateInput = {
    id?: SortOrder
    totalCarbohydrateId?: SortOrder
    sugarCarbohydrateId?: SortOrder
  }

  export type CarbohydrateSumOrderByAggregateInput = {
    id?: SortOrder
    totalCarbohydrateId?: SortOrder
    sugarCarbohydrateId?: SortOrder
  }

  export type CarbohydrateRelationFilter = {
    is?: CarbohydrateWhereInput | null
    isNot?: CarbohydrateWhereInput | null
  }

  export type TotalCarbohydrateCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type TotalCarbohydrateAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type TotalCarbohydrateMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type TotalCarbohydrateMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type TotalCarbohydrateSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SugarCarbohydrateCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SugarCarbohydrateAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SugarCarbohydrateMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SugarCarbohydrateMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SugarCarbohydrateSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminCRelationFilter = {
    is?: VitaminCWhereInput | null
    isNot?: VitaminCWhereInput | null
  }

  export type VitaminARelationFilter = {
    is?: VitaminAWhereInput | null
    isNot?: VitaminAWhereInput | null
  }

  export type VitaminDRelationFilter = {
    is?: VitaminDWhereInput | null
    isNot?: VitaminDWhereInput | null
  }

  export type VitaminERelationFilter = {
    is?: VitaminEWhereInput | null
    isNot?: VitaminEWhereInput | null
  }

  export type VitaminB1RelationFilter = {
    is?: VitaminB1WhereInput | null
    isNot?: VitaminB1WhereInput | null
  }

  export type VitaminB2RelationFilter = {
    is?: VitaminB2WhereInput | null
    isNot?: VitaminB2WhereInput | null
  }

  export type VitaminB6RelationFilter = {
    is?: VitaminB6WhereInput | null
    isNot?: VitaminB6WhereInput | null
  }

  export type VitaminB12RelationFilter = {
    is?: VitaminB12WhereInput | null
    isNot?: VitaminB12WhereInput | null
  }

  export type MeasurementListRelationFilter = {
    every?: MeasurementWhereInput
    some?: MeasurementWhereInput
    none?: MeasurementWhereInput
  }

  export type MeasurementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitaminCountOrderByAggregateInput = {
    id?: SortOrder
    vitaminCId?: SortOrder
    vitaminAId?: SortOrder
    vitaminDId?: SortOrder
    vitaminEId?: SortOrder
    vitaminB1Id?: SortOrder
    vitaminB2Id?: SortOrder
    vitaminB6Id?: SortOrder
    vitaminB12Id?: SortOrder
  }

  export type VitaminAvgOrderByAggregateInput = {
    id?: SortOrder
    vitaminCId?: SortOrder
    vitaminAId?: SortOrder
    vitaminDId?: SortOrder
    vitaminEId?: SortOrder
    vitaminB1Id?: SortOrder
    vitaminB2Id?: SortOrder
    vitaminB6Id?: SortOrder
    vitaminB12Id?: SortOrder
  }

  export type VitaminMaxOrderByAggregateInput = {
    id?: SortOrder
    vitaminCId?: SortOrder
    vitaminAId?: SortOrder
    vitaminDId?: SortOrder
    vitaminEId?: SortOrder
    vitaminB1Id?: SortOrder
    vitaminB2Id?: SortOrder
    vitaminB6Id?: SortOrder
    vitaminB12Id?: SortOrder
  }

  export type VitaminMinOrderByAggregateInput = {
    id?: SortOrder
    vitaminCId?: SortOrder
    vitaminAId?: SortOrder
    vitaminDId?: SortOrder
    vitaminEId?: SortOrder
    vitaminB1Id?: SortOrder
    vitaminB2Id?: SortOrder
    vitaminB6Id?: SortOrder
    vitaminB12Id?: SortOrder
  }

  export type VitaminSumOrderByAggregateInput = {
    id?: SortOrder
    vitaminCId?: SortOrder
    vitaminAId?: SortOrder
    vitaminDId?: SortOrder
    vitaminEId?: SortOrder
    vitaminB1Id?: SortOrder
    vitaminB2Id?: SortOrder
    vitaminB6Id?: SortOrder
    vitaminB12Id?: SortOrder
  }

  export type VitaminRelationFilter = {
    is?: VitaminWhereInput | null
    isNot?: VitaminWhereInput | null
  }

  export type VitaminCCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminCAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminCMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminCMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminCSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminACountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminAAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminAMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminAMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminASumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminDCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminDAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminDMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminDMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminDSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminECountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminEAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminEMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminEMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminESumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB1CountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB1AvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB1MaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB1MinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB1SumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB2CountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB2AvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB2MaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB2MinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB2SumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB6CountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB6AvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB6MaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB6MinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB6SumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB12CountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB12AvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB12MaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB12MinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type VitaminB12SumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type MineralListRelationFilter = {
    every?: MineralWhereInput
    some?: MineralWhereInput
    none?: MineralWhereInput
  }

  export type MineralOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaltCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SaltAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SaltMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SaltMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SaltSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ZincCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ZincAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ZincMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ZincMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ZincSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type IronCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type IronAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type IronMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type IronMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type IronSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type MagnesiumCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type MagnesiumAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type MagnesiumMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type MagnesiumMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type MagnesiumSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ChlorideCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ChlorideAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ChlorideMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ChlorideMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ChlorideSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ManganeseCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ManganeseAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ManganeseMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ManganeseMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ManganeseSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SulfurCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SulfurAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SulfurMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SulfurMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SulfurSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PotassiumCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PotassiumAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PotassiumMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PotassiumMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PotassiumSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type FluorideCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type FluorideAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type FluorideMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type FluorideMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type FluorideSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PhosphorousCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PhosphorousAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PhosphorousMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PhosphorousMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type PhosphorousSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type CopperCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type CopperAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type CopperMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type CopperMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type CopperSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type IodineCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type IodineAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type IodineMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type IodineMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type IodineSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type CalciumCountOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type CalciumAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type CalciumMaxOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type CalciumMinOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type CalciumSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type SaltRelationFilter = {
    is?: SaltWhereInput | null
    isNot?: SaltWhereInput | null
  }

  export type IronRelationFilter = {
    is?: IronWhereInput | null
    isNot?: IronWhereInput | null
  }

  export type ZincRelationFilter = {
    is?: ZincWhereInput | null
    isNot?: ZincWhereInput | null
  }

  export type MagnesiumRelationFilter = {
    is?: MagnesiumWhereInput | null
    isNot?: MagnesiumWhereInput | null
  }

  export type ChlorideRelationFilter = {
    is?: ChlorideWhereInput | null
    isNot?: ChlorideWhereInput | null
  }

  export type ManganeseRelationFilter = {
    is?: ManganeseWhereInput | null
    isNot?: ManganeseWhereInput | null
  }

  export type SulfurRelationFilter = {
    is?: SulfurWhereInput | null
    isNot?: SulfurWhereInput | null
  }

  export type PotassiumRelationFilter = {
    is?: PotassiumWhereInput | null
    isNot?: PotassiumWhereInput | null
  }

  export type FluorideRelationFilter = {
    is?: FluorideWhereInput | null
    isNot?: FluorideWhereInput | null
  }

  export type PhosphorousRelationFilter = {
    is?: PhosphorousWhereInput | null
    isNot?: PhosphorousWhereInput | null
  }

  export type CopperRelationFilter = {
    is?: CopperWhereInput | null
    isNot?: CopperWhereInput | null
  }

  export type IodineRelationFilter = {
    is?: IodineWhereInput | null
    isNot?: IodineWhereInput | null
  }

  export type CalciumRelationFilter = {
    is?: CalciumWhereInput | null
    isNot?: CalciumWhereInput | null
  }

  export type MineralCountOrderByAggregateInput = {
    id?: SortOrder
    saltId?: SortOrder
    ironId?: SortOrder
    zincId?: SortOrder
    magnesiumId?: SortOrder
    chlorideId?: SortOrder
    manganeseId?: SortOrder
    sulfurId?: SortOrder
    potassiumId?: SortOrder
    fluorideId?: SortOrder
    phosphorousId?: SortOrder
    copperId?: SortOrder
    iodineId?: SortOrder
    calciumId?: SortOrder
  }

  export type MineralAvgOrderByAggregateInput = {
    id?: SortOrder
    saltId?: SortOrder
    ironId?: SortOrder
    zincId?: SortOrder
    magnesiumId?: SortOrder
    chlorideId?: SortOrder
    manganeseId?: SortOrder
    sulfurId?: SortOrder
    potassiumId?: SortOrder
    fluorideId?: SortOrder
    phosphorousId?: SortOrder
    copperId?: SortOrder
    iodineId?: SortOrder
    calciumId?: SortOrder
  }

  export type MineralMaxOrderByAggregateInput = {
    id?: SortOrder
    saltId?: SortOrder
    ironId?: SortOrder
    zincId?: SortOrder
    magnesiumId?: SortOrder
    chlorideId?: SortOrder
    manganeseId?: SortOrder
    sulfurId?: SortOrder
    potassiumId?: SortOrder
    fluorideId?: SortOrder
    phosphorousId?: SortOrder
    copperId?: SortOrder
    iodineId?: SortOrder
    calciumId?: SortOrder
  }

  export type MineralMinOrderByAggregateInput = {
    id?: SortOrder
    saltId?: SortOrder
    ironId?: SortOrder
    zincId?: SortOrder
    magnesiumId?: SortOrder
    chlorideId?: SortOrder
    manganeseId?: SortOrder
    sulfurId?: SortOrder
    potassiumId?: SortOrder
    fluorideId?: SortOrder
    phosphorousId?: SortOrder
    copperId?: SortOrder
    iodineId?: SortOrder
    calciumId?: SortOrder
  }

  export type MineralSumOrderByAggregateInput = {
    id?: SortOrder
    saltId?: SortOrder
    ironId?: SortOrder
    zincId?: SortOrder
    magnesiumId?: SortOrder
    chlorideId?: SortOrder
    manganeseId?: SortOrder
    sulfurId?: SortOrder
    potassiumId?: SortOrder
    fluorideId?: SortOrder
    phosphorousId?: SortOrder
    copperId?: SortOrder
    iodineId?: SortOrder
    calciumId?: SortOrder
  }

  export type UnitCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
  }

  export type UnitAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UnitMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
  }

  export type UnitMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    abbreviation?: SortOrder
  }

  export type UnitSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type DecimalNullableFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableFilter | Decimal | number | string | null
  }

  export type UnitRelationFilter = {
    is?: UnitWhereInput
    isNot?: UnitWhereInput
  }

  export type ServingListRelationFilter = {
    every?: ServingWhereInput
    some?: ServingWhereInput
    none?: ServingWhereInput
  }

  export type VitaminListRelationFilter = {
    every?: VitaminWhereInput
    some?: VitaminWhereInput
    none?: VitaminWhereInput
  }

  export type SaltListRelationFilter = {
    every?: SaltWhereInput
    some?: SaltWhereInput
    none?: SaltWhereInput
  }

  export type ZincListRelationFilter = {
    every?: ZincWhereInput
    some?: ZincWhereInput
    none?: ZincWhereInput
  }

  export type IronListRelationFilter = {
    every?: IronWhereInput
    some?: IronWhereInput
    none?: IronWhereInput
  }

  export type MagnesiumListRelationFilter = {
    every?: MagnesiumWhereInput
    some?: MagnesiumWhereInput
    none?: MagnesiumWhereInput
  }

  export type ChlorideListRelationFilter = {
    every?: ChlorideWhereInput
    some?: ChlorideWhereInput
    none?: ChlorideWhereInput
  }

  export type ManganeseListRelationFilter = {
    every?: ManganeseWhereInput
    some?: ManganeseWhereInput
    none?: ManganeseWhereInput
  }

  export type SulfurListRelationFilter = {
    every?: SulfurWhereInput
    some?: SulfurWhereInput
    none?: SulfurWhereInput
  }

  export type PotassiumListRelationFilter = {
    every?: PotassiumWhereInput
    some?: PotassiumWhereInput
    none?: PotassiumWhereInput
  }

  export type FluorideListRelationFilter = {
    every?: FluorideWhereInput
    some?: FluorideWhereInput
    none?: FluorideWhereInput
  }

  export type PhosphorousListRelationFilter = {
    every?: PhosphorousWhereInput
    some?: PhosphorousWhereInput
    none?: PhosphorousWhereInput
  }

  export type CopperListRelationFilter = {
    every?: CopperWhereInput
    some?: CopperWhereInput
    none?: CopperWhereInput
  }

  export type IodineListRelationFilter = {
    every?: IodineWhereInput
    some?: IodineWhereInput
    none?: IodineWhereInput
  }

  export type CalciumListRelationFilter = {
    every?: CalciumWhereInput
    some?: CalciumWhereInput
    none?: CalciumWhereInput
  }

  export type TotalFatListRelationFilter = {
    every?: TotalFatWhereInput
    some?: TotalFatWhereInput
    none?: TotalFatWhereInput
  }

  export type SaturatedFatListRelationFilter = {
    every?: SaturatedFatWhereInput
    some?: SaturatedFatWhereInput
    none?: SaturatedFatWhereInput
  }

  export type MonosaturatedFatListRelationFilter = {
    every?: MonosaturatedFatWhereInput
    some?: MonosaturatedFatWhereInput
    none?: MonosaturatedFatWhereInput
  }

  export type PolyunsaturatedFatListRelationFilter = {
    every?: PolyunsaturatedFatWhereInput
    some?: PolyunsaturatedFatWhereInput
    none?: PolyunsaturatedFatWhereInput
  }

  export type TransFatListRelationFilter = {
    every?: TransFatWhereInput
    some?: TransFatWhereInput
    none?: TransFatWhereInput
  }

  export type TotalCarbohydrateListRelationFilter = {
    every?: TotalCarbohydrateWhereInput
    some?: TotalCarbohydrateWhereInput
    none?: TotalCarbohydrateWhereInput
  }

  export type SugarCarbohydrateListRelationFilter = {
    every?: SugarCarbohydrateWhereInput
    some?: SugarCarbohydrateWhereInput
    none?: SugarCarbohydrateWhereInput
  }

  export type VitaminCListRelationFilter = {
    every?: VitaminCWhereInput
    some?: VitaminCWhereInput
    none?: VitaminCWhereInput
  }

  export type VitaminAListRelationFilter = {
    every?: VitaminAWhereInput
    some?: VitaminAWhereInput
    none?: VitaminAWhereInput
  }

  export type VitaminDListRelationFilter = {
    every?: VitaminDWhereInput
    some?: VitaminDWhereInput
    none?: VitaminDWhereInput
  }

  export type VitaminEListRelationFilter = {
    every?: VitaminEWhereInput
    some?: VitaminEWhereInput
    none?: VitaminEWhereInput
  }

  export type VitaminB1ListRelationFilter = {
    every?: VitaminB1WhereInput
    some?: VitaminB1WhereInput
    none?: VitaminB1WhereInput
  }

  export type VitaminB2ListRelationFilter = {
    every?: VitaminB2WhereInput
    some?: VitaminB2WhereInput
    none?: VitaminB2WhereInput
  }

  export type VitaminB6ListRelationFilter = {
    every?: VitaminB6WhereInput
    some?: VitaminB6WhereInput
    none?: VitaminB6WhereInput
  }

  export type VitaminB12ListRelationFilter = {
    every?: VitaminB12WhereInput
    some?: VitaminB12WhereInput
    none?: VitaminB12WhereInput
  }

  export type EnergyListRelationFilter = {
    every?: EnergyWhereInput
    some?: EnergyWhereInput
    none?: EnergyWhereInput
  }

  export type ProteinRelationFilter = {
    is?: ProteinWhereInput | null
    isNot?: ProteinWhereInput | null
  }

  export type CholesterolRelationFilter = {
    is?: CholesterolWhereInput | null
    isNot?: CholesterolWhereInput | null
  }

  export type FiberRelationFilter = {
    is?: FiberWhereInput | null
    isNot?: FiberWhereInput | null
  }

  export type WaterRelationFilter = {
    is?: WaterWhereInput | null
    isNot?: WaterWhereInput | null
  }

  export type ServingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitaminOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaltOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ZincOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IronOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MagnesiumOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChlorideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ManganeseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SulfurOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PotassiumOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FluorideOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhosphorousOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CopperOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type IodineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CalciumOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TotalFatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SaturatedFatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MonosaturatedFatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PolyunsaturatedFatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransFatOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TotalCarbohydrateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SugarCarbohydrateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitaminCOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitaminAOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitaminDOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitaminEOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitaminB1OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitaminB2OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitaminB6OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VitaminB12OrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EnergyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeasurementCountOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
    proteinId?: SortOrder
    cholesterolId?: SortOrder
    fiberId?: SortOrder
    waterId?: SortOrder
  }

  export type MeasurementAvgOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
    proteinId?: SortOrder
    cholesterolId?: SortOrder
    fiberId?: SortOrder
    waterId?: SortOrder
  }

  export type MeasurementMaxOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
    proteinId?: SortOrder
    cholesterolId?: SortOrder
    fiberId?: SortOrder
    waterId?: SortOrder
  }

  export type MeasurementMinOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
    proteinId?: SortOrder
    cholesterolId?: SortOrder
    fiberId?: SortOrder
    waterId?: SortOrder
  }

  export type MeasurementSumOrderByAggregateInput = {
    id?: SortOrder
    value?: SortOrder
    unitId?: SortOrder
    proteinId?: SortOrder
    cholesterolId?: SortOrder
    fiberId?: SortOrder
    waterId?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type ServingCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    measurementId?: SortOrder
  }

  export type ServingAvgOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type ServingMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    measurementId?: SortOrder
  }

  export type ServingMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    measurementId?: SortOrder
  }

  export type ServingSumOrderByAggregateInput = {
    id?: SortOrder
    measurementId?: SortOrder
  }

  export type NutritionFactRelationFilter = {
    is?: NutritionFactWhereInput
    isNot?: NutritionFactWhereInput
  }

  export type EnergyCountOrderByAggregateInput = {
    id?: SortOrder
    nutritionFactId?: SortOrder
  }

  export type EnergyAvgOrderByAggregateInput = {
    id?: SortOrder
    nutritionFactId?: SortOrder
  }

  export type EnergyMaxOrderByAggregateInput = {
    id?: SortOrder
    nutritionFactId?: SortOrder
  }

  export type EnergyMinOrderByAggregateInput = {
    id?: SortOrder
    nutritionFactId?: SortOrder
  }

  export type EnergySumOrderByAggregateInput = {
    id?: SortOrder
    nutritionFactId?: SortOrder
  }

  export type ProteinCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProteinAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProteinMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProteinMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProteinSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CholesterolCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CholesterolAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CholesterolMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CholesterolMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CholesterolSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FiberCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FiberAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FiberMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FiberMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FiberSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WaterCountOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WaterAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WaterMaxOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WaterMinOrderByAggregateInput = {
    id?: SortOrder
  }

  export type WaterSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type MineralRelationFilter = {
    is?: MineralWhereInput | null
    isNot?: MineralWhereInput | null
  }

  export type ProductRelationFilter = {
    is?: ProductWhereInput | null
    isNot?: ProductWhereInput | null
  }

  export type NutritionFactCountOrderByAggregateInput = {
    id?: SortOrder
    proteinId?: SortOrder
    fatId?: SortOrder
    carbohydrateId?: SortOrder
    fiberId?: SortOrder
    vitaminId?: SortOrder
    mineralId?: SortOrder
    cholesterolId?: SortOrder
    waterId?: SortOrder
    productId?: SortOrder
  }

  export type NutritionFactAvgOrderByAggregateInput = {
    id?: SortOrder
    proteinId?: SortOrder
    fatId?: SortOrder
    carbohydrateId?: SortOrder
    fiberId?: SortOrder
    vitaminId?: SortOrder
    mineralId?: SortOrder
    cholesterolId?: SortOrder
    waterId?: SortOrder
    productId?: SortOrder
  }

  export type NutritionFactMaxOrderByAggregateInput = {
    id?: SortOrder
    proteinId?: SortOrder
    fatId?: SortOrder
    carbohydrateId?: SortOrder
    fiberId?: SortOrder
    vitaminId?: SortOrder
    mineralId?: SortOrder
    cholesterolId?: SortOrder
    waterId?: SortOrder
    productId?: SortOrder
  }

  export type NutritionFactMinOrderByAggregateInput = {
    id?: SortOrder
    proteinId?: SortOrder
    fatId?: SortOrder
    carbohydrateId?: SortOrder
    fiberId?: SortOrder
    vitaminId?: SortOrder
    mineralId?: SortOrder
    cholesterolId?: SortOrder
    waterId?: SortOrder
    productId?: SortOrder
  }

  export type NutritionFactSumOrderByAggregateInput = {
    id?: SortOrder
    proteinId?: SortOrder
    fatId?: SortOrder
    carbohydrateId?: SortOrder
    fiberId?: SortOrder
    vitaminId?: SortOrder
    mineralId?: SortOrder
    cholesterolId?: SortOrder
    waterId?: SortOrder
    productId?: SortOrder
  }

  export type LabelListRelationFilter = {
    every?: LabelWhereInput
    some?: LabelWhereInput
    none?: LabelWhereInput
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type ServingRelationFilter = {
    is?: ServingWhereInput
    isNot?: ServingWhereInput
  }

  export type LabelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProductCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ean?: SortOrder
    manufacturer?: SortOrder
    group?: SortOrder
    servingId?: SortOrder
    nutritionFactId?: SortOrder
  }

  export type ProductAvgOrderByAggregateInput = {
    id?: SortOrder
    servingId?: SortOrder
    nutritionFactId?: SortOrder
  }

  export type ProductMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ean?: SortOrder
    manufacturer?: SortOrder
    group?: SortOrder
    servingId?: SortOrder
    nutritionFactId?: SortOrder
  }

  export type ProductMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ean?: SortOrder
    manufacturer?: SortOrder
    group?: SortOrder
    servingId?: SortOrder
    nutritionFactId?: SortOrder
  }

  export type ProductSumOrderByAggregateInput = {
    id?: SortOrder
    servingId?: SortOrder
    nutritionFactId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ProductCreateNestedManyWithoutLabelsInput = {
    create?: XOR<Enumerable<ProductCreateWithoutLabelsInput>, Enumerable<ProductUncheckedCreateWithoutLabelsInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutLabelsInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutLabelsInput = {
    create?: XOR<Enumerable<ProductCreateWithoutLabelsInput>, Enumerable<ProductUncheckedCreateWithoutLabelsInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutLabelsInput>
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUpdateManyWithoutLabelsInput = {
    create?: XOR<Enumerable<ProductCreateWithoutLabelsInput>, Enumerable<ProductUncheckedCreateWithoutLabelsInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutLabelsInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutLabelsInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutLabelsInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutLabelsInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutLabelsInput = {
    create?: XOR<Enumerable<ProductCreateWithoutLabelsInput>, Enumerable<ProductUncheckedCreateWithoutLabelsInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutLabelsInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutLabelsInput>
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutLabelsInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutLabelsInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type TotalFatCreateNestedOneWithoutFatInput = {
    create?: XOR<TotalFatCreateWithoutFatInput, TotalFatUncheckedCreateWithoutFatInput>
    connectOrCreate?: TotalFatCreateOrConnectWithoutFatInput
    connect?: TotalFatWhereUniqueInput
  }

  export type SaturatedFatCreateNestedOneWithoutFatInput = {
    create?: XOR<SaturatedFatCreateWithoutFatInput, SaturatedFatUncheckedCreateWithoutFatInput>
    connectOrCreate?: SaturatedFatCreateOrConnectWithoutFatInput
    connect?: SaturatedFatWhereUniqueInput
  }

  export type MonosaturatedFatCreateNestedOneWithoutFatInput = {
    create?: XOR<MonosaturatedFatCreateWithoutFatInput, MonosaturatedFatUncheckedCreateWithoutFatInput>
    connectOrCreate?: MonosaturatedFatCreateOrConnectWithoutFatInput
    connect?: MonosaturatedFatWhereUniqueInput
  }

  export type PolyunsaturatedFatCreateNestedOneWithoutFatInput = {
    create?: XOR<PolyunsaturatedFatCreateWithoutFatInput, PolyunsaturatedFatUncheckedCreateWithoutFatInput>
    connectOrCreate?: PolyunsaturatedFatCreateOrConnectWithoutFatInput
    connect?: PolyunsaturatedFatWhereUniqueInput
  }

  export type TransFatCreateNestedOneWithoutFatInput = {
    create?: XOR<TransFatCreateWithoutFatInput, TransFatUncheckedCreateWithoutFatInput>
    connectOrCreate?: TransFatCreateOrConnectWithoutFatInput
    connect?: TransFatWhereUniqueInput
  }

  export type NutritionFactCreateNestedManyWithoutFatsInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutFatsInput>, Enumerable<NutritionFactUncheckedCreateWithoutFatsInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutFatsInput>
    createMany?: NutritionFactCreateManyFatsInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type NutritionFactUncheckedCreateNestedManyWithoutFatsInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutFatsInput>, Enumerable<NutritionFactUncheckedCreateWithoutFatsInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutFatsInput>
    createMany?: NutritionFactCreateManyFatsInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type TotalFatUpdateOneWithoutFatInput = {
    create?: XOR<TotalFatCreateWithoutFatInput, TotalFatUncheckedCreateWithoutFatInput>
    connectOrCreate?: TotalFatCreateOrConnectWithoutFatInput
    upsert?: TotalFatUpsertWithoutFatInput
    disconnect?: boolean
    delete?: boolean
    connect?: TotalFatWhereUniqueInput
    update?: XOR<TotalFatUpdateWithoutFatInput, TotalFatUncheckedUpdateWithoutFatInput>
  }

  export type SaturatedFatUpdateOneWithoutFatInput = {
    create?: XOR<SaturatedFatCreateWithoutFatInput, SaturatedFatUncheckedCreateWithoutFatInput>
    connectOrCreate?: SaturatedFatCreateOrConnectWithoutFatInput
    upsert?: SaturatedFatUpsertWithoutFatInput
    disconnect?: boolean
    delete?: boolean
    connect?: SaturatedFatWhereUniqueInput
    update?: XOR<SaturatedFatUpdateWithoutFatInput, SaturatedFatUncheckedUpdateWithoutFatInput>
  }

  export type MonosaturatedFatUpdateOneWithoutFatInput = {
    create?: XOR<MonosaturatedFatCreateWithoutFatInput, MonosaturatedFatUncheckedCreateWithoutFatInput>
    connectOrCreate?: MonosaturatedFatCreateOrConnectWithoutFatInput
    upsert?: MonosaturatedFatUpsertWithoutFatInput
    disconnect?: boolean
    delete?: boolean
    connect?: MonosaturatedFatWhereUniqueInput
    update?: XOR<MonosaturatedFatUpdateWithoutFatInput, MonosaturatedFatUncheckedUpdateWithoutFatInput>
  }

  export type PolyunsaturatedFatUpdateOneWithoutFatInput = {
    create?: XOR<PolyunsaturatedFatCreateWithoutFatInput, PolyunsaturatedFatUncheckedCreateWithoutFatInput>
    connectOrCreate?: PolyunsaturatedFatCreateOrConnectWithoutFatInput
    upsert?: PolyunsaturatedFatUpsertWithoutFatInput
    disconnect?: boolean
    delete?: boolean
    connect?: PolyunsaturatedFatWhereUniqueInput
    update?: XOR<PolyunsaturatedFatUpdateWithoutFatInput, PolyunsaturatedFatUncheckedUpdateWithoutFatInput>
  }

  export type TransFatUpdateOneWithoutFatInput = {
    create?: XOR<TransFatCreateWithoutFatInput, TransFatUncheckedCreateWithoutFatInput>
    connectOrCreate?: TransFatCreateOrConnectWithoutFatInput
    upsert?: TransFatUpsertWithoutFatInput
    disconnect?: boolean
    delete?: boolean
    connect?: TransFatWhereUniqueInput
    update?: XOR<TransFatUpdateWithoutFatInput, TransFatUncheckedUpdateWithoutFatInput>
  }

  export type NutritionFactUpdateManyWithoutFatsInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutFatsInput>, Enumerable<NutritionFactUncheckedCreateWithoutFatsInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutFatsInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutFatsInput>
    createMany?: NutritionFactCreateManyFatsInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutFatsInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutFatsInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NutritionFactUncheckedUpdateManyWithoutFatsInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutFatsInput>, Enumerable<NutritionFactUncheckedCreateWithoutFatsInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutFatsInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutFatsInput>
    createMany?: NutritionFactCreateManyFatsInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutFatsInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutFatsInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type MeasurementCreateNestedOneWithoutTotalFatInput = {
    create?: XOR<MeasurementCreateWithoutTotalFatInput, MeasurementUncheckedCreateWithoutTotalFatInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutTotalFatInput
    connect?: MeasurementWhereUniqueInput
  }

  export type FatCreateNestedOneWithoutTotalInput = {
    create?: XOR<FatCreateWithoutTotalInput, FatUncheckedCreateWithoutTotalInput>
    connectOrCreate?: FatCreateOrConnectWithoutTotalInput
    connect?: FatWhereUniqueInput
  }

  export type FatUncheckedCreateNestedOneWithoutTotalInput = {
    create?: XOR<FatCreateWithoutTotalInput, FatUncheckedCreateWithoutTotalInput>
    connectOrCreate?: FatCreateOrConnectWithoutTotalInput
    connect?: FatWhereUniqueInput
  }

  export type MeasurementUpdateOneWithoutTotalFatInput = {
    create?: XOR<MeasurementCreateWithoutTotalFatInput, MeasurementUncheckedCreateWithoutTotalFatInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutTotalFatInput
    upsert?: MeasurementUpsertWithoutTotalFatInput
    disconnect?: boolean
    delete?: boolean
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutTotalFatInput, MeasurementUncheckedUpdateWithoutTotalFatInput>
  }

  export type FatUpdateOneWithoutTotalInput = {
    create?: XOR<FatCreateWithoutTotalInput, FatUncheckedCreateWithoutTotalInput>
    connectOrCreate?: FatCreateOrConnectWithoutTotalInput
    upsert?: FatUpsertWithoutTotalInput
    disconnect?: boolean
    delete?: boolean
    connect?: FatWhereUniqueInput
    update?: XOR<FatUpdateWithoutTotalInput, FatUncheckedUpdateWithoutTotalInput>
  }

  export type FatUncheckedUpdateOneWithoutTotalInput = {
    create?: XOR<FatCreateWithoutTotalInput, FatUncheckedCreateWithoutTotalInput>
    connectOrCreate?: FatCreateOrConnectWithoutTotalInput
    upsert?: FatUpsertWithoutTotalInput
    disconnect?: boolean
    delete?: boolean
    connect?: FatWhereUniqueInput
    update?: XOR<FatUpdateWithoutTotalInput, FatUncheckedUpdateWithoutTotalInput>
  }

  export type MeasurementCreateNestedOneWithoutSaturatedFatInput = {
    create?: XOR<MeasurementCreateWithoutSaturatedFatInput, MeasurementUncheckedCreateWithoutSaturatedFatInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutSaturatedFatInput
    connect?: MeasurementWhereUniqueInput
  }

  export type FatCreateNestedOneWithoutSaturatedInput = {
    create?: XOR<FatCreateWithoutSaturatedInput, FatUncheckedCreateWithoutSaturatedInput>
    connectOrCreate?: FatCreateOrConnectWithoutSaturatedInput
    connect?: FatWhereUniqueInput
  }

  export type FatUncheckedCreateNestedOneWithoutSaturatedInput = {
    create?: XOR<FatCreateWithoutSaturatedInput, FatUncheckedCreateWithoutSaturatedInput>
    connectOrCreate?: FatCreateOrConnectWithoutSaturatedInput
    connect?: FatWhereUniqueInput
  }

  export type MeasurementUpdateOneRequiredWithoutSaturatedFatInput = {
    create?: XOR<MeasurementCreateWithoutSaturatedFatInput, MeasurementUncheckedCreateWithoutSaturatedFatInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutSaturatedFatInput
    upsert?: MeasurementUpsertWithoutSaturatedFatInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutSaturatedFatInput, MeasurementUncheckedUpdateWithoutSaturatedFatInput>
  }

  export type FatUpdateOneWithoutSaturatedInput = {
    create?: XOR<FatCreateWithoutSaturatedInput, FatUncheckedCreateWithoutSaturatedInput>
    connectOrCreate?: FatCreateOrConnectWithoutSaturatedInput
    upsert?: FatUpsertWithoutSaturatedInput
    disconnect?: boolean
    delete?: boolean
    connect?: FatWhereUniqueInput
    update?: XOR<FatUpdateWithoutSaturatedInput, FatUncheckedUpdateWithoutSaturatedInput>
  }

  export type FatUncheckedUpdateOneWithoutSaturatedInput = {
    create?: XOR<FatCreateWithoutSaturatedInput, FatUncheckedCreateWithoutSaturatedInput>
    connectOrCreate?: FatCreateOrConnectWithoutSaturatedInput
    upsert?: FatUpsertWithoutSaturatedInput
    disconnect?: boolean
    delete?: boolean
    connect?: FatWhereUniqueInput
    update?: XOR<FatUpdateWithoutSaturatedInput, FatUncheckedUpdateWithoutSaturatedInput>
  }

  export type MeasurementCreateNestedOneWithoutMonosaturatedFatInput = {
    create?: XOR<MeasurementCreateWithoutMonosaturatedFatInput, MeasurementUncheckedCreateWithoutMonosaturatedFatInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutMonosaturatedFatInput
    connect?: MeasurementWhereUniqueInput
  }

  export type FatCreateNestedOneWithoutMonounsaturatedInput = {
    create?: XOR<FatCreateWithoutMonounsaturatedInput, FatUncheckedCreateWithoutMonounsaturatedInput>
    connectOrCreate?: FatCreateOrConnectWithoutMonounsaturatedInput
    connect?: FatWhereUniqueInput
  }

  export type FatUncheckedCreateNestedOneWithoutMonounsaturatedInput = {
    create?: XOR<FatCreateWithoutMonounsaturatedInput, FatUncheckedCreateWithoutMonounsaturatedInput>
    connectOrCreate?: FatCreateOrConnectWithoutMonounsaturatedInput
    connect?: FatWhereUniqueInput
  }

  export type MeasurementUpdateOneRequiredWithoutMonosaturatedFatInput = {
    create?: XOR<MeasurementCreateWithoutMonosaturatedFatInput, MeasurementUncheckedCreateWithoutMonosaturatedFatInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutMonosaturatedFatInput
    upsert?: MeasurementUpsertWithoutMonosaturatedFatInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutMonosaturatedFatInput, MeasurementUncheckedUpdateWithoutMonosaturatedFatInput>
  }

  export type FatUpdateOneWithoutMonounsaturatedInput = {
    create?: XOR<FatCreateWithoutMonounsaturatedInput, FatUncheckedCreateWithoutMonounsaturatedInput>
    connectOrCreate?: FatCreateOrConnectWithoutMonounsaturatedInput
    upsert?: FatUpsertWithoutMonounsaturatedInput
    disconnect?: boolean
    delete?: boolean
    connect?: FatWhereUniqueInput
    update?: XOR<FatUpdateWithoutMonounsaturatedInput, FatUncheckedUpdateWithoutMonounsaturatedInput>
  }

  export type FatUncheckedUpdateOneWithoutMonounsaturatedInput = {
    create?: XOR<FatCreateWithoutMonounsaturatedInput, FatUncheckedCreateWithoutMonounsaturatedInput>
    connectOrCreate?: FatCreateOrConnectWithoutMonounsaturatedInput
    upsert?: FatUpsertWithoutMonounsaturatedInput
    disconnect?: boolean
    delete?: boolean
    connect?: FatWhereUniqueInput
    update?: XOR<FatUpdateWithoutMonounsaturatedInput, FatUncheckedUpdateWithoutMonounsaturatedInput>
  }

  export type MeasurementCreateNestedOneWithoutPolyunsaturatedFatInput = {
    create?: XOR<MeasurementCreateWithoutPolyunsaturatedFatInput, MeasurementUncheckedCreateWithoutPolyunsaturatedFatInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutPolyunsaturatedFatInput
    connect?: MeasurementWhereUniqueInput
  }

  export type FatCreateNestedOneWithoutPolyunsaturatedInput = {
    create?: XOR<FatCreateWithoutPolyunsaturatedInput, FatUncheckedCreateWithoutPolyunsaturatedInput>
    connectOrCreate?: FatCreateOrConnectWithoutPolyunsaturatedInput
    connect?: FatWhereUniqueInput
  }

  export type FatUncheckedCreateNestedOneWithoutPolyunsaturatedInput = {
    create?: XOR<FatCreateWithoutPolyunsaturatedInput, FatUncheckedCreateWithoutPolyunsaturatedInput>
    connectOrCreate?: FatCreateOrConnectWithoutPolyunsaturatedInput
    connect?: FatWhereUniqueInput
  }

  export type MeasurementUpdateOneRequiredWithoutPolyunsaturatedFatInput = {
    create?: XOR<MeasurementCreateWithoutPolyunsaturatedFatInput, MeasurementUncheckedCreateWithoutPolyunsaturatedFatInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutPolyunsaturatedFatInput
    upsert?: MeasurementUpsertWithoutPolyunsaturatedFatInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutPolyunsaturatedFatInput, MeasurementUncheckedUpdateWithoutPolyunsaturatedFatInput>
  }

  export type FatUpdateOneWithoutPolyunsaturatedInput = {
    create?: XOR<FatCreateWithoutPolyunsaturatedInput, FatUncheckedCreateWithoutPolyunsaturatedInput>
    connectOrCreate?: FatCreateOrConnectWithoutPolyunsaturatedInput
    upsert?: FatUpsertWithoutPolyunsaturatedInput
    disconnect?: boolean
    delete?: boolean
    connect?: FatWhereUniqueInput
    update?: XOR<FatUpdateWithoutPolyunsaturatedInput, FatUncheckedUpdateWithoutPolyunsaturatedInput>
  }

  export type FatUncheckedUpdateOneWithoutPolyunsaturatedInput = {
    create?: XOR<FatCreateWithoutPolyunsaturatedInput, FatUncheckedCreateWithoutPolyunsaturatedInput>
    connectOrCreate?: FatCreateOrConnectWithoutPolyunsaturatedInput
    upsert?: FatUpsertWithoutPolyunsaturatedInput
    disconnect?: boolean
    delete?: boolean
    connect?: FatWhereUniqueInput
    update?: XOR<FatUpdateWithoutPolyunsaturatedInput, FatUncheckedUpdateWithoutPolyunsaturatedInput>
  }

  export type MeasurementCreateNestedOneWithoutTransFatInput = {
    create?: XOR<MeasurementCreateWithoutTransFatInput, MeasurementUncheckedCreateWithoutTransFatInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutTransFatInput
    connect?: MeasurementWhereUniqueInput
  }

  export type FatCreateNestedOneWithoutTransInput = {
    create?: XOR<FatCreateWithoutTransInput, FatUncheckedCreateWithoutTransInput>
    connectOrCreate?: FatCreateOrConnectWithoutTransInput
    connect?: FatWhereUniqueInput
  }

  export type FatUncheckedCreateNestedOneWithoutTransInput = {
    create?: XOR<FatCreateWithoutTransInput, FatUncheckedCreateWithoutTransInput>
    connectOrCreate?: FatCreateOrConnectWithoutTransInput
    connect?: FatWhereUniqueInput
  }

  export type MeasurementUpdateOneRequiredWithoutTransFatInput = {
    create?: XOR<MeasurementCreateWithoutTransFatInput, MeasurementUncheckedCreateWithoutTransFatInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutTransFatInput
    upsert?: MeasurementUpsertWithoutTransFatInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutTransFatInput, MeasurementUncheckedUpdateWithoutTransFatInput>
  }

  export type FatUpdateOneWithoutTransInput = {
    create?: XOR<FatCreateWithoutTransInput, FatUncheckedCreateWithoutTransInput>
    connectOrCreate?: FatCreateOrConnectWithoutTransInput
    upsert?: FatUpsertWithoutTransInput
    disconnect?: boolean
    delete?: boolean
    connect?: FatWhereUniqueInput
    update?: XOR<FatUpdateWithoutTransInput, FatUncheckedUpdateWithoutTransInput>
  }

  export type FatUncheckedUpdateOneWithoutTransInput = {
    create?: XOR<FatCreateWithoutTransInput, FatUncheckedCreateWithoutTransInput>
    connectOrCreate?: FatCreateOrConnectWithoutTransInput
    upsert?: FatUpsertWithoutTransInput
    disconnect?: boolean
    delete?: boolean
    connect?: FatWhereUniqueInput
    update?: XOR<FatUpdateWithoutTransInput, FatUncheckedUpdateWithoutTransInput>
  }

  export type TotalCarbohydrateCreateNestedOneWithoutCarbohydrateInput = {
    create?: XOR<TotalCarbohydrateCreateWithoutCarbohydrateInput, TotalCarbohydrateUncheckedCreateWithoutCarbohydrateInput>
    connectOrCreate?: TotalCarbohydrateCreateOrConnectWithoutCarbohydrateInput
    connect?: TotalCarbohydrateWhereUniqueInput
  }

  export type SugarCarbohydrateCreateNestedOneWithoutCarbohydrateInput = {
    create?: XOR<SugarCarbohydrateCreateWithoutCarbohydrateInput, SugarCarbohydrateUncheckedCreateWithoutCarbohydrateInput>
    connectOrCreate?: SugarCarbohydrateCreateOrConnectWithoutCarbohydrateInput
    connect?: SugarCarbohydrateWhereUniqueInput
  }

  export type NutritionFactCreateNestedManyWithoutCarbohydrateInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutCarbohydrateInput>, Enumerable<NutritionFactUncheckedCreateWithoutCarbohydrateInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutCarbohydrateInput>
    createMany?: NutritionFactCreateManyCarbohydrateInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type NutritionFactUncheckedCreateNestedManyWithoutCarbohydrateInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutCarbohydrateInput>, Enumerable<NutritionFactUncheckedCreateWithoutCarbohydrateInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutCarbohydrateInput>
    createMany?: NutritionFactCreateManyCarbohydrateInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type TotalCarbohydrateUpdateOneWithoutCarbohydrateInput = {
    create?: XOR<TotalCarbohydrateCreateWithoutCarbohydrateInput, TotalCarbohydrateUncheckedCreateWithoutCarbohydrateInput>
    connectOrCreate?: TotalCarbohydrateCreateOrConnectWithoutCarbohydrateInput
    upsert?: TotalCarbohydrateUpsertWithoutCarbohydrateInput
    disconnect?: boolean
    delete?: boolean
    connect?: TotalCarbohydrateWhereUniqueInput
    update?: XOR<TotalCarbohydrateUpdateWithoutCarbohydrateInput, TotalCarbohydrateUncheckedUpdateWithoutCarbohydrateInput>
  }

  export type SugarCarbohydrateUpdateOneWithoutCarbohydrateInput = {
    create?: XOR<SugarCarbohydrateCreateWithoutCarbohydrateInput, SugarCarbohydrateUncheckedCreateWithoutCarbohydrateInput>
    connectOrCreate?: SugarCarbohydrateCreateOrConnectWithoutCarbohydrateInput
    upsert?: SugarCarbohydrateUpsertWithoutCarbohydrateInput
    disconnect?: boolean
    delete?: boolean
    connect?: SugarCarbohydrateWhereUniqueInput
    update?: XOR<SugarCarbohydrateUpdateWithoutCarbohydrateInput, SugarCarbohydrateUncheckedUpdateWithoutCarbohydrateInput>
  }

  export type NutritionFactUpdateManyWithoutCarbohydrateInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutCarbohydrateInput>, Enumerable<NutritionFactUncheckedCreateWithoutCarbohydrateInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutCarbohydrateInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutCarbohydrateInput>
    createMany?: NutritionFactCreateManyCarbohydrateInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutCarbohydrateInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutCarbohydrateInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type NutritionFactUncheckedUpdateManyWithoutCarbohydrateInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutCarbohydrateInput>, Enumerable<NutritionFactUncheckedCreateWithoutCarbohydrateInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutCarbohydrateInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutCarbohydrateInput>
    createMany?: NutritionFactCreateManyCarbohydrateInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutCarbohydrateInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutCarbohydrateInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type MeasurementCreateNestedOneWithoutTotalCarbohydrateInput = {
    create?: XOR<MeasurementCreateWithoutTotalCarbohydrateInput, MeasurementUncheckedCreateWithoutTotalCarbohydrateInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutTotalCarbohydrateInput
    connect?: MeasurementWhereUniqueInput
  }

  export type CarbohydrateCreateNestedOneWithoutTotalInput = {
    create?: XOR<CarbohydrateCreateWithoutTotalInput, CarbohydrateUncheckedCreateWithoutTotalInput>
    connectOrCreate?: CarbohydrateCreateOrConnectWithoutTotalInput
    connect?: CarbohydrateWhereUniqueInput
  }

  export type CarbohydrateUncheckedCreateNestedOneWithoutTotalInput = {
    create?: XOR<CarbohydrateCreateWithoutTotalInput, CarbohydrateUncheckedCreateWithoutTotalInput>
    connectOrCreate?: CarbohydrateCreateOrConnectWithoutTotalInput
    connect?: CarbohydrateWhereUniqueInput
  }

  export type MeasurementUpdateOneRequiredWithoutTotalCarbohydrateInput = {
    create?: XOR<MeasurementCreateWithoutTotalCarbohydrateInput, MeasurementUncheckedCreateWithoutTotalCarbohydrateInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutTotalCarbohydrateInput
    upsert?: MeasurementUpsertWithoutTotalCarbohydrateInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutTotalCarbohydrateInput, MeasurementUncheckedUpdateWithoutTotalCarbohydrateInput>
  }

  export type CarbohydrateUpdateOneWithoutTotalInput = {
    create?: XOR<CarbohydrateCreateWithoutTotalInput, CarbohydrateUncheckedCreateWithoutTotalInput>
    connectOrCreate?: CarbohydrateCreateOrConnectWithoutTotalInput
    upsert?: CarbohydrateUpsertWithoutTotalInput
    disconnect?: boolean
    delete?: boolean
    connect?: CarbohydrateWhereUniqueInput
    update?: XOR<CarbohydrateUpdateWithoutTotalInput, CarbohydrateUncheckedUpdateWithoutTotalInput>
  }

  export type CarbohydrateUncheckedUpdateOneWithoutTotalInput = {
    create?: XOR<CarbohydrateCreateWithoutTotalInput, CarbohydrateUncheckedCreateWithoutTotalInput>
    connectOrCreate?: CarbohydrateCreateOrConnectWithoutTotalInput
    upsert?: CarbohydrateUpsertWithoutTotalInput
    disconnect?: boolean
    delete?: boolean
    connect?: CarbohydrateWhereUniqueInput
    update?: XOR<CarbohydrateUpdateWithoutTotalInput, CarbohydrateUncheckedUpdateWithoutTotalInput>
  }

  export type MeasurementCreateNestedOneWithoutSugarCarbohydrateInput = {
    create?: XOR<MeasurementCreateWithoutSugarCarbohydrateInput, MeasurementUncheckedCreateWithoutSugarCarbohydrateInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutSugarCarbohydrateInput
    connect?: MeasurementWhereUniqueInput
  }

  export type CarbohydrateCreateNestedOneWithoutSugarInput = {
    create?: XOR<CarbohydrateCreateWithoutSugarInput, CarbohydrateUncheckedCreateWithoutSugarInput>
    connectOrCreate?: CarbohydrateCreateOrConnectWithoutSugarInput
    connect?: CarbohydrateWhereUniqueInput
  }

  export type CarbohydrateUncheckedCreateNestedOneWithoutSugarInput = {
    create?: XOR<CarbohydrateCreateWithoutSugarInput, CarbohydrateUncheckedCreateWithoutSugarInput>
    connectOrCreate?: CarbohydrateCreateOrConnectWithoutSugarInput
    connect?: CarbohydrateWhereUniqueInput
  }

  export type MeasurementUpdateOneRequiredWithoutSugarCarbohydrateInput = {
    create?: XOR<MeasurementCreateWithoutSugarCarbohydrateInput, MeasurementUncheckedCreateWithoutSugarCarbohydrateInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutSugarCarbohydrateInput
    upsert?: MeasurementUpsertWithoutSugarCarbohydrateInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutSugarCarbohydrateInput, MeasurementUncheckedUpdateWithoutSugarCarbohydrateInput>
  }

  export type CarbohydrateUpdateOneWithoutSugarInput = {
    create?: XOR<CarbohydrateCreateWithoutSugarInput, CarbohydrateUncheckedCreateWithoutSugarInput>
    connectOrCreate?: CarbohydrateCreateOrConnectWithoutSugarInput
    upsert?: CarbohydrateUpsertWithoutSugarInput
    disconnect?: boolean
    delete?: boolean
    connect?: CarbohydrateWhereUniqueInput
    update?: XOR<CarbohydrateUpdateWithoutSugarInput, CarbohydrateUncheckedUpdateWithoutSugarInput>
  }

  export type CarbohydrateUncheckedUpdateOneWithoutSugarInput = {
    create?: XOR<CarbohydrateCreateWithoutSugarInput, CarbohydrateUncheckedCreateWithoutSugarInput>
    connectOrCreate?: CarbohydrateCreateOrConnectWithoutSugarInput
    upsert?: CarbohydrateUpsertWithoutSugarInput
    disconnect?: boolean
    delete?: boolean
    connect?: CarbohydrateWhereUniqueInput
    update?: XOR<CarbohydrateUpdateWithoutSugarInput, CarbohydrateUncheckedUpdateWithoutSugarInput>
  }

  export type VitaminCCreateNestedOneWithoutVitaminInput = {
    create?: XOR<VitaminCCreateWithoutVitaminInput, VitaminCUncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminCCreateOrConnectWithoutVitaminInput
    connect?: VitaminCWhereUniqueInput
  }

  export type VitaminACreateNestedOneWithoutVitaminInput = {
    create?: XOR<VitaminACreateWithoutVitaminInput, VitaminAUncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminACreateOrConnectWithoutVitaminInput
    connect?: VitaminAWhereUniqueInput
  }

  export type VitaminDCreateNestedOneWithoutVitaminInput = {
    create?: XOR<VitaminDCreateWithoutVitaminInput, VitaminDUncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminDCreateOrConnectWithoutVitaminInput
    connect?: VitaminDWhereUniqueInput
  }

  export type VitaminECreateNestedOneWithoutVitaminInput = {
    create?: XOR<VitaminECreateWithoutVitaminInput, VitaminEUncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminECreateOrConnectWithoutVitaminInput
    connect?: VitaminEWhereUniqueInput
  }

  export type VitaminB1CreateNestedOneWithoutVitaminInput = {
    create?: XOR<VitaminB1CreateWithoutVitaminInput, VitaminB1UncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminB1CreateOrConnectWithoutVitaminInput
    connect?: VitaminB1WhereUniqueInput
  }

  export type VitaminB2CreateNestedOneWithoutVitaminInput = {
    create?: XOR<VitaminB2CreateWithoutVitaminInput, VitaminB2UncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminB2CreateOrConnectWithoutVitaminInput
    connect?: VitaminB2WhereUniqueInput
  }

  export type VitaminB6CreateNestedOneWithoutVitaminInput = {
    create?: XOR<VitaminB6CreateWithoutVitaminInput, VitaminB6UncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminB6CreateOrConnectWithoutVitaminInput
    connect?: VitaminB6WhereUniqueInput
  }

  export type VitaminB12CreateNestedOneWithoutVitaminInput = {
    create?: XOR<VitaminB12CreateWithoutVitaminInput, VitaminB12UncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminB12CreateOrConnectWithoutVitaminInput
    connect?: VitaminB12WhereUniqueInput
  }

  export type NutritionFactCreateNestedManyWithoutVitaminsInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutVitaminsInput>, Enumerable<NutritionFactUncheckedCreateWithoutVitaminsInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutVitaminsInput>
    createMany?: NutritionFactCreateManyVitaminsInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type MeasurementCreateNestedManyWithoutVitaminInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutVitaminInput>, Enumerable<MeasurementUncheckedCreateWithoutVitaminInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutVitaminInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
  }

  export type NutritionFactUncheckedCreateNestedManyWithoutVitaminsInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutVitaminsInput>, Enumerable<NutritionFactUncheckedCreateWithoutVitaminsInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutVitaminsInput>
    createMany?: NutritionFactCreateManyVitaminsInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type MeasurementUncheckedCreateNestedManyWithoutVitaminInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutVitaminInput>, Enumerable<MeasurementUncheckedCreateWithoutVitaminInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutVitaminInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
  }

  export type VitaminCUpdateOneWithoutVitaminInput = {
    create?: XOR<VitaminCCreateWithoutVitaminInput, VitaminCUncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminCCreateOrConnectWithoutVitaminInput
    upsert?: VitaminCUpsertWithoutVitaminInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminCWhereUniqueInput
    update?: XOR<VitaminCUpdateWithoutVitaminInput, VitaminCUncheckedUpdateWithoutVitaminInput>
  }

  export type VitaminAUpdateOneWithoutVitaminInput = {
    create?: XOR<VitaminACreateWithoutVitaminInput, VitaminAUncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminACreateOrConnectWithoutVitaminInput
    upsert?: VitaminAUpsertWithoutVitaminInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminAWhereUniqueInput
    update?: XOR<VitaminAUpdateWithoutVitaminInput, VitaminAUncheckedUpdateWithoutVitaminInput>
  }

  export type VitaminDUpdateOneWithoutVitaminInput = {
    create?: XOR<VitaminDCreateWithoutVitaminInput, VitaminDUncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminDCreateOrConnectWithoutVitaminInput
    upsert?: VitaminDUpsertWithoutVitaminInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminDWhereUniqueInput
    update?: XOR<VitaminDUpdateWithoutVitaminInput, VitaminDUncheckedUpdateWithoutVitaminInput>
  }

  export type VitaminEUpdateOneWithoutVitaminInput = {
    create?: XOR<VitaminECreateWithoutVitaminInput, VitaminEUncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminECreateOrConnectWithoutVitaminInput
    upsert?: VitaminEUpsertWithoutVitaminInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminEWhereUniqueInput
    update?: XOR<VitaminEUpdateWithoutVitaminInput, VitaminEUncheckedUpdateWithoutVitaminInput>
  }

  export type VitaminB1UpdateOneWithoutVitaminInput = {
    create?: XOR<VitaminB1CreateWithoutVitaminInput, VitaminB1UncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminB1CreateOrConnectWithoutVitaminInput
    upsert?: VitaminB1UpsertWithoutVitaminInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminB1WhereUniqueInput
    update?: XOR<VitaminB1UpdateWithoutVitaminInput, VitaminB1UncheckedUpdateWithoutVitaminInput>
  }

  export type VitaminB2UpdateOneWithoutVitaminInput = {
    create?: XOR<VitaminB2CreateWithoutVitaminInput, VitaminB2UncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminB2CreateOrConnectWithoutVitaminInput
    upsert?: VitaminB2UpsertWithoutVitaminInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminB2WhereUniqueInput
    update?: XOR<VitaminB2UpdateWithoutVitaminInput, VitaminB2UncheckedUpdateWithoutVitaminInput>
  }

  export type VitaminB6UpdateOneWithoutVitaminInput = {
    create?: XOR<VitaminB6CreateWithoutVitaminInput, VitaminB6UncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminB6CreateOrConnectWithoutVitaminInput
    upsert?: VitaminB6UpsertWithoutVitaminInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminB6WhereUniqueInput
    update?: XOR<VitaminB6UpdateWithoutVitaminInput, VitaminB6UncheckedUpdateWithoutVitaminInput>
  }

  export type VitaminB12UpdateOneWithoutVitaminInput = {
    create?: XOR<VitaminB12CreateWithoutVitaminInput, VitaminB12UncheckedCreateWithoutVitaminInput>
    connectOrCreate?: VitaminB12CreateOrConnectWithoutVitaminInput
    upsert?: VitaminB12UpsertWithoutVitaminInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminB12WhereUniqueInput
    update?: XOR<VitaminB12UpdateWithoutVitaminInput, VitaminB12UncheckedUpdateWithoutVitaminInput>
  }

  export type NutritionFactUpdateManyWithoutVitaminsInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutVitaminsInput>, Enumerable<NutritionFactUncheckedCreateWithoutVitaminsInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutVitaminsInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutVitaminsInput>
    createMany?: NutritionFactCreateManyVitaminsInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutVitaminsInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutVitaminsInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type MeasurementUpdateManyWithoutVitaminInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutVitaminInput>, Enumerable<MeasurementUncheckedCreateWithoutVitaminInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutVitaminInput>
    upsert?: Enumerable<MeasurementUpsertWithWhereUniqueWithoutVitaminInput>
    set?: Enumerable<MeasurementWhereUniqueInput>
    disconnect?: Enumerable<MeasurementWhereUniqueInput>
    delete?: Enumerable<MeasurementWhereUniqueInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
    update?: Enumerable<MeasurementUpdateWithWhereUniqueWithoutVitaminInput>
    updateMany?: Enumerable<MeasurementUpdateManyWithWhereWithoutVitaminInput>
    deleteMany?: Enumerable<MeasurementScalarWhereInput>
  }

  export type NutritionFactUncheckedUpdateManyWithoutVitaminsInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutVitaminsInput>, Enumerable<NutritionFactUncheckedCreateWithoutVitaminsInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutVitaminsInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutVitaminsInput>
    createMany?: NutritionFactCreateManyVitaminsInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutVitaminsInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutVitaminsInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type MeasurementUncheckedUpdateManyWithoutVitaminInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutVitaminInput>, Enumerable<MeasurementUncheckedCreateWithoutVitaminInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutVitaminInput>
    upsert?: Enumerable<MeasurementUpsertWithWhereUniqueWithoutVitaminInput>
    set?: Enumerable<MeasurementWhereUniqueInput>
    disconnect?: Enumerable<MeasurementWhereUniqueInput>
    delete?: Enumerable<MeasurementWhereUniqueInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
    update?: Enumerable<MeasurementUpdateWithWhereUniqueWithoutVitaminInput>
    updateMany?: Enumerable<MeasurementUpdateManyWithWhereWithoutVitaminInput>
    deleteMany?: Enumerable<MeasurementScalarWhereInput>
  }

  export type MeasurementCreateNestedOneWithoutVitaminCInput = {
    create?: XOR<MeasurementCreateWithoutVitaminCInput, MeasurementUncheckedCreateWithoutVitaminCInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminCInput
    connect?: MeasurementWhereUniqueInput
  }

  export type VitaminCreateNestedOneWithoutCInput = {
    create?: XOR<VitaminCreateWithoutCInput, VitaminUncheckedCreateWithoutCInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutCInput
    connect?: VitaminWhereUniqueInput
  }

  export type VitaminUncheckedCreateNestedOneWithoutCInput = {
    create?: XOR<VitaminCreateWithoutCInput, VitaminUncheckedCreateWithoutCInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutCInput
    connect?: VitaminWhereUniqueInput
  }

  export type MeasurementUpdateOneRequiredWithoutVitaminCInput = {
    create?: XOR<MeasurementCreateWithoutVitaminCInput, MeasurementUncheckedCreateWithoutVitaminCInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminCInput
    upsert?: MeasurementUpsertWithoutVitaminCInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutVitaminCInput, MeasurementUncheckedUpdateWithoutVitaminCInput>
  }

  export type VitaminUpdateOneWithoutCInput = {
    create?: XOR<VitaminCreateWithoutCInput, VitaminUncheckedCreateWithoutCInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutCInput
    upsert?: VitaminUpsertWithoutCInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutCInput, VitaminUncheckedUpdateWithoutCInput>
  }

  export type VitaminUncheckedUpdateOneWithoutCInput = {
    create?: XOR<VitaminCreateWithoutCInput, VitaminUncheckedCreateWithoutCInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutCInput
    upsert?: VitaminUpsertWithoutCInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutCInput, VitaminUncheckedUpdateWithoutCInput>
  }

  export type MeasurementCreateNestedOneWithoutVitaminAInput = {
    create?: XOR<MeasurementCreateWithoutVitaminAInput, MeasurementUncheckedCreateWithoutVitaminAInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminAInput
    connect?: MeasurementWhereUniqueInput
  }

  export type VitaminCreateNestedOneWithoutAInput = {
    create?: XOR<VitaminCreateWithoutAInput, VitaminUncheckedCreateWithoutAInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutAInput
    connect?: VitaminWhereUniqueInput
  }

  export type VitaminUncheckedCreateNestedOneWithoutAInput = {
    create?: XOR<VitaminCreateWithoutAInput, VitaminUncheckedCreateWithoutAInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutAInput
    connect?: VitaminWhereUniqueInput
  }

  export type MeasurementUpdateOneRequiredWithoutVitaminAInput = {
    create?: XOR<MeasurementCreateWithoutVitaminAInput, MeasurementUncheckedCreateWithoutVitaminAInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminAInput
    upsert?: MeasurementUpsertWithoutVitaminAInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutVitaminAInput, MeasurementUncheckedUpdateWithoutVitaminAInput>
  }

  export type VitaminUpdateOneWithoutAInput = {
    create?: XOR<VitaminCreateWithoutAInput, VitaminUncheckedCreateWithoutAInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutAInput
    upsert?: VitaminUpsertWithoutAInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutAInput, VitaminUncheckedUpdateWithoutAInput>
  }

  export type VitaminUncheckedUpdateOneWithoutAInput = {
    create?: XOR<VitaminCreateWithoutAInput, VitaminUncheckedCreateWithoutAInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutAInput
    upsert?: VitaminUpsertWithoutAInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutAInput, VitaminUncheckedUpdateWithoutAInput>
  }

  export type MeasurementCreateNestedOneWithoutVitaminDInput = {
    create?: XOR<MeasurementCreateWithoutVitaminDInput, MeasurementUncheckedCreateWithoutVitaminDInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminDInput
    connect?: MeasurementWhereUniqueInput
  }

  export type VitaminCreateNestedOneWithoutDInput = {
    create?: XOR<VitaminCreateWithoutDInput, VitaminUncheckedCreateWithoutDInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutDInput
    connect?: VitaminWhereUniqueInput
  }

  export type VitaminUncheckedCreateNestedOneWithoutDInput = {
    create?: XOR<VitaminCreateWithoutDInput, VitaminUncheckedCreateWithoutDInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutDInput
    connect?: VitaminWhereUniqueInput
  }

  export type MeasurementUpdateOneRequiredWithoutVitaminDInput = {
    create?: XOR<MeasurementCreateWithoutVitaminDInput, MeasurementUncheckedCreateWithoutVitaminDInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminDInput
    upsert?: MeasurementUpsertWithoutVitaminDInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutVitaminDInput, MeasurementUncheckedUpdateWithoutVitaminDInput>
  }

  export type VitaminUpdateOneWithoutDInput = {
    create?: XOR<VitaminCreateWithoutDInput, VitaminUncheckedCreateWithoutDInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutDInput
    upsert?: VitaminUpsertWithoutDInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutDInput, VitaminUncheckedUpdateWithoutDInput>
  }

  export type VitaminUncheckedUpdateOneWithoutDInput = {
    create?: XOR<VitaminCreateWithoutDInput, VitaminUncheckedCreateWithoutDInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutDInput
    upsert?: VitaminUpsertWithoutDInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutDInput, VitaminUncheckedUpdateWithoutDInput>
  }

  export type MeasurementCreateNestedOneWithoutVitaminEInput = {
    create?: XOR<MeasurementCreateWithoutVitaminEInput, MeasurementUncheckedCreateWithoutVitaminEInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminEInput
    connect?: MeasurementWhereUniqueInput
  }

  export type VitaminCreateNestedOneWithoutEInput = {
    create?: XOR<VitaminCreateWithoutEInput, VitaminUncheckedCreateWithoutEInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutEInput
    connect?: VitaminWhereUniqueInput
  }

  export type VitaminUncheckedCreateNestedOneWithoutEInput = {
    create?: XOR<VitaminCreateWithoutEInput, VitaminUncheckedCreateWithoutEInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutEInput
    connect?: VitaminWhereUniqueInput
  }

  export type MeasurementUpdateOneRequiredWithoutVitaminEInput = {
    create?: XOR<MeasurementCreateWithoutVitaminEInput, MeasurementUncheckedCreateWithoutVitaminEInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminEInput
    upsert?: MeasurementUpsertWithoutVitaminEInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutVitaminEInput, MeasurementUncheckedUpdateWithoutVitaminEInput>
  }

  export type VitaminUpdateOneWithoutEInput = {
    create?: XOR<VitaminCreateWithoutEInput, VitaminUncheckedCreateWithoutEInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutEInput
    upsert?: VitaminUpsertWithoutEInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutEInput, VitaminUncheckedUpdateWithoutEInput>
  }

  export type VitaminUncheckedUpdateOneWithoutEInput = {
    create?: XOR<VitaminCreateWithoutEInput, VitaminUncheckedCreateWithoutEInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutEInput
    upsert?: VitaminUpsertWithoutEInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutEInput, VitaminUncheckedUpdateWithoutEInput>
  }

  export type MeasurementCreateNestedOneWithoutVitaminB1Input = {
    create?: XOR<MeasurementCreateWithoutVitaminB1Input, MeasurementUncheckedCreateWithoutVitaminB1Input>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminB1Input
    connect?: MeasurementWhereUniqueInput
  }

  export type VitaminCreateNestedOneWithoutB1Input = {
    create?: XOR<VitaminCreateWithoutB1Input, VitaminUncheckedCreateWithoutB1Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB1Input
    connect?: VitaminWhereUniqueInput
  }

  export type VitaminUncheckedCreateNestedOneWithoutB1Input = {
    create?: XOR<VitaminCreateWithoutB1Input, VitaminUncheckedCreateWithoutB1Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB1Input
    connect?: VitaminWhereUniqueInput
  }

  export type MeasurementUpdateOneRequiredWithoutVitaminB1Input = {
    create?: XOR<MeasurementCreateWithoutVitaminB1Input, MeasurementUncheckedCreateWithoutVitaminB1Input>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminB1Input
    upsert?: MeasurementUpsertWithoutVitaminB1Input
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutVitaminB1Input, MeasurementUncheckedUpdateWithoutVitaminB1Input>
  }

  export type VitaminUpdateOneWithoutB1Input = {
    create?: XOR<VitaminCreateWithoutB1Input, VitaminUncheckedCreateWithoutB1Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB1Input
    upsert?: VitaminUpsertWithoutB1Input
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutB1Input, VitaminUncheckedUpdateWithoutB1Input>
  }

  export type VitaminUncheckedUpdateOneWithoutB1Input = {
    create?: XOR<VitaminCreateWithoutB1Input, VitaminUncheckedCreateWithoutB1Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB1Input
    upsert?: VitaminUpsertWithoutB1Input
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutB1Input, VitaminUncheckedUpdateWithoutB1Input>
  }

  export type MeasurementCreateNestedOneWithoutVitaminB2Input = {
    create?: XOR<MeasurementCreateWithoutVitaminB2Input, MeasurementUncheckedCreateWithoutVitaminB2Input>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminB2Input
    connect?: MeasurementWhereUniqueInput
  }

  export type VitaminCreateNestedOneWithoutB2Input = {
    create?: XOR<VitaminCreateWithoutB2Input, VitaminUncheckedCreateWithoutB2Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB2Input
    connect?: VitaminWhereUniqueInput
  }

  export type VitaminUncheckedCreateNestedOneWithoutB2Input = {
    create?: XOR<VitaminCreateWithoutB2Input, VitaminUncheckedCreateWithoutB2Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB2Input
    connect?: VitaminWhereUniqueInput
  }

  export type MeasurementUpdateOneRequiredWithoutVitaminB2Input = {
    create?: XOR<MeasurementCreateWithoutVitaminB2Input, MeasurementUncheckedCreateWithoutVitaminB2Input>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminB2Input
    upsert?: MeasurementUpsertWithoutVitaminB2Input
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutVitaminB2Input, MeasurementUncheckedUpdateWithoutVitaminB2Input>
  }

  export type VitaminUpdateOneWithoutB2Input = {
    create?: XOR<VitaminCreateWithoutB2Input, VitaminUncheckedCreateWithoutB2Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB2Input
    upsert?: VitaminUpsertWithoutB2Input
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutB2Input, VitaminUncheckedUpdateWithoutB2Input>
  }

  export type VitaminUncheckedUpdateOneWithoutB2Input = {
    create?: XOR<VitaminCreateWithoutB2Input, VitaminUncheckedCreateWithoutB2Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB2Input
    upsert?: VitaminUpsertWithoutB2Input
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutB2Input, VitaminUncheckedUpdateWithoutB2Input>
  }

  export type MeasurementCreateNestedOneWithoutVitaminB6Input = {
    create?: XOR<MeasurementCreateWithoutVitaminB6Input, MeasurementUncheckedCreateWithoutVitaminB6Input>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminB6Input
    connect?: MeasurementWhereUniqueInput
  }

  export type VitaminCreateNestedOneWithoutB6Input = {
    create?: XOR<VitaminCreateWithoutB6Input, VitaminUncheckedCreateWithoutB6Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB6Input
    connect?: VitaminWhereUniqueInput
  }

  export type VitaminUncheckedCreateNestedOneWithoutB6Input = {
    create?: XOR<VitaminCreateWithoutB6Input, VitaminUncheckedCreateWithoutB6Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB6Input
    connect?: VitaminWhereUniqueInput
  }

  export type MeasurementUpdateOneRequiredWithoutVitaminB6Input = {
    create?: XOR<MeasurementCreateWithoutVitaminB6Input, MeasurementUncheckedCreateWithoutVitaminB6Input>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminB6Input
    upsert?: MeasurementUpsertWithoutVitaminB6Input
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutVitaminB6Input, MeasurementUncheckedUpdateWithoutVitaminB6Input>
  }

  export type VitaminUpdateOneWithoutB6Input = {
    create?: XOR<VitaminCreateWithoutB6Input, VitaminUncheckedCreateWithoutB6Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB6Input
    upsert?: VitaminUpsertWithoutB6Input
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutB6Input, VitaminUncheckedUpdateWithoutB6Input>
  }

  export type VitaminUncheckedUpdateOneWithoutB6Input = {
    create?: XOR<VitaminCreateWithoutB6Input, VitaminUncheckedCreateWithoutB6Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB6Input
    upsert?: VitaminUpsertWithoutB6Input
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutB6Input, VitaminUncheckedUpdateWithoutB6Input>
  }

  export type MeasurementCreateNestedOneWithoutVitaminB12Input = {
    create?: XOR<MeasurementCreateWithoutVitaminB12Input, MeasurementUncheckedCreateWithoutVitaminB12Input>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminB12Input
    connect?: MeasurementWhereUniqueInput
  }

  export type VitaminCreateNestedOneWithoutB12Input = {
    create?: XOR<VitaminCreateWithoutB12Input, VitaminUncheckedCreateWithoutB12Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB12Input
    connect?: VitaminWhereUniqueInput
  }

  export type VitaminUncheckedCreateNestedOneWithoutB12Input = {
    create?: XOR<VitaminCreateWithoutB12Input, VitaminUncheckedCreateWithoutB12Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB12Input
    connect?: VitaminWhereUniqueInput
  }

  export type MeasurementUpdateOneRequiredWithoutVitaminB12Input = {
    create?: XOR<MeasurementCreateWithoutVitaminB12Input, MeasurementUncheckedCreateWithoutVitaminB12Input>
    connectOrCreate?: MeasurementCreateOrConnectWithoutVitaminB12Input
    upsert?: MeasurementUpsertWithoutVitaminB12Input
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutVitaminB12Input, MeasurementUncheckedUpdateWithoutVitaminB12Input>
  }

  export type VitaminUpdateOneWithoutB12Input = {
    create?: XOR<VitaminCreateWithoutB12Input, VitaminUncheckedCreateWithoutB12Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB12Input
    upsert?: VitaminUpsertWithoutB12Input
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutB12Input, VitaminUncheckedUpdateWithoutB12Input>
  }

  export type VitaminUncheckedUpdateOneWithoutB12Input = {
    create?: XOR<VitaminCreateWithoutB12Input, VitaminUncheckedCreateWithoutB12Input>
    connectOrCreate?: VitaminCreateOrConnectWithoutB12Input
    upsert?: VitaminUpsertWithoutB12Input
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutB12Input, VitaminUncheckedUpdateWithoutB12Input>
  }

  export type MineralCreateNestedManyWithoutSaltInput = {
    create?: XOR<Enumerable<MineralCreateWithoutSaltInput>, Enumerable<MineralUncheckedCreateWithoutSaltInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutSaltInput>
    createMany?: MineralCreateManySaltInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MeasurementCreateNestedOneWithoutSaltInput = {
    create?: XOR<MeasurementCreateWithoutSaltInput, MeasurementUncheckedCreateWithoutSaltInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutSaltInput
    connect?: MeasurementWhereUniqueInput
  }

  export type MineralUncheckedCreateNestedManyWithoutSaltInput = {
    create?: XOR<Enumerable<MineralCreateWithoutSaltInput>, Enumerable<MineralUncheckedCreateWithoutSaltInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutSaltInput>
    createMany?: MineralCreateManySaltInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MineralUpdateManyWithoutSaltInput = {
    create?: XOR<Enumerable<MineralCreateWithoutSaltInput>, Enumerable<MineralUncheckedCreateWithoutSaltInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutSaltInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutSaltInput>
    createMany?: MineralCreateManySaltInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutSaltInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutSaltInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MeasurementUpdateOneRequiredWithoutSaltInput = {
    create?: XOR<MeasurementCreateWithoutSaltInput, MeasurementUncheckedCreateWithoutSaltInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutSaltInput
    upsert?: MeasurementUpsertWithoutSaltInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutSaltInput, MeasurementUncheckedUpdateWithoutSaltInput>
  }

  export type MineralUncheckedUpdateManyWithoutSaltInput = {
    create?: XOR<Enumerable<MineralCreateWithoutSaltInput>, Enumerable<MineralUncheckedCreateWithoutSaltInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutSaltInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutSaltInput>
    createMany?: MineralCreateManySaltInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutSaltInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutSaltInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MineralCreateNestedManyWithoutZincInput = {
    create?: XOR<Enumerable<MineralCreateWithoutZincInput>, Enumerable<MineralUncheckedCreateWithoutZincInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutZincInput>
    createMany?: MineralCreateManyZincInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MeasurementCreateNestedOneWithoutZincInput = {
    create?: XOR<MeasurementCreateWithoutZincInput, MeasurementUncheckedCreateWithoutZincInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutZincInput
    connect?: MeasurementWhereUniqueInput
  }

  export type MineralUncheckedCreateNestedManyWithoutZincInput = {
    create?: XOR<Enumerable<MineralCreateWithoutZincInput>, Enumerable<MineralUncheckedCreateWithoutZincInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutZincInput>
    createMany?: MineralCreateManyZincInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MineralUpdateManyWithoutZincInput = {
    create?: XOR<Enumerable<MineralCreateWithoutZincInput>, Enumerable<MineralUncheckedCreateWithoutZincInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutZincInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutZincInput>
    createMany?: MineralCreateManyZincInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutZincInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutZincInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MeasurementUpdateOneRequiredWithoutZincInput = {
    create?: XOR<MeasurementCreateWithoutZincInput, MeasurementUncheckedCreateWithoutZincInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutZincInput
    upsert?: MeasurementUpsertWithoutZincInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutZincInput, MeasurementUncheckedUpdateWithoutZincInput>
  }

  export type MineralUncheckedUpdateManyWithoutZincInput = {
    create?: XOR<Enumerable<MineralCreateWithoutZincInput>, Enumerable<MineralUncheckedCreateWithoutZincInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutZincInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutZincInput>
    createMany?: MineralCreateManyZincInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutZincInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutZincInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MineralCreateNestedManyWithoutIronInput = {
    create?: XOR<Enumerable<MineralCreateWithoutIronInput>, Enumerable<MineralUncheckedCreateWithoutIronInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutIronInput>
    createMany?: MineralCreateManyIronInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MeasurementCreateNestedOneWithoutIronInput = {
    create?: XOR<MeasurementCreateWithoutIronInput, MeasurementUncheckedCreateWithoutIronInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutIronInput
    connect?: MeasurementWhereUniqueInput
  }

  export type MineralUncheckedCreateNestedManyWithoutIronInput = {
    create?: XOR<Enumerable<MineralCreateWithoutIronInput>, Enumerable<MineralUncheckedCreateWithoutIronInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutIronInput>
    createMany?: MineralCreateManyIronInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MineralUpdateManyWithoutIronInput = {
    create?: XOR<Enumerable<MineralCreateWithoutIronInput>, Enumerable<MineralUncheckedCreateWithoutIronInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutIronInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutIronInput>
    createMany?: MineralCreateManyIronInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutIronInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutIronInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MeasurementUpdateOneRequiredWithoutIronInput = {
    create?: XOR<MeasurementCreateWithoutIronInput, MeasurementUncheckedCreateWithoutIronInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutIronInput
    upsert?: MeasurementUpsertWithoutIronInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutIronInput, MeasurementUncheckedUpdateWithoutIronInput>
  }

  export type MineralUncheckedUpdateManyWithoutIronInput = {
    create?: XOR<Enumerable<MineralCreateWithoutIronInput>, Enumerable<MineralUncheckedCreateWithoutIronInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutIronInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutIronInput>
    createMany?: MineralCreateManyIronInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutIronInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutIronInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MineralCreateNestedManyWithoutMagnesiumInput = {
    create?: XOR<Enumerable<MineralCreateWithoutMagnesiumInput>, Enumerable<MineralUncheckedCreateWithoutMagnesiumInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutMagnesiumInput>
    createMany?: MineralCreateManyMagnesiumInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MeasurementCreateNestedOneWithoutMagnesiumInput = {
    create?: XOR<MeasurementCreateWithoutMagnesiumInput, MeasurementUncheckedCreateWithoutMagnesiumInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutMagnesiumInput
    connect?: MeasurementWhereUniqueInput
  }

  export type MineralUncheckedCreateNestedManyWithoutMagnesiumInput = {
    create?: XOR<Enumerable<MineralCreateWithoutMagnesiumInput>, Enumerable<MineralUncheckedCreateWithoutMagnesiumInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutMagnesiumInput>
    createMany?: MineralCreateManyMagnesiumInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MineralUpdateManyWithoutMagnesiumInput = {
    create?: XOR<Enumerable<MineralCreateWithoutMagnesiumInput>, Enumerable<MineralUncheckedCreateWithoutMagnesiumInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutMagnesiumInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutMagnesiumInput>
    createMany?: MineralCreateManyMagnesiumInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutMagnesiumInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutMagnesiumInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MeasurementUpdateOneRequiredWithoutMagnesiumInput = {
    create?: XOR<MeasurementCreateWithoutMagnesiumInput, MeasurementUncheckedCreateWithoutMagnesiumInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutMagnesiumInput
    upsert?: MeasurementUpsertWithoutMagnesiumInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutMagnesiumInput, MeasurementUncheckedUpdateWithoutMagnesiumInput>
  }

  export type MineralUncheckedUpdateManyWithoutMagnesiumInput = {
    create?: XOR<Enumerable<MineralCreateWithoutMagnesiumInput>, Enumerable<MineralUncheckedCreateWithoutMagnesiumInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutMagnesiumInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutMagnesiumInput>
    createMany?: MineralCreateManyMagnesiumInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutMagnesiumInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutMagnesiumInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MineralCreateNestedManyWithoutChlorideInput = {
    create?: XOR<Enumerable<MineralCreateWithoutChlorideInput>, Enumerable<MineralUncheckedCreateWithoutChlorideInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutChlorideInput>
    createMany?: MineralCreateManyChlorideInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MeasurementCreateNestedOneWithoutChlorideInput = {
    create?: XOR<MeasurementCreateWithoutChlorideInput, MeasurementUncheckedCreateWithoutChlorideInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutChlorideInput
    connect?: MeasurementWhereUniqueInput
  }

  export type MineralUncheckedCreateNestedManyWithoutChlorideInput = {
    create?: XOR<Enumerable<MineralCreateWithoutChlorideInput>, Enumerable<MineralUncheckedCreateWithoutChlorideInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutChlorideInput>
    createMany?: MineralCreateManyChlorideInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MineralUpdateManyWithoutChlorideInput = {
    create?: XOR<Enumerable<MineralCreateWithoutChlorideInput>, Enumerable<MineralUncheckedCreateWithoutChlorideInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutChlorideInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutChlorideInput>
    createMany?: MineralCreateManyChlorideInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutChlorideInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutChlorideInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MeasurementUpdateOneRequiredWithoutChlorideInput = {
    create?: XOR<MeasurementCreateWithoutChlorideInput, MeasurementUncheckedCreateWithoutChlorideInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutChlorideInput
    upsert?: MeasurementUpsertWithoutChlorideInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutChlorideInput, MeasurementUncheckedUpdateWithoutChlorideInput>
  }

  export type MineralUncheckedUpdateManyWithoutChlorideInput = {
    create?: XOR<Enumerable<MineralCreateWithoutChlorideInput>, Enumerable<MineralUncheckedCreateWithoutChlorideInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutChlorideInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutChlorideInput>
    createMany?: MineralCreateManyChlorideInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutChlorideInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutChlorideInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MineralCreateNestedManyWithoutManganeseInput = {
    create?: XOR<Enumerable<MineralCreateWithoutManganeseInput>, Enumerable<MineralUncheckedCreateWithoutManganeseInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutManganeseInput>
    createMany?: MineralCreateManyManganeseInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MeasurementCreateNestedOneWithoutManganeseInput = {
    create?: XOR<MeasurementCreateWithoutManganeseInput, MeasurementUncheckedCreateWithoutManganeseInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutManganeseInput
    connect?: MeasurementWhereUniqueInput
  }

  export type MineralUncheckedCreateNestedManyWithoutManganeseInput = {
    create?: XOR<Enumerable<MineralCreateWithoutManganeseInput>, Enumerable<MineralUncheckedCreateWithoutManganeseInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutManganeseInput>
    createMany?: MineralCreateManyManganeseInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MineralUpdateManyWithoutManganeseInput = {
    create?: XOR<Enumerable<MineralCreateWithoutManganeseInput>, Enumerable<MineralUncheckedCreateWithoutManganeseInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutManganeseInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutManganeseInput>
    createMany?: MineralCreateManyManganeseInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutManganeseInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutManganeseInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MeasurementUpdateOneRequiredWithoutManganeseInput = {
    create?: XOR<MeasurementCreateWithoutManganeseInput, MeasurementUncheckedCreateWithoutManganeseInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutManganeseInput
    upsert?: MeasurementUpsertWithoutManganeseInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutManganeseInput, MeasurementUncheckedUpdateWithoutManganeseInput>
  }

  export type MineralUncheckedUpdateManyWithoutManganeseInput = {
    create?: XOR<Enumerable<MineralCreateWithoutManganeseInput>, Enumerable<MineralUncheckedCreateWithoutManganeseInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutManganeseInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutManganeseInput>
    createMany?: MineralCreateManyManganeseInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutManganeseInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutManganeseInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MineralCreateNestedManyWithoutSulfurInput = {
    create?: XOR<Enumerable<MineralCreateWithoutSulfurInput>, Enumerable<MineralUncheckedCreateWithoutSulfurInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutSulfurInput>
    createMany?: MineralCreateManySulfurInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MeasurementCreateNestedOneWithoutSulfurInput = {
    create?: XOR<MeasurementCreateWithoutSulfurInput, MeasurementUncheckedCreateWithoutSulfurInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutSulfurInput
    connect?: MeasurementWhereUniqueInput
  }

  export type MineralUncheckedCreateNestedManyWithoutSulfurInput = {
    create?: XOR<Enumerable<MineralCreateWithoutSulfurInput>, Enumerable<MineralUncheckedCreateWithoutSulfurInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutSulfurInput>
    createMany?: MineralCreateManySulfurInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MineralUpdateManyWithoutSulfurInput = {
    create?: XOR<Enumerable<MineralCreateWithoutSulfurInput>, Enumerable<MineralUncheckedCreateWithoutSulfurInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutSulfurInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutSulfurInput>
    createMany?: MineralCreateManySulfurInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutSulfurInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutSulfurInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MeasurementUpdateOneRequiredWithoutSulfurInput = {
    create?: XOR<MeasurementCreateWithoutSulfurInput, MeasurementUncheckedCreateWithoutSulfurInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutSulfurInput
    upsert?: MeasurementUpsertWithoutSulfurInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutSulfurInput, MeasurementUncheckedUpdateWithoutSulfurInput>
  }

  export type MineralUncheckedUpdateManyWithoutSulfurInput = {
    create?: XOR<Enumerable<MineralCreateWithoutSulfurInput>, Enumerable<MineralUncheckedCreateWithoutSulfurInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutSulfurInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutSulfurInput>
    createMany?: MineralCreateManySulfurInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutSulfurInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutSulfurInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MineralCreateNestedManyWithoutPotassiumInput = {
    create?: XOR<Enumerable<MineralCreateWithoutPotassiumInput>, Enumerable<MineralUncheckedCreateWithoutPotassiumInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutPotassiumInput>
    createMany?: MineralCreateManyPotassiumInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MeasurementCreateNestedOneWithoutPotassiumInput = {
    create?: XOR<MeasurementCreateWithoutPotassiumInput, MeasurementUncheckedCreateWithoutPotassiumInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutPotassiumInput
    connect?: MeasurementWhereUniqueInput
  }

  export type MineralUncheckedCreateNestedManyWithoutPotassiumInput = {
    create?: XOR<Enumerable<MineralCreateWithoutPotassiumInput>, Enumerable<MineralUncheckedCreateWithoutPotassiumInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutPotassiumInput>
    createMany?: MineralCreateManyPotassiumInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MineralUpdateManyWithoutPotassiumInput = {
    create?: XOR<Enumerable<MineralCreateWithoutPotassiumInput>, Enumerable<MineralUncheckedCreateWithoutPotassiumInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutPotassiumInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutPotassiumInput>
    createMany?: MineralCreateManyPotassiumInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutPotassiumInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutPotassiumInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MeasurementUpdateOneRequiredWithoutPotassiumInput = {
    create?: XOR<MeasurementCreateWithoutPotassiumInput, MeasurementUncheckedCreateWithoutPotassiumInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutPotassiumInput
    upsert?: MeasurementUpsertWithoutPotassiumInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutPotassiumInput, MeasurementUncheckedUpdateWithoutPotassiumInput>
  }

  export type MineralUncheckedUpdateManyWithoutPotassiumInput = {
    create?: XOR<Enumerable<MineralCreateWithoutPotassiumInput>, Enumerable<MineralUncheckedCreateWithoutPotassiumInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutPotassiumInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutPotassiumInput>
    createMany?: MineralCreateManyPotassiumInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutPotassiumInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutPotassiumInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MineralCreateNestedManyWithoutFluorideInput = {
    create?: XOR<Enumerable<MineralCreateWithoutFluorideInput>, Enumerable<MineralUncheckedCreateWithoutFluorideInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutFluorideInput>
    createMany?: MineralCreateManyFluorideInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MeasurementCreateNestedOneWithoutFluorideInput = {
    create?: XOR<MeasurementCreateWithoutFluorideInput, MeasurementUncheckedCreateWithoutFluorideInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutFluorideInput
    connect?: MeasurementWhereUniqueInput
  }

  export type MineralUncheckedCreateNestedManyWithoutFluorideInput = {
    create?: XOR<Enumerable<MineralCreateWithoutFluorideInput>, Enumerable<MineralUncheckedCreateWithoutFluorideInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutFluorideInput>
    createMany?: MineralCreateManyFluorideInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MineralUpdateManyWithoutFluorideInput = {
    create?: XOR<Enumerable<MineralCreateWithoutFluorideInput>, Enumerable<MineralUncheckedCreateWithoutFluorideInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutFluorideInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutFluorideInput>
    createMany?: MineralCreateManyFluorideInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutFluorideInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutFluorideInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MeasurementUpdateOneRequiredWithoutFluorideInput = {
    create?: XOR<MeasurementCreateWithoutFluorideInput, MeasurementUncheckedCreateWithoutFluorideInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutFluorideInput
    upsert?: MeasurementUpsertWithoutFluorideInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutFluorideInput, MeasurementUncheckedUpdateWithoutFluorideInput>
  }

  export type MineralUncheckedUpdateManyWithoutFluorideInput = {
    create?: XOR<Enumerable<MineralCreateWithoutFluorideInput>, Enumerable<MineralUncheckedCreateWithoutFluorideInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutFluorideInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutFluorideInput>
    createMany?: MineralCreateManyFluorideInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutFluorideInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutFluorideInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MineralCreateNestedManyWithoutPhosphorousInput = {
    create?: XOR<Enumerable<MineralCreateWithoutPhosphorousInput>, Enumerable<MineralUncheckedCreateWithoutPhosphorousInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutPhosphorousInput>
    createMany?: MineralCreateManyPhosphorousInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MeasurementCreateNestedOneWithoutPhosphorousInput = {
    create?: XOR<MeasurementCreateWithoutPhosphorousInput, MeasurementUncheckedCreateWithoutPhosphorousInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutPhosphorousInput
    connect?: MeasurementWhereUniqueInput
  }

  export type MineralUncheckedCreateNestedManyWithoutPhosphorousInput = {
    create?: XOR<Enumerable<MineralCreateWithoutPhosphorousInput>, Enumerable<MineralUncheckedCreateWithoutPhosphorousInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutPhosphorousInput>
    createMany?: MineralCreateManyPhosphorousInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MineralUpdateManyWithoutPhosphorousInput = {
    create?: XOR<Enumerable<MineralCreateWithoutPhosphorousInput>, Enumerable<MineralUncheckedCreateWithoutPhosphorousInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutPhosphorousInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutPhosphorousInput>
    createMany?: MineralCreateManyPhosphorousInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutPhosphorousInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutPhosphorousInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MeasurementUpdateOneRequiredWithoutPhosphorousInput = {
    create?: XOR<MeasurementCreateWithoutPhosphorousInput, MeasurementUncheckedCreateWithoutPhosphorousInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutPhosphorousInput
    upsert?: MeasurementUpsertWithoutPhosphorousInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutPhosphorousInput, MeasurementUncheckedUpdateWithoutPhosphorousInput>
  }

  export type MineralUncheckedUpdateManyWithoutPhosphorousInput = {
    create?: XOR<Enumerable<MineralCreateWithoutPhosphorousInput>, Enumerable<MineralUncheckedCreateWithoutPhosphorousInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutPhosphorousInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutPhosphorousInput>
    createMany?: MineralCreateManyPhosphorousInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutPhosphorousInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutPhosphorousInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MineralCreateNestedManyWithoutCopperInput = {
    create?: XOR<Enumerable<MineralCreateWithoutCopperInput>, Enumerable<MineralUncheckedCreateWithoutCopperInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutCopperInput>
    createMany?: MineralCreateManyCopperInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MeasurementCreateNestedOneWithoutCopperInput = {
    create?: XOR<MeasurementCreateWithoutCopperInput, MeasurementUncheckedCreateWithoutCopperInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutCopperInput
    connect?: MeasurementWhereUniqueInput
  }

  export type MineralUncheckedCreateNestedManyWithoutCopperInput = {
    create?: XOR<Enumerable<MineralCreateWithoutCopperInput>, Enumerable<MineralUncheckedCreateWithoutCopperInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutCopperInput>
    createMany?: MineralCreateManyCopperInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MineralUpdateManyWithoutCopperInput = {
    create?: XOR<Enumerable<MineralCreateWithoutCopperInput>, Enumerable<MineralUncheckedCreateWithoutCopperInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutCopperInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutCopperInput>
    createMany?: MineralCreateManyCopperInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutCopperInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutCopperInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MeasurementUpdateOneRequiredWithoutCopperInput = {
    create?: XOR<MeasurementCreateWithoutCopperInput, MeasurementUncheckedCreateWithoutCopperInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutCopperInput
    upsert?: MeasurementUpsertWithoutCopperInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutCopperInput, MeasurementUncheckedUpdateWithoutCopperInput>
  }

  export type MineralUncheckedUpdateManyWithoutCopperInput = {
    create?: XOR<Enumerable<MineralCreateWithoutCopperInput>, Enumerable<MineralUncheckedCreateWithoutCopperInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutCopperInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutCopperInput>
    createMany?: MineralCreateManyCopperInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutCopperInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutCopperInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MineralCreateNestedManyWithoutIodineInput = {
    create?: XOR<Enumerable<MineralCreateWithoutIodineInput>, Enumerable<MineralUncheckedCreateWithoutIodineInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutIodineInput>
    createMany?: MineralCreateManyIodineInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MeasurementCreateNestedOneWithoutIodineInput = {
    create?: XOR<MeasurementCreateWithoutIodineInput, MeasurementUncheckedCreateWithoutIodineInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutIodineInput
    connect?: MeasurementWhereUniqueInput
  }

  export type MineralUncheckedCreateNestedManyWithoutIodineInput = {
    create?: XOR<Enumerable<MineralCreateWithoutIodineInput>, Enumerable<MineralUncheckedCreateWithoutIodineInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutIodineInput>
    createMany?: MineralCreateManyIodineInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MineralUpdateManyWithoutIodineInput = {
    create?: XOR<Enumerable<MineralCreateWithoutIodineInput>, Enumerable<MineralUncheckedCreateWithoutIodineInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutIodineInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutIodineInput>
    createMany?: MineralCreateManyIodineInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutIodineInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutIodineInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MeasurementUpdateOneRequiredWithoutIodineInput = {
    create?: XOR<MeasurementCreateWithoutIodineInput, MeasurementUncheckedCreateWithoutIodineInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutIodineInput
    upsert?: MeasurementUpsertWithoutIodineInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutIodineInput, MeasurementUncheckedUpdateWithoutIodineInput>
  }

  export type MineralUncheckedUpdateManyWithoutIodineInput = {
    create?: XOR<Enumerable<MineralCreateWithoutIodineInput>, Enumerable<MineralUncheckedCreateWithoutIodineInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutIodineInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutIodineInput>
    createMany?: MineralCreateManyIodineInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutIodineInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutIodineInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MineralCreateNestedManyWithoutCalciumInput = {
    create?: XOR<Enumerable<MineralCreateWithoutCalciumInput>, Enumerable<MineralUncheckedCreateWithoutCalciumInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutCalciumInput>
    createMany?: MineralCreateManyCalciumInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MeasurementCreateNestedOneWithoutCalciumInput = {
    create?: XOR<MeasurementCreateWithoutCalciumInput, MeasurementUncheckedCreateWithoutCalciumInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutCalciumInput
    connect?: MeasurementWhereUniqueInput
  }

  export type MineralUncheckedCreateNestedManyWithoutCalciumInput = {
    create?: XOR<Enumerable<MineralCreateWithoutCalciumInput>, Enumerable<MineralUncheckedCreateWithoutCalciumInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutCalciumInput>
    createMany?: MineralCreateManyCalciumInputEnvelope
    connect?: Enumerable<MineralWhereUniqueInput>
  }

  export type MineralUpdateManyWithoutCalciumInput = {
    create?: XOR<Enumerable<MineralCreateWithoutCalciumInput>, Enumerable<MineralUncheckedCreateWithoutCalciumInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutCalciumInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutCalciumInput>
    createMany?: MineralCreateManyCalciumInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutCalciumInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutCalciumInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type MeasurementUpdateOneRequiredWithoutCalciumInput = {
    create?: XOR<MeasurementCreateWithoutCalciumInput, MeasurementUncheckedCreateWithoutCalciumInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutCalciumInput
    upsert?: MeasurementUpsertWithoutCalciumInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutCalciumInput, MeasurementUncheckedUpdateWithoutCalciumInput>
  }

  export type MineralUncheckedUpdateManyWithoutCalciumInput = {
    create?: XOR<Enumerable<MineralCreateWithoutCalciumInput>, Enumerable<MineralUncheckedCreateWithoutCalciumInput>>
    connectOrCreate?: Enumerable<MineralCreateOrConnectWithoutCalciumInput>
    upsert?: Enumerable<MineralUpsertWithWhereUniqueWithoutCalciumInput>
    createMany?: MineralCreateManyCalciumInputEnvelope
    set?: Enumerable<MineralWhereUniqueInput>
    disconnect?: Enumerable<MineralWhereUniqueInput>
    delete?: Enumerable<MineralWhereUniqueInput>
    connect?: Enumerable<MineralWhereUniqueInput>
    update?: Enumerable<MineralUpdateWithWhereUniqueWithoutCalciumInput>
    updateMany?: Enumerable<MineralUpdateManyWithWhereWithoutCalciumInput>
    deleteMany?: Enumerable<MineralScalarWhereInput>
  }

  export type SaltCreateNestedOneWithoutMineralsInput = {
    create?: XOR<SaltCreateWithoutMineralsInput, SaltUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: SaltCreateOrConnectWithoutMineralsInput
    connect?: SaltWhereUniqueInput
  }

  export type NutritionFactCreateNestedManyWithoutMineralsInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutMineralsInput>, Enumerable<NutritionFactUncheckedCreateWithoutMineralsInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutMineralsInput>
    createMany?: NutritionFactCreateManyMineralsInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type IronCreateNestedOneWithoutMineralsInput = {
    create?: XOR<IronCreateWithoutMineralsInput, IronUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: IronCreateOrConnectWithoutMineralsInput
    connect?: IronWhereUniqueInput
  }

  export type ZincCreateNestedOneWithoutMineralsInput = {
    create?: XOR<ZincCreateWithoutMineralsInput, ZincUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: ZincCreateOrConnectWithoutMineralsInput
    connect?: ZincWhereUniqueInput
  }

  export type MagnesiumCreateNestedOneWithoutMineralsInput = {
    create?: XOR<MagnesiumCreateWithoutMineralsInput, MagnesiumUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: MagnesiumCreateOrConnectWithoutMineralsInput
    connect?: MagnesiumWhereUniqueInput
  }

  export type ChlorideCreateNestedOneWithoutMineralsInput = {
    create?: XOR<ChlorideCreateWithoutMineralsInput, ChlorideUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: ChlorideCreateOrConnectWithoutMineralsInput
    connect?: ChlorideWhereUniqueInput
  }

  export type ManganeseCreateNestedOneWithoutMineralsInput = {
    create?: XOR<ManganeseCreateWithoutMineralsInput, ManganeseUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: ManganeseCreateOrConnectWithoutMineralsInput
    connect?: ManganeseWhereUniqueInput
  }

  export type SulfurCreateNestedOneWithoutMineralsInput = {
    create?: XOR<SulfurCreateWithoutMineralsInput, SulfurUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: SulfurCreateOrConnectWithoutMineralsInput
    connect?: SulfurWhereUniqueInput
  }

  export type PotassiumCreateNestedOneWithoutMineralsInput = {
    create?: XOR<PotassiumCreateWithoutMineralsInput, PotassiumUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: PotassiumCreateOrConnectWithoutMineralsInput
    connect?: PotassiumWhereUniqueInput
  }

  export type FluorideCreateNestedOneWithoutMineralsInput = {
    create?: XOR<FluorideCreateWithoutMineralsInput, FluorideUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: FluorideCreateOrConnectWithoutMineralsInput
    connect?: FluorideWhereUniqueInput
  }

  export type PhosphorousCreateNestedOneWithoutMineralsInput = {
    create?: XOR<PhosphorousCreateWithoutMineralsInput, PhosphorousUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: PhosphorousCreateOrConnectWithoutMineralsInput
    connect?: PhosphorousWhereUniqueInput
  }

  export type CopperCreateNestedOneWithoutMineralsInput = {
    create?: XOR<CopperCreateWithoutMineralsInput, CopperUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: CopperCreateOrConnectWithoutMineralsInput
    connect?: CopperWhereUniqueInput
  }

  export type IodineCreateNestedOneWithoutMineralsInput = {
    create?: XOR<IodineCreateWithoutMineralsInput, IodineUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: IodineCreateOrConnectWithoutMineralsInput
    connect?: IodineWhereUniqueInput
  }

  export type CalciumCreateNestedOneWithoutMineralsInput = {
    create?: XOR<CalciumCreateWithoutMineralsInput, CalciumUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: CalciumCreateOrConnectWithoutMineralsInput
    connect?: CalciumWhereUniqueInput
  }

  export type NutritionFactUncheckedCreateNestedManyWithoutMineralsInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutMineralsInput>, Enumerable<NutritionFactUncheckedCreateWithoutMineralsInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutMineralsInput>
    createMany?: NutritionFactCreateManyMineralsInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type SaltUpdateOneWithoutMineralsInput = {
    create?: XOR<SaltCreateWithoutMineralsInput, SaltUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: SaltCreateOrConnectWithoutMineralsInput
    upsert?: SaltUpsertWithoutMineralsInput
    disconnect?: boolean
    delete?: boolean
    connect?: SaltWhereUniqueInput
    update?: XOR<SaltUpdateWithoutMineralsInput, SaltUncheckedUpdateWithoutMineralsInput>
  }

  export type NutritionFactUpdateManyWithoutMineralsInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutMineralsInput>, Enumerable<NutritionFactUncheckedCreateWithoutMineralsInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutMineralsInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutMineralsInput>
    createMany?: NutritionFactCreateManyMineralsInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutMineralsInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutMineralsInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type IronUpdateOneWithoutMineralsInput = {
    create?: XOR<IronCreateWithoutMineralsInput, IronUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: IronCreateOrConnectWithoutMineralsInput
    upsert?: IronUpsertWithoutMineralsInput
    disconnect?: boolean
    delete?: boolean
    connect?: IronWhereUniqueInput
    update?: XOR<IronUpdateWithoutMineralsInput, IronUncheckedUpdateWithoutMineralsInput>
  }

  export type ZincUpdateOneWithoutMineralsInput = {
    create?: XOR<ZincCreateWithoutMineralsInput, ZincUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: ZincCreateOrConnectWithoutMineralsInput
    upsert?: ZincUpsertWithoutMineralsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ZincWhereUniqueInput
    update?: XOR<ZincUpdateWithoutMineralsInput, ZincUncheckedUpdateWithoutMineralsInput>
  }

  export type MagnesiumUpdateOneWithoutMineralsInput = {
    create?: XOR<MagnesiumCreateWithoutMineralsInput, MagnesiumUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: MagnesiumCreateOrConnectWithoutMineralsInput
    upsert?: MagnesiumUpsertWithoutMineralsInput
    disconnect?: boolean
    delete?: boolean
    connect?: MagnesiumWhereUniqueInput
    update?: XOR<MagnesiumUpdateWithoutMineralsInput, MagnesiumUncheckedUpdateWithoutMineralsInput>
  }

  export type ChlorideUpdateOneWithoutMineralsInput = {
    create?: XOR<ChlorideCreateWithoutMineralsInput, ChlorideUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: ChlorideCreateOrConnectWithoutMineralsInput
    upsert?: ChlorideUpsertWithoutMineralsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ChlorideWhereUniqueInput
    update?: XOR<ChlorideUpdateWithoutMineralsInput, ChlorideUncheckedUpdateWithoutMineralsInput>
  }

  export type ManganeseUpdateOneWithoutMineralsInput = {
    create?: XOR<ManganeseCreateWithoutMineralsInput, ManganeseUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: ManganeseCreateOrConnectWithoutMineralsInput
    upsert?: ManganeseUpsertWithoutMineralsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ManganeseWhereUniqueInput
    update?: XOR<ManganeseUpdateWithoutMineralsInput, ManganeseUncheckedUpdateWithoutMineralsInput>
  }

  export type SulfurUpdateOneWithoutMineralsInput = {
    create?: XOR<SulfurCreateWithoutMineralsInput, SulfurUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: SulfurCreateOrConnectWithoutMineralsInput
    upsert?: SulfurUpsertWithoutMineralsInput
    disconnect?: boolean
    delete?: boolean
    connect?: SulfurWhereUniqueInput
    update?: XOR<SulfurUpdateWithoutMineralsInput, SulfurUncheckedUpdateWithoutMineralsInput>
  }

  export type PotassiumUpdateOneWithoutMineralsInput = {
    create?: XOR<PotassiumCreateWithoutMineralsInput, PotassiumUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: PotassiumCreateOrConnectWithoutMineralsInput
    upsert?: PotassiumUpsertWithoutMineralsInput
    disconnect?: boolean
    delete?: boolean
    connect?: PotassiumWhereUniqueInput
    update?: XOR<PotassiumUpdateWithoutMineralsInput, PotassiumUncheckedUpdateWithoutMineralsInput>
  }

  export type FluorideUpdateOneWithoutMineralsInput = {
    create?: XOR<FluorideCreateWithoutMineralsInput, FluorideUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: FluorideCreateOrConnectWithoutMineralsInput
    upsert?: FluorideUpsertWithoutMineralsInput
    disconnect?: boolean
    delete?: boolean
    connect?: FluorideWhereUniqueInput
    update?: XOR<FluorideUpdateWithoutMineralsInput, FluorideUncheckedUpdateWithoutMineralsInput>
  }

  export type PhosphorousUpdateOneWithoutMineralsInput = {
    create?: XOR<PhosphorousCreateWithoutMineralsInput, PhosphorousUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: PhosphorousCreateOrConnectWithoutMineralsInput
    upsert?: PhosphorousUpsertWithoutMineralsInput
    disconnect?: boolean
    delete?: boolean
    connect?: PhosphorousWhereUniqueInput
    update?: XOR<PhosphorousUpdateWithoutMineralsInput, PhosphorousUncheckedUpdateWithoutMineralsInput>
  }

  export type CopperUpdateOneWithoutMineralsInput = {
    create?: XOR<CopperCreateWithoutMineralsInput, CopperUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: CopperCreateOrConnectWithoutMineralsInput
    upsert?: CopperUpsertWithoutMineralsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CopperWhereUniqueInput
    update?: XOR<CopperUpdateWithoutMineralsInput, CopperUncheckedUpdateWithoutMineralsInput>
  }

  export type IodineUpdateOneWithoutMineralsInput = {
    create?: XOR<IodineCreateWithoutMineralsInput, IodineUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: IodineCreateOrConnectWithoutMineralsInput
    upsert?: IodineUpsertWithoutMineralsInput
    disconnect?: boolean
    delete?: boolean
    connect?: IodineWhereUniqueInput
    update?: XOR<IodineUpdateWithoutMineralsInput, IodineUncheckedUpdateWithoutMineralsInput>
  }

  export type CalciumUpdateOneWithoutMineralsInput = {
    create?: XOR<CalciumCreateWithoutMineralsInput, CalciumUncheckedCreateWithoutMineralsInput>
    connectOrCreate?: CalciumCreateOrConnectWithoutMineralsInput
    upsert?: CalciumUpsertWithoutMineralsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CalciumWhereUniqueInput
    update?: XOR<CalciumUpdateWithoutMineralsInput, CalciumUncheckedUpdateWithoutMineralsInput>
  }

  export type NutritionFactUncheckedUpdateManyWithoutMineralsInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutMineralsInput>, Enumerable<NutritionFactUncheckedCreateWithoutMineralsInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutMineralsInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutMineralsInput>
    createMany?: NutritionFactCreateManyMineralsInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutMineralsInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutMineralsInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type MeasurementCreateNestedManyWithoutUnitInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutUnitInput>, Enumerable<MeasurementUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutUnitInput>
    createMany?: MeasurementCreateManyUnitInputEnvelope
    connect?: Enumerable<MeasurementWhereUniqueInput>
  }

  export type MeasurementUncheckedCreateNestedManyWithoutUnitInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutUnitInput>, Enumerable<MeasurementUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutUnitInput>
    createMany?: MeasurementCreateManyUnitInputEnvelope
    connect?: Enumerable<MeasurementWhereUniqueInput>
  }

  export type MeasurementUpdateManyWithoutUnitInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutUnitInput>, Enumerable<MeasurementUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutUnitInput>
    upsert?: Enumerable<MeasurementUpsertWithWhereUniqueWithoutUnitInput>
    createMany?: MeasurementCreateManyUnitInputEnvelope
    set?: Enumerable<MeasurementWhereUniqueInput>
    disconnect?: Enumerable<MeasurementWhereUniqueInput>
    delete?: Enumerable<MeasurementWhereUniqueInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
    update?: Enumerable<MeasurementUpdateWithWhereUniqueWithoutUnitInput>
    updateMany?: Enumerable<MeasurementUpdateManyWithWhereWithoutUnitInput>
    deleteMany?: Enumerable<MeasurementScalarWhereInput>
  }

  export type MeasurementUncheckedUpdateManyWithoutUnitInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutUnitInput>, Enumerable<MeasurementUncheckedCreateWithoutUnitInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutUnitInput>
    upsert?: Enumerable<MeasurementUpsertWithWhereUniqueWithoutUnitInput>
    createMany?: MeasurementCreateManyUnitInputEnvelope
    set?: Enumerable<MeasurementWhereUniqueInput>
    disconnect?: Enumerable<MeasurementWhereUniqueInput>
    delete?: Enumerable<MeasurementWhereUniqueInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
    update?: Enumerable<MeasurementUpdateWithWhereUniqueWithoutUnitInput>
    updateMany?: Enumerable<MeasurementUpdateManyWithWhereWithoutUnitInput>
    deleteMany?: Enumerable<MeasurementScalarWhereInput>
  }

  export type UnitCreateNestedOneWithoutMeasurementsInput = {
    create?: XOR<UnitCreateWithoutMeasurementsInput, UnitUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutMeasurementsInput
    connect?: UnitWhereUniqueInput
  }

  export type ServingCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ServingCreateWithoutMeasurementInput>, Enumerable<ServingUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ServingCreateOrConnectWithoutMeasurementInput>
    createMany?: ServingCreateManyMeasurementInputEnvelope
    connect?: Enumerable<ServingWhereUniqueInput>
  }

  export type VitaminCreateNestedManyWithoutMeasurementsInput = {
    create?: XOR<Enumerable<VitaminCreateWithoutMeasurementsInput>, Enumerable<VitaminUncheckedCreateWithoutMeasurementsInput>>
    connectOrCreate?: Enumerable<VitaminCreateOrConnectWithoutMeasurementsInput>
    connect?: Enumerable<VitaminWhereUniqueInput>
  }

  export type SaltCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SaltCreateWithoutMeasurementInput>, Enumerable<SaltUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SaltCreateOrConnectWithoutMeasurementInput>
    createMany?: SaltCreateManyMeasurementInputEnvelope
    connect?: Enumerable<SaltWhereUniqueInput>
  }

  export type ZincCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ZincCreateWithoutMeasurementInput>, Enumerable<ZincUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ZincCreateOrConnectWithoutMeasurementInput>
    createMany?: ZincCreateManyMeasurementInputEnvelope
    connect?: Enumerable<ZincWhereUniqueInput>
  }

  export type IronCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<IronCreateWithoutMeasurementInput>, Enumerable<IronUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<IronCreateOrConnectWithoutMeasurementInput>
    createMany?: IronCreateManyMeasurementInputEnvelope
    connect?: Enumerable<IronWhereUniqueInput>
  }

  export type MagnesiumCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<MagnesiumCreateWithoutMeasurementInput>, Enumerable<MagnesiumUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<MagnesiumCreateOrConnectWithoutMeasurementInput>
    createMany?: MagnesiumCreateManyMeasurementInputEnvelope
    connect?: Enumerable<MagnesiumWhereUniqueInput>
  }

  export type ChlorideCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ChlorideCreateWithoutMeasurementInput>, Enumerable<ChlorideUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ChlorideCreateOrConnectWithoutMeasurementInput>
    createMany?: ChlorideCreateManyMeasurementInputEnvelope
    connect?: Enumerable<ChlorideWhereUniqueInput>
  }

  export type ManganeseCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ManganeseCreateWithoutMeasurementInput>, Enumerable<ManganeseUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ManganeseCreateOrConnectWithoutMeasurementInput>
    createMany?: ManganeseCreateManyMeasurementInputEnvelope
    connect?: Enumerable<ManganeseWhereUniqueInput>
  }

  export type SulfurCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SulfurCreateWithoutMeasurementInput>, Enumerable<SulfurUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SulfurCreateOrConnectWithoutMeasurementInput>
    createMany?: SulfurCreateManyMeasurementInputEnvelope
    connect?: Enumerable<SulfurWhereUniqueInput>
  }

  export type PotassiumCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<PotassiumCreateWithoutMeasurementInput>, Enumerable<PotassiumUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<PotassiumCreateOrConnectWithoutMeasurementInput>
    createMany?: PotassiumCreateManyMeasurementInputEnvelope
    connect?: Enumerable<PotassiumWhereUniqueInput>
  }

  export type FluorideCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<FluorideCreateWithoutMeasurementInput>, Enumerable<FluorideUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<FluorideCreateOrConnectWithoutMeasurementInput>
    createMany?: FluorideCreateManyMeasurementInputEnvelope
    connect?: Enumerable<FluorideWhereUniqueInput>
  }

  export type PhosphorousCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<PhosphorousCreateWithoutMeasurementInput>, Enumerable<PhosphorousUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<PhosphorousCreateOrConnectWithoutMeasurementInput>
    createMany?: PhosphorousCreateManyMeasurementInputEnvelope
    connect?: Enumerable<PhosphorousWhereUniqueInput>
  }

  export type CopperCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<CopperCreateWithoutMeasurementInput>, Enumerable<CopperUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<CopperCreateOrConnectWithoutMeasurementInput>
    createMany?: CopperCreateManyMeasurementInputEnvelope
    connect?: Enumerable<CopperWhereUniqueInput>
  }

  export type IodineCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<IodineCreateWithoutMeasurementInput>, Enumerable<IodineUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<IodineCreateOrConnectWithoutMeasurementInput>
    createMany?: IodineCreateManyMeasurementInputEnvelope
    connect?: Enumerable<IodineWhereUniqueInput>
  }

  export type CalciumCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<CalciumCreateWithoutMeasurementInput>, Enumerable<CalciumUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<CalciumCreateOrConnectWithoutMeasurementInput>
    createMany?: CalciumCreateManyMeasurementInputEnvelope
    connect?: Enumerable<CalciumWhereUniqueInput>
  }

  export type TotalFatCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<TotalFatCreateWithoutMeasurementInput>, Enumerable<TotalFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<TotalFatCreateOrConnectWithoutMeasurementInput>
    createMany?: TotalFatCreateManyMeasurementInputEnvelope
    connect?: Enumerable<TotalFatWhereUniqueInput>
  }

  export type SaturatedFatCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SaturatedFatCreateWithoutMeasurementInput>, Enumerable<SaturatedFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SaturatedFatCreateOrConnectWithoutMeasurementInput>
    createMany?: SaturatedFatCreateManyMeasurementInputEnvelope
    connect?: Enumerable<SaturatedFatWhereUniqueInput>
  }

  export type MonosaturatedFatCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<MonosaturatedFatCreateWithoutMeasurementInput>, Enumerable<MonosaturatedFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<MonosaturatedFatCreateOrConnectWithoutMeasurementInput>
    createMany?: MonosaturatedFatCreateManyMeasurementInputEnvelope
    connect?: Enumerable<MonosaturatedFatWhereUniqueInput>
  }

  export type PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<PolyunsaturatedFatCreateWithoutMeasurementInput>, Enumerable<PolyunsaturatedFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<PolyunsaturatedFatCreateOrConnectWithoutMeasurementInput>
    createMany?: PolyunsaturatedFatCreateManyMeasurementInputEnvelope
    connect?: Enumerable<PolyunsaturatedFatWhereUniqueInput>
  }

  export type TransFatCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<TransFatCreateWithoutMeasurementInput>, Enumerable<TransFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<TransFatCreateOrConnectWithoutMeasurementInput>
    createMany?: TransFatCreateManyMeasurementInputEnvelope
    connect?: Enumerable<TransFatWhereUniqueInput>
  }

  export type TotalCarbohydrateCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<TotalCarbohydrateCreateWithoutMeasurementInput>, Enumerable<TotalCarbohydrateUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<TotalCarbohydrateCreateOrConnectWithoutMeasurementInput>
    createMany?: TotalCarbohydrateCreateManyMeasurementInputEnvelope
    connect?: Enumerable<TotalCarbohydrateWhereUniqueInput>
  }

  export type SugarCarbohydrateCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SugarCarbohydrateCreateWithoutMeasurementInput>, Enumerable<SugarCarbohydrateUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SugarCarbohydrateCreateOrConnectWithoutMeasurementInput>
    createMany?: SugarCarbohydrateCreateManyMeasurementInputEnvelope
    connect?: Enumerable<SugarCarbohydrateWhereUniqueInput>
  }

  export type VitaminCCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminCCreateWithoutMeasurementInput>, Enumerable<VitaminCUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminCCreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminCCreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminCWhereUniqueInput>
  }

  export type VitaminACreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminACreateWithoutMeasurementInput>, Enumerable<VitaminAUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminACreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminACreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminAWhereUniqueInput>
  }

  export type VitaminDCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminDCreateWithoutMeasurementInput>, Enumerable<VitaminDUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminDCreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminDCreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminDWhereUniqueInput>
  }

  export type VitaminECreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminECreateWithoutMeasurementInput>, Enumerable<VitaminEUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminECreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminECreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminEWhereUniqueInput>
  }

  export type VitaminB1CreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB1CreateWithoutMeasurementInput>, Enumerable<VitaminB1UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB1CreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminB1CreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminB1WhereUniqueInput>
  }

  export type VitaminB2CreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB2CreateWithoutMeasurementInput>, Enumerable<VitaminB2UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB2CreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminB2CreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminB2WhereUniqueInput>
  }

  export type VitaminB6CreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB6CreateWithoutMeasurementInput>, Enumerable<VitaminB6UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB6CreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminB6CreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminB6WhereUniqueInput>
  }

  export type VitaminB12CreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB12CreateWithoutMeasurementInput>, Enumerable<VitaminB12UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB12CreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminB12CreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminB12WhereUniqueInput>
  }

  export type EnergyCreateNestedManyWithoutMeasurementsInput = {
    create?: XOR<Enumerable<EnergyCreateWithoutMeasurementsInput>, Enumerable<EnergyUncheckedCreateWithoutMeasurementsInput>>
    connectOrCreate?: Enumerable<EnergyCreateOrConnectWithoutMeasurementsInput>
    connect?: Enumerable<EnergyWhereUniqueInput>
  }

  export type ProteinCreateNestedOneWithoutMeasurementsInput = {
    create?: XOR<ProteinCreateWithoutMeasurementsInput, ProteinUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: ProteinCreateOrConnectWithoutMeasurementsInput
    connect?: ProteinWhereUniqueInput
  }

  export type CholesterolCreateNestedOneWithoutMeasurementsInput = {
    create?: XOR<CholesterolCreateWithoutMeasurementsInput, CholesterolUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: CholesterolCreateOrConnectWithoutMeasurementsInput
    connect?: CholesterolWhereUniqueInput
  }

  export type FiberCreateNestedOneWithoutMeasurementsInput = {
    create?: XOR<FiberCreateWithoutMeasurementsInput, FiberUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: FiberCreateOrConnectWithoutMeasurementsInput
    connect?: FiberWhereUniqueInput
  }

  export type WaterCreateNestedOneWithoutMeasurementsInput = {
    create?: XOR<WaterCreateWithoutMeasurementsInput, WaterUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: WaterCreateOrConnectWithoutMeasurementsInput
    connect?: WaterWhereUniqueInput
  }

  export type ServingUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ServingCreateWithoutMeasurementInput>, Enumerable<ServingUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ServingCreateOrConnectWithoutMeasurementInput>
    createMany?: ServingCreateManyMeasurementInputEnvelope
    connect?: Enumerable<ServingWhereUniqueInput>
  }

  export type VitaminUncheckedCreateNestedManyWithoutMeasurementsInput = {
    create?: XOR<Enumerable<VitaminCreateWithoutMeasurementsInput>, Enumerable<VitaminUncheckedCreateWithoutMeasurementsInput>>
    connectOrCreate?: Enumerable<VitaminCreateOrConnectWithoutMeasurementsInput>
    connect?: Enumerable<VitaminWhereUniqueInput>
  }

  export type SaltUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SaltCreateWithoutMeasurementInput>, Enumerable<SaltUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SaltCreateOrConnectWithoutMeasurementInput>
    createMany?: SaltCreateManyMeasurementInputEnvelope
    connect?: Enumerable<SaltWhereUniqueInput>
  }

  export type ZincUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ZincCreateWithoutMeasurementInput>, Enumerable<ZincUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ZincCreateOrConnectWithoutMeasurementInput>
    createMany?: ZincCreateManyMeasurementInputEnvelope
    connect?: Enumerable<ZincWhereUniqueInput>
  }

  export type IronUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<IronCreateWithoutMeasurementInput>, Enumerable<IronUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<IronCreateOrConnectWithoutMeasurementInput>
    createMany?: IronCreateManyMeasurementInputEnvelope
    connect?: Enumerable<IronWhereUniqueInput>
  }

  export type MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<MagnesiumCreateWithoutMeasurementInput>, Enumerable<MagnesiumUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<MagnesiumCreateOrConnectWithoutMeasurementInput>
    createMany?: MagnesiumCreateManyMeasurementInputEnvelope
    connect?: Enumerable<MagnesiumWhereUniqueInput>
  }

  export type ChlorideUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ChlorideCreateWithoutMeasurementInput>, Enumerable<ChlorideUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ChlorideCreateOrConnectWithoutMeasurementInput>
    createMany?: ChlorideCreateManyMeasurementInputEnvelope
    connect?: Enumerable<ChlorideWhereUniqueInput>
  }

  export type ManganeseUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ManganeseCreateWithoutMeasurementInput>, Enumerable<ManganeseUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ManganeseCreateOrConnectWithoutMeasurementInput>
    createMany?: ManganeseCreateManyMeasurementInputEnvelope
    connect?: Enumerable<ManganeseWhereUniqueInput>
  }

  export type SulfurUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SulfurCreateWithoutMeasurementInput>, Enumerable<SulfurUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SulfurCreateOrConnectWithoutMeasurementInput>
    createMany?: SulfurCreateManyMeasurementInputEnvelope
    connect?: Enumerable<SulfurWhereUniqueInput>
  }

  export type PotassiumUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<PotassiumCreateWithoutMeasurementInput>, Enumerable<PotassiumUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<PotassiumCreateOrConnectWithoutMeasurementInput>
    createMany?: PotassiumCreateManyMeasurementInputEnvelope
    connect?: Enumerable<PotassiumWhereUniqueInput>
  }

  export type FluorideUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<FluorideCreateWithoutMeasurementInput>, Enumerable<FluorideUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<FluorideCreateOrConnectWithoutMeasurementInput>
    createMany?: FluorideCreateManyMeasurementInputEnvelope
    connect?: Enumerable<FluorideWhereUniqueInput>
  }

  export type PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<PhosphorousCreateWithoutMeasurementInput>, Enumerable<PhosphorousUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<PhosphorousCreateOrConnectWithoutMeasurementInput>
    createMany?: PhosphorousCreateManyMeasurementInputEnvelope
    connect?: Enumerable<PhosphorousWhereUniqueInput>
  }

  export type CopperUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<CopperCreateWithoutMeasurementInput>, Enumerable<CopperUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<CopperCreateOrConnectWithoutMeasurementInput>
    createMany?: CopperCreateManyMeasurementInputEnvelope
    connect?: Enumerable<CopperWhereUniqueInput>
  }

  export type IodineUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<IodineCreateWithoutMeasurementInput>, Enumerable<IodineUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<IodineCreateOrConnectWithoutMeasurementInput>
    createMany?: IodineCreateManyMeasurementInputEnvelope
    connect?: Enumerable<IodineWhereUniqueInput>
  }

  export type CalciumUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<CalciumCreateWithoutMeasurementInput>, Enumerable<CalciumUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<CalciumCreateOrConnectWithoutMeasurementInput>
    createMany?: CalciumCreateManyMeasurementInputEnvelope
    connect?: Enumerable<CalciumWhereUniqueInput>
  }

  export type TotalFatUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<TotalFatCreateWithoutMeasurementInput>, Enumerable<TotalFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<TotalFatCreateOrConnectWithoutMeasurementInput>
    createMany?: TotalFatCreateManyMeasurementInputEnvelope
    connect?: Enumerable<TotalFatWhereUniqueInput>
  }

  export type SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SaturatedFatCreateWithoutMeasurementInput>, Enumerable<SaturatedFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SaturatedFatCreateOrConnectWithoutMeasurementInput>
    createMany?: SaturatedFatCreateManyMeasurementInputEnvelope
    connect?: Enumerable<SaturatedFatWhereUniqueInput>
  }

  export type MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<MonosaturatedFatCreateWithoutMeasurementInput>, Enumerable<MonosaturatedFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<MonosaturatedFatCreateOrConnectWithoutMeasurementInput>
    createMany?: MonosaturatedFatCreateManyMeasurementInputEnvelope
    connect?: Enumerable<MonosaturatedFatWhereUniqueInput>
  }

  export type PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<PolyunsaturatedFatCreateWithoutMeasurementInput>, Enumerable<PolyunsaturatedFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<PolyunsaturatedFatCreateOrConnectWithoutMeasurementInput>
    createMany?: PolyunsaturatedFatCreateManyMeasurementInputEnvelope
    connect?: Enumerable<PolyunsaturatedFatWhereUniqueInput>
  }

  export type TransFatUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<TransFatCreateWithoutMeasurementInput>, Enumerable<TransFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<TransFatCreateOrConnectWithoutMeasurementInput>
    createMany?: TransFatCreateManyMeasurementInputEnvelope
    connect?: Enumerable<TransFatWhereUniqueInput>
  }

  export type TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<TotalCarbohydrateCreateWithoutMeasurementInput>, Enumerable<TotalCarbohydrateUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<TotalCarbohydrateCreateOrConnectWithoutMeasurementInput>
    createMany?: TotalCarbohydrateCreateManyMeasurementInputEnvelope
    connect?: Enumerable<TotalCarbohydrateWhereUniqueInput>
  }

  export type SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SugarCarbohydrateCreateWithoutMeasurementInput>, Enumerable<SugarCarbohydrateUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SugarCarbohydrateCreateOrConnectWithoutMeasurementInput>
    createMany?: SugarCarbohydrateCreateManyMeasurementInputEnvelope
    connect?: Enumerable<SugarCarbohydrateWhereUniqueInput>
  }

  export type VitaminCUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminCCreateWithoutMeasurementInput>, Enumerable<VitaminCUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminCCreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminCCreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminCWhereUniqueInput>
  }

  export type VitaminAUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminACreateWithoutMeasurementInput>, Enumerable<VitaminAUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminACreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminACreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminAWhereUniqueInput>
  }

  export type VitaminDUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminDCreateWithoutMeasurementInput>, Enumerable<VitaminDUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminDCreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminDCreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminDWhereUniqueInput>
  }

  export type VitaminEUncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminECreateWithoutMeasurementInput>, Enumerable<VitaminEUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminECreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminECreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminEWhereUniqueInput>
  }

  export type VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB1CreateWithoutMeasurementInput>, Enumerable<VitaminB1UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB1CreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminB1CreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminB1WhereUniqueInput>
  }

  export type VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB2CreateWithoutMeasurementInput>, Enumerable<VitaminB2UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB2CreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminB2CreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminB2WhereUniqueInput>
  }

  export type VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB6CreateWithoutMeasurementInput>, Enumerable<VitaminB6UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB6CreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminB6CreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminB6WhereUniqueInput>
  }

  export type VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB12CreateWithoutMeasurementInput>, Enumerable<VitaminB12UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB12CreateOrConnectWithoutMeasurementInput>
    createMany?: VitaminB12CreateManyMeasurementInputEnvelope
    connect?: Enumerable<VitaminB12WhereUniqueInput>
  }

  export type EnergyUncheckedCreateNestedManyWithoutMeasurementsInput = {
    create?: XOR<Enumerable<EnergyCreateWithoutMeasurementsInput>, Enumerable<EnergyUncheckedCreateWithoutMeasurementsInput>>
    connectOrCreate?: Enumerable<EnergyCreateOrConnectWithoutMeasurementsInput>
    connect?: Enumerable<EnergyWhereUniqueInput>
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | number | string | null
    increment?: Decimal | number | string
    decrement?: Decimal | number | string
    multiply?: Decimal | number | string
    divide?: Decimal | number | string
  }

  export type UnitUpdateOneRequiredWithoutMeasurementsInput = {
    create?: XOR<UnitCreateWithoutMeasurementsInput, UnitUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: UnitCreateOrConnectWithoutMeasurementsInput
    upsert?: UnitUpsertWithoutMeasurementsInput
    connect?: UnitWhereUniqueInput
    update?: XOR<UnitUpdateWithoutMeasurementsInput, UnitUncheckedUpdateWithoutMeasurementsInput>
  }

  export type ServingUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ServingCreateWithoutMeasurementInput>, Enumerable<ServingUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ServingCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<ServingUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: ServingCreateManyMeasurementInputEnvelope
    set?: Enumerable<ServingWhereUniqueInput>
    disconnect?: Enumerable<ServingWhereUniqueInput>
    delete?: Enumerable<ServingWhereUniqueInput>
    connect?: Enumerable<ServingWhereUniqueInput>
    update?: Enumerable<ServingUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<ServingUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<ServingScalarWhereInput>
  }

  export type VitaminUpdateManyWithoutMeasurementsInput = {
    create?: XOR<Enumerable<VitaminCreateWithoutMeasurementsInput>, Enumerable<VitaminUncheckedCreateWithoutMeasurementsInput>>
    connectOrCreate?: Enumerable<VitaminCreateOrConnectWithoutMeasurementsInput>
    upsert?: Enumerable<VitaminUpsertWithWhereUniqueWithoutMeasurementsInput>
    set?: Enumerable<VitaminWhereUniqueInput>
    disconnect?: Enumerable<VitaminWhereUniqueInput>
    delete?: Enumerable<VitaminWhereUniqueInput>
    connect?: Enumerable<VitaminWhereUniqueInput>
    update?: Enumerable<VitaminUpdateWithWhereUniqueWithoutMeasurementsInput>
    updateMany?: Enumerable<VitaminUpdateManyWithWhereWithoutMeasurementsInput>
    deleteMany?: Enumerable<VitaminScalarWhereInput>
  }

  export type SaltUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SaltCreateWithoutMeasurementInput>, Enumerable<SaltUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SaltCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<SaltUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: SaltCreateManyMeasurementInputEnvelope
    set?: Enumerable<SaltWhereUniqueInput>
    disconnect?: Enumerable<SaltWhereUniqueInput>
    delete?: Enumerable<SaltWhereUniqueInput>
    connect?: Enumerable<SaltWhereUniqueInput>
    update?: Enumerable<SaltUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<SaltUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<SaltScalarWhereInput>
  }

  export type ZincUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ZincCreateWithoutMeasurementInput>, Enumerable<ZincUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ZincCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<ZincUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: ZincCreateManyMeasurementInputEnvelope
    set?: Enumerable<ZincWhereUniqueInput>
    disconnect?: Enumerable<ZincWhereUniqueInput>
    delete?: Enumerable<ZincWhereUniqueInput>
    connect?: Enumerable<ZincWhereUniqueInput>
    update?: Enumerable<ZincUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<ZincUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<ZincScalarWhereInput>
  }

  export type IronUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<IronCreateWithoutMeasurementInput>, Enumerable<IronUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<IronCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<IronUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: IronCreateManyMeasurementInputEnvelope
    set?: Enumerable<IronWhereUniqueInput>
    disconnect?: Enumerable<IronWhereUniqueInput>
    delete?: Enumerable<IronWhereUniqueInput>
    connect?: Enumerable<IronWhereUniqueInput>
    update?: Enumerable<IronUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<IronUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<IronScalarWhereInput>
  }

  export type MagnesiumUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<MagnesiumCreateWithoutMeasurementInput>, Enumerable<MagnesiumUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<MagnesiumCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<MagnesiumUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: MagnesiumCreateManyMeasurementInputEnvelope
    set?: Enumerable<MagnesiumWhereUniqueInput>
    disconnect?: Enumerable<MagnesiumWhereUniqueInput>
    delete?: Enumerable<MagnesiumWhereUniqueInput>
    connect?: Enumerable<MagnesiumWhereUniqueInput>
    update?: Enumerable<MagnesiumUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<MagnesiumUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<MagnesiumScalarWhereInput>
  }

  export type ChlorideUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ChlorideCreateWithoutMeasurementInput>, Enumerable<ChlorideUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ChlorideCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<ChlorideUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: ChlorideCreateManyMeasurementInputEnvelope
    set?: Enumerable<ChlorideWhereUniqueInput>
    disconnect?: Enumerable<ChlorideWhereUniqueInput>
    delete?: Enumerable<ChlorideWhereUniqueInput>
    connect?: Enumerable<ChlorideWhereUniqueInput>
    update?: Enumerable<ChlorideUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<ChlorideUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<ChlorideScalarWhereInput>
  }

  export type ManganeseUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ManganeseCreateWithoutMeasurementInput>, Enumerable<ManganeseUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ManganeseCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<ManganeseUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: ManganeseCreateManyMeasurementInputEnvelope
    set?: Enumerable<ManganeseWhereUniqueInput>
    disconnect?: Enumerable<ManganeseWhereUniqueInput>
    delete?: Enumerable<ManganeseWhereUniqueInput>
    connect?: Enumerable<ManganeseWhereUniqueInput>
    update?: Enumerable<ManganeseUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<ManganeseUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<ManganeseScalarWhereInput>
  }

  export type SulfurUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SulfurCreateWithoutMeasurementInput>, Enumerable<SulfurUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SulfurCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<SulfurUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: SulfurCreateManyMeasurementInputEnvelope
    set?: Enumerable<SulfurWhereUniqueInput>
    disconnect?: Enumerable<SulfurWhereUniqueInput>
    delete?: Enumerable<SulfurWhereUniqueInput>
    connect?: Enumerable<SulfurWhereUniqueInput>
    update?: Enumerable<SulfurUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<SulfurUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<SulfurScalarWhereInput>
  }

  export type PotassiumUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<PotassiumCreateWithoutMeasurementInput>, Enumerable<PotassiumUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<PotassiumCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<PotassiumUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: PotassiumCreateManyMeasurementInputEnvelope
    set?: Enumerable<PotassiumWhereUniqueInput>
    disconnect?: Enumerable<PotassiumWhereUniqueInput>
    delete?: Enumerable<PotassiumWhereUniqueInput>
    connect?: Enumerable<PotassiumWhereUniqueInput>
    update?: Enumerable<PotassiumUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<PotassiumUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<PotassiumScalarWhereInput>
  }

  export type FluorideUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<FluorideCreateWithoutMeasurementInput>, Enumerable<FluorideUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<FluorideCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<FluorideUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: FluorideCreateManyMeasurementInputEnvelope
    set?: Enumerable<FluorideWhereUniqueInput>
    disconnect?: Enumerable<FluorideWhereUniqueInput>
    delete?: Enumerable<FluorideWhereUniqueInput>
    connect?: Enumerable<FluorideWhereUniqueInput>
    update?: Enumerable<FluorideUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<FluorideUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<FluorideScalarWhereInput>
  }

  export type PhosphorousUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<PhosphorousCreateWithoutMeasurementInput>, Enumerable<PhosphorousUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<PhosphorousCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<PhosphorousUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: PhosphorousCreateManyMeasurementInputEnvelope
    set?: Enumerable<PhosphorousWhereUniqueInput>
    disconnect?: Enumerable<PhosphorousWhereUniqueInput>
    delete?: Enumerable<PhosphorousWhereUniqueInput>
    connect?: Enumerable<PhosphorousWhereUniqueInput>
    update?: Enumerable<PhosphorousUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<PhosphorousUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<PhosphorousScalarWhereInput>
  }

  export type CopperUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<CopperCreateWithoutMeasurementInput>, Enumerable<CopperUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<CopperCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<CopperUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: CopperCreateManyMeasurementInputEnvelope
    set?: Enumerable<CopperWhereUniqueInput>
    disconnect?: Enumerable<CopperWhereUniqueInput>
    delete?: Enumerable<CopperWhereUniqueInput>
    connect?: Enumerable<CopperWhereUniqueInput>
    update?: Enumerable<CopperUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<CopperUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<CopperScalarWhereInput>
  }

  export type IodineUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<IodineCreateWithoutMeasurementInput>, Enumerable<IodineUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<IodineCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<IodineUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: IodineCreateManyMeasurementInputEnvelope
    set?: Enumerable<IodineWhereUniqueInput>
    disconnect?: Enumerable<IodineWhereUniqueInput>
    delete?: Enumerable<IodineWhereUniqueInput>
    connect?: Enumerable<IodineWhereUniqueInput>
    update?: Enumerable<IodineUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<IodineUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<IodineScalarWhereInput>
  }

  export type CalciumUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<CalciumCreateWithoutMeasurementInput>, Enumerable<CalciumUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<CalciumCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<CalciumUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: CalciumCreateManyMeasurementInputEnvelope
    set?: Enumerable<CalciumWhereUniqueInput>
    disconnect?: Enumerable<CalciumWhereUniqueInput>
    delete?: Enumerable<CalciumWhereUniqueInput>
    connect?: Enumerable<CalciumWhereUniqueInput>
    update?: Enumerable<CalciumUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<CalciumUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<CalciumScalarWhereInput>
  }

  export type TotalFatUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<TotalFatCreateWithoutMeasurementInput>, Enumerable<TotalFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<TotalFatCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<TotalFatUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: TotalFatCreateManyMeasurementInputEnvelope
    set?: Enumerable<TotalFatWhereUniqueInput>
    disconnect?: Enumerable<TotalFatWhereUniqueInput>
    delete?: Enumerable<TotalFatWhereUniqueInput>
    connect?: Enumerable<TotalFatWhereUniqueInput>
    update?: Enumerable<TotalFatUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<TotalFatUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<TotalFatScalarWhereInput>
  }

  export type SaturatedFatUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SaturatedFatCreateWithoutMeasurementInput>, Enumerable<SaturatedFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SaturatedFatCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<SaturatedFatUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: SaturatedFatCreateManyMeasurementInputEnvelope
    set?: Enumerable<SaturatedFatWhereUniqueInput>
    disconnect?: Enumerable<SaturatedFatWhereUniqueInput>
    delete?: Enumerable<SaturatedFatWhereUniqueInput>
    connect?: Enumerable<SaturatedFatWhereUniqueInput>
    update?: Enumerable<SaturatedFatUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<SaturatedFatUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<SaturatedFatScalarWhereInput>
  }

  export type MonosaturatedFatUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<MonosaturatedFatCreateWithoutMeasurementInput>, Enumerable<MonosaturatedFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<MonosaturatedFatCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<MonosaturatedFatUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: MonosaturatedFatCreateManyMeasurementInputEnvelope
    set?: Enumerable<MonosaturatedFatWhereUniqueInput>
    disconnect?: Enumerable<MonosaturatedFatWhereUniqueInput>
    delete?: Enumerable<MonosaturatedFatWhereUniqueInput>
    connect?: Enumerable<MonosaturatedFatWhereUniqueInput>
    update?: Enumerable<MonosaturatedFatUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<MonosaturatedFatUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<MonosaturatedFatScalarWhereInput>
  }

  export type PolyunsaturatedFatUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<PolyunsaturatedFatCreateWithoutMeasurementInput>, Enumerable<PolyunsaturatedFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<PolyunsaturatedFatCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<PolyunsaturatedFatUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: PolyunsaturatedFatCreateManyMeasurementInputEnvelope
    set?: Enumerable<PolyunsaturatedFatWhereUniqueInput>
    disconnect?: Enumerable<PolyunsaturatedFatWhereUniqueInput>
    delete?: Enumerable<PolyunsaturatedFatWhereUniqueInput>
    connect?: Enumerable<PolyunsaturatedFatWhereUniqueInput>
    update?: Enumerable<PolyunsaturatedFatUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<PolyunsaturatedFatUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<PolyunsaturatedFatScalarWhereInput>
  }

  export type TransFatUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<TransFatCreateWithoutMeasurementInput>, Enumerable<TransFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<TransFatCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<TransFatUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: TransFatCreateManyMeasurementInputEnvelope
    set?: Enumerable<TransFatWhereUniqueInput>
    disconnect?: Enumerable<TransFatWhereUniqueInput>
    delete?: Enumerable<TransFatWhereUniqueInput>
    connect?: Enumerable<TransFatWhereUniqueInput>
    update?: Enumerable<TransFatUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<TransFatUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<TransFatScalarWhereInput>
  }

  export type TotalCarbohydrateUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<TotalCarbohydrateCreateWithoutMeasurementInput>, Enumerable<TotalCarbohydrateUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<TotalCarbohydrateCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<TotalCarbohydrateUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: TotalCarbohydrateCreateManyMeasurementInputEnvelope
    set?: Enumerable<TotalCarbohydrateWhereUniqueInput>
    disconnect?: Enumerable<TotalCarbohydrateWhereUniqueInput>
    delete?: Enumerable<TotalCarbohydrateWhereUniqueInput>
    connect?: Enumerable<TotalCarbohydrateWhereUniqueInput>
    update?: Enumerable<TotalCarbohydrateUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<TotalCarbohydrateUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<TotalCarbohydrateScalarWhereInput>
  }

  export type SugarCarbohydrateUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SugarCarbohydrateCreateWithoutMeasurementInput>, Enumerable<SugarCarbohydrateUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SugarCarbohydrateCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<SugarCarbohydrateUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: SugarCarbohydrateCreateManyMeasurementInputEnvelope
    set?: Enumerable<SugarCarbohydrateWhereUniqueInput>
    disconnect?: Enumerable<SugarCarbohydrateWhereUniqueInput>
    delete?: Enumerable<SugarCarbohydrateWhereUniqueInput>
    connect?: Enumerable<SugarCarbohydrateWhereUniqueInput>
    update?: Enumerable<SugarCarbohydrateUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<SugarCarbohydrateUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<SugarCarbohydrateScalarWhereInput>
  }

  export type VitaminCUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminCCreateWithoutMeasurementInput>, Enumerable<VitaminCUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminCCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminCUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminCCreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminCWhereUniqueInput>
    disconnect?: Enumerable<VitaminCWhereUniqueInput>
    delete?: Enumerable<VitaminCWhereUniqueInput>
    connect?: Enumerable<VitaminCWhereUniqueInput>
    update?: Enumerable<VitaminCUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminCUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminCScalarWhereInput>
  }

  export type VitaminAUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminACreateWithoutMeasurementInput>, Enumerable<VitaminAUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminACreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminAUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminACreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminAWhereUniqueInput>
    disconnect?: Enumerable<VitaminAWhereUniqueInput>
    delete?: Enumerable<VitaminAWhereUniqueInput>
    connect?: Enumerable<VitaminAWhereUniqueInput>
    update?: Enumerable<VitaminAUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminAUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminAScalarWhereInput>
  }

  export type VitaminDUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminDCreateWithoutMeasurementInput>, Enumerable<VitaminDUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminDCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminDUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminDCreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminDWhereUniqueInput>
    disconnect?: Enumerable<VitaminDWhereUniqueInput>
    delete?: Enumerable<VitaminDWhereUniqueInput>
    connect?: Enumerable<VitaminDWhereUniqueInput>
    update?: Enumerable<VitaminDUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminDUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminDScalarWhereInput>
  }

  export type VitaminEUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminECreateWithoutMeasurementInput>, Enumerable<VitaminEUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminECreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminEUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminECreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminEWhereUniqueInput>
    disconnect?: Enumerable<VitaminEWhereUniqueInput>
    delete?: Enumerable<VitaminEWhereUniqueInput>
    connect?: Enumerable<VitaminEWhereUniqueInput>
    update?: Enumerable<VitaminEUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminEUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminEScalarWhereInput>
  }

  export type VitaminB1UpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB1CreateWithoutMeasurementInput>, Enumerable<VitaminB1UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB1CreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminB1UpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminB1CreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminB1WhereUniqueInput>
    disconnect?: Enumerable<VitaminB1WhereUniqueInput>
    delete?: Enumerable<VitaminB1WhereUniqueInput>
    connect?: Enumerable<VitaminB1WhereUniqueInput>
    update?: Enumerable<VitaminB1UpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminB1UpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminB1ScalarWhereInput>
  }

  export type VitaminB2UpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB2CreateWithoutMeasurementInput>, Enumerable<VitaminB2UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB2CreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminB2UpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminB2CreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminB2WhereUniqueInput>
    disconnect?: Enumerable<VitaminB2WhereUniqueInput>
    delete?: Enumerable<VitaminB2WhereUniqueInput>
    connect?: Enumerable<VitaminB2WhereUniqueInput>
    update?: Enumerable<VitaminB2UpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminB2UpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminB2ScalarWhereInput>
  }

  export type VitaminB6UpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB6CreateWithoutMeasurementInput>, Enumerable<VitaminB6UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB6CreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminB6UpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminB6CreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminB6WhereUniqueInput>
    disconnect?: Enumerable<VitaminB6WhereUniqueInput>
    delete?: Enumerable<VitaminB6WhereUniqueInput>
    connect?: Enumerable<VitaminB6WhereUniqueInput>
    update?: Enumerable<VitaminB6UpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminB6UpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminB6ScalarWhereInput>
  }

  export type VitaminB12UpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB12CreateWithoutMeasurementInput>, Enumerable<VitaminB12UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB12CreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminB12UpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminB12CreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminB12WhereUniqueInput>
    disconnect?: Enumerable<VitaminB12WhereUniqueInput>
    delete?: Enumerable<VitaminB12WhereUniqueInput>
    connect?: Enumerable<VitaminB12WhereUniqueInput>
    update?: Enumerable<VitaminB12UpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminB12UpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminB12ScalarWhereInput>
  }

  export type EnergyUpdateManyWithoutMeasurementsInput = {
    create?: XOR<Enumerable<EnergyCreateWithoutMeasurementsInput>, Enumerable<EnergyUncheckedCreateWithoutMeasurementsInput>>
    connectOrCreate?: Enumerable<EnergyCreateOrConnectWithoutMeasurementsInput>
    upsert?: Enumerable<EnergyUpsertWithWhereUniqueWithoutMeasurementsInput>
    set?: Enumerable<EnergyWhereUniqueInput>
    disconnect?: Enumerable<EnergyWhereUniqueInput>
    delete?: Enumerable<EnergyWhereUniqueInput>
    connect?: Enumerable<EnergyWhereUniqueInput>
    update?: Enumerable<EnergyUpdateWithWhereUniqueWithoutMeasurementsInput>
    updateMany?: Enumerable<EnergyUpdateManyWithWhereWithoutMeasurementsInput>
    deleteMany?: Enumerable<EnergyScalarWhereInput>
  }

  export type ProteinUpdateOneWithoutMeasurementsInput = {
    create?: XOR<ProteinCreateWithoutMeasurementsInput, ProteinUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: ProteinCreateOrConnectWithoutMeasurementsInput
    upsert?: ProteinUpsertWithoutMeasurementsInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProteinWhereUniqueInput
    update?: XOR<ProteinUpdateWithoutMeasurementsInput, ProteinUncheckedUpdateWithoutMeasurementsInput>
  }

  export type CholesterolUpdateOneWithoutMeasurementsInput = {
    create?: XOR<CholesterolCreateWithoutMeasurementsInput, CholesterolUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: CholesterolCreateOrConnectWithoutMeasurementsInput
    upsert?: CholesterolUpsertWithoutMeasurementsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CholesterolWhereUniqueInput
    update?: XOR<CholesterolUpdateWithoutMeasurementsInput, CholesterolUncheckedUpdateWithoutMeasurementsInput>
  }

  export type FiberUpdateOneWithoutMeasurementsInput = {
    create?: XOR<FiberCreateWithoutMeasurementsInput, FiberUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: FiberCreateOrConnectWithoutMeasurementsInput
    upsert?: FiberUpsertWithoutMeasurementsInput
    disconnect?: boolean
    delete?: boolean
    connect?: FiberWhereUniqueInput
    update?: XOR<FiberUpdateWithoutMeasurementsInput, FiberUncheckedUpdateWithoutMeasurementsInput>
  }

  export type WaterUpdateOneWithoutMeasurementsInput = {
    create?: XOR<WaterCreateWithoutMeasurementsInput, WaterUncheckedCreateWithoutMeasurementsInput>
    connectOrCreate?: WaterCreateOrConnectWithoutMeasurementsInput
    upsert?: WaterUpsertWithoutMeasurementsInput
    disconnect?: boolean
    delete?: boolean
    connect?: WaterWhereUniqueInput
    update?: XOR<WaterUpdateWithoutMeasurementsInput, WaterUncheckedUpdateWithoutMeasurementsInput>
  }

  export type ServingUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ServingCreateWithoutMeasurementInput>, Enumerable<ServingUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ServingCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<ServingUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: ServingCreateManyMeasurementInputEnvelope
    set?: Enumerable<ServingWhereUniqueInput>
    disconnect?: Enumerable<ServingWhereUniqueInput>
    delete?: Enumerable<ServingWhereUniqueInput>
    connect?: Enumerable<ServingWhereUniqueInput>
    update?: Enumerable<ServingUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<ServingUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<ServingScalarWhereInput>
  }

  export type VitaminUncheckedUpdateManyWithoutMeasurementsInput = {
    create?: XOR<Enumerable<VitaminCreateWithoutMeasurementsInput>, Enumerable<VitaminUncheckedCreateWithoutMeasurementsInput>>
    connectOrCreate?: Enumerable<VitaminCreateOrConnectWithoutMeasurementsInput>
    upsert?: Enumerable<VitaminUpsertWithWhereUniqueWithoutMeasurementsInput>
    set?: Enumerable<VitaminWhereUniqueInput>
    disconnect?: Enumerable<VitaminWhereUniqueInput>
    delete?: Enumerable<VitaminWhereUniqueInput>
    connect?: Enumerable<VitaminWhereUniqueInput>
    update?: Enumerable<VitaminUpdateWithWhereUniqueWithoutMeasurementsInput>
    updateMany?: Enumerable<VitaminUpdateManyWithWhereWithoutMeasurementsInput>
    deleteMany?: Enumerable<VitaminScalarWhereInput>
  }

  export type SaltUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SaltCreateWithoutMeasurementInput>, Enumerable<SaltUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SaltCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<SaltUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: SaltCreateManyMeasurementInputEnvelope
    set?: Enumerable<SaltWhereUniqueInput>
    disconnect?: Enumerable<SaltWhereUniqueInput>
    delete?: Enumerable<SaltWhereUniqueInput>
    connect?: Enumerable<SaltWhereUniqueInput>
    update?: Enumerable<SaltUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<SaltUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<SaltScalarWhereInput>
  }

  export type ZincUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ZincCreateWithoutMeasurementInput>, Enumerable<ZincUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ZincCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<ZincUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: ZincCreateManyMeasurementInputEnvelope
    set?: Enumerable<ZincWhereUniqueInput>
    disconnect?: Enumerable<ZincWhereUniqueInput>
    delete?: Enumerable<ZincWhereUniqueInput>
    connect?: Enumerable<ZincWhereUniqueInput>
    update?: Enumerable<ZincUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<ZincUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<ZincScalarWhereInput>
  }

  export type IronUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<IronCreateWithoutMeasurementInput>, Enumerable<IronUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<IronCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<IronUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: IronCreateManyMeasurementInputEnvelope
    set?: Enumerable<IronWhereUniqueInput>
    disconnect?: Enumerable<IronWhereUniqueInput>
    delete?: Enumerable<IronWhereUniqueInput>
    connect?: Enumerable<IronWhereUniqueInput>
    update?: Enumerable<IronUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<IronUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<IronScalarWhereInput>
  }

  export type MagnesiumUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<MagnesiumCreateWithoutMeasurementInput>, Enumerable<MagnesiumUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<MagnesiumCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<MagnesiumUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: MagnesiumCreateManyMeasurementInputEnvelope
    set?: Enumerable<MagnesiumWhereUniqueInput>
    disconnect?: Enumerable<MagnesiumWhereUniqueInput>
    delete?: Enumerable<MagnesiumWhereUniqueInput>
    connect?: Enumerable<MagnesiumWhereUniqueInput>
    update?: Enumerable<MagnesiumUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<MagnesiumUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<MagnesiumScalarWhereInput>
  }

  export type ChlorideUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ChlorideCreateWithoutMeasurementInput>, Enumerable<ChlorideUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ChlorideCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<ChlorideUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: ChlorideCreateManyMeasurementInputEnvelope
    set?: Enumerable<ChlorideWhereUniqueInput>
    disconnect?: Enumerable<ChlorideWhereUniqueInput>
    delete?: Enumerable<ChlorideWhereUniqueInput>
    connect?: Enumerable<ChlorideWhereUniqueInput>
    update?: Enumerable<ChlorideUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<ChlorideUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<ChlorideScalarWhereInput>
  }

  export type ManganeseUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<ManganeseCreateWithoutMeasurementInput>, Enumerable<ManganeseUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<ManganeseCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<ManganeseUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: ManganeseCreateManyMeasurementInputEnvelope
    set?: Enumerable<ManganeseWhereUniqueInput>
    disconnect?: Enumerable<ManganeseWhereUniqueInput>
    delete?: Enumerable<ManganeseWhereUniqueInput>
    connect?: Enumerable<ManganeseWhereUniqueInput>
    update?: Enumerable<ManganeseUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<ManganeseUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<ManganeseScalarWhereInput>
  }

  export type SulfurUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SulfurCreateWithoutMeasurementInput>, Enumerable<SulfurUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SulfurCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<SulfurUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: SulfurCreateManyMeasurementInputEnvelope
    set?: Enumerable<SulfurWhereUniqueInput>
    disconnect?: Enumerable<SulfurWhereUniqueInput>
    delete?: Enumerable<SulfurWhereUniqueInput>
    connect?: Enumerable<SulfurWhereUniqueInput>
    update?: Enumerable<SulfurUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<SulfurUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<SulfurScalarWhereInput>
  }

  export type PotassiumUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<PotassiumCreateWithoutMeasurementInput>, Enumerable<PotassiumUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<PotassiumCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<PotassiumUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: PotassiumCreateManyMeasurementInputEnvelope
    set?: Enumerable<PotassiumWhereUniqueInput>
    disconnect?: Enumerable<PotassiumWhereUniqueInput>
    delete?: Enumerable<PotassiumWhereUniqueInput>
    connect?: Enumerable<PotassiumWhereUniqueInput>
    update?: Enumerable<PotassiumUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<PotassiumUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<PotassiumScalarWhereInput>
  }

  export type FluorideUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<FluorideCreateWithoutMeasurementInput>, Enumerable<FluorideUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<FluorideCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<FluorideUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: FluorideCreateManyMeasurementInputEnvelope
    set?: Enumerable<FluorideWhereUniqueInput>
    disconnect?: Enumerable<FluorideWhereUniqueInput>
    delete?: Enumerable<FluorideWhereUniqueInput>
    connect?: Enumerable<FluorideWhereUniqueInput>
    update?: Enumerable<FluorideUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<FluorideUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<FluorideScalarWhereInput>
  }

  export type PhosphorousUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<PhosphorousCreateWithoutMeasurementInput>, Enumerable<PhosphorousUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<PhosphorousCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<PhosphorousUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: PhosphorousCreateManyMeasurementInputEnvelope
    set?: Enumerable<PhosphorousWhereUniqueInput>
    disconnect?: Enumerable<PhosphorousWhereUniqueInput>
    delete?: Enumerable<PhosphorousWhereUniqueInput>
    connect?: Enumerable<PhosphorousWhereUniqueInput>
    update?: Enumerable<PhosphorousUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<PhosphorousUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<PhosphorousScalarWhereInput>
  }

  export type CopperUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<CopperCreateWithoutMeasurementInput>, Enumerable<CopperUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<CopperCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<CopperUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: CopperCreateManyMeasurementInputEnvelope
    set?: Enumerable<CopperWhereUniqueInput>
    disconnect?: Enumerable<CopperWhereUniqueInput>
    delete?: Enumerable<CopperWhereUniqueInput>
    connect?: Enumerable<CopperWhereUniqueInput>
    update?: Enumerable<CopperUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<CopperUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<CopperScalarWhereInput>
  }

  export type IodineUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<IodineCreateWithoutMeasurementInput>, Enumerable<IodineUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<IodineCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<IodineUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: IodineCreateManyMeasurementInputEnvelope
    set?: Enumerable<IodineWhereUniqueInput>
    disconnect?: Enumerable<IodineWhereUniqueInput>
    delete?: Enumerable<IodineWhereUniqueInput>
    connect?: Enumerable<IodineWhereUniqueInput>
    update?: Enumerable<IodineUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<IodineUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<IodineScalarWhereInput>
  }

  export type CalciumUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<CalciumCreateWithoutMeasurementInput>, Enumerable<CalciumUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<CalciumCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<CalciumUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: CalciumCreateManyMeasurementInputEnvelope
    set?: Enumerable<CalciumWhereUniqueInput>
    disconnect?: Enumerable<CalciumWhereUniqueInput>
    delete?: Enumerable<CalciumWhereUniqueInput>
    connect?: Enumerable<CalciumWhereUniqueInput>
    update?: Enumerable<CalciumUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<CalciumUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<CalciumScalarWhereInput>
  }

  export type TotalFatUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<TotalFatCreateWithoutMeasurementInput>, Enumerable<TotalFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<TotalFatCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<TotalFatUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: TotalFatCreateManyMeasurementInputEnvelope
    set?: Enumerable<TotalFatWhereUniqueInput>
    disconnect?: Enumerable<TotalFatWhereUniqueInput>
    delete?: Enumerable<TotalFatWhereUniqueInput>
    connect?: Enumerable<TotalFatWhereUniqueInput>
    update?: Enumerable<TotalFatUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<TotalFatUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<TotalFatScalarWhereInput>
  }

  export type SaturatedFatUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SaturatedFatCreateWithoutMeasurementInput>, Enumerable<SaturatedFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SaturatedFatCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<SaturatedFatUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: SaturatedFatCreateManyMeasurementInputEnvelope
    set?: Enumerable<SaturatedFatWhereUniqueInput>
    disconnect?: Enumerable<SaturatedFatWhereUniqueInput>
    delete?: Enumerable<SaturatedFatWhereUniqueInput>
    connect?: Enumerable<SaturatedFatWhereUniqueInput>
    update?: Enumerable<SaturatedFatUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<SaturatedFatUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<SaturatedFatScalarWhereInput>
  }

  export type MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<MonosaturatedFatCreateWithoutMeasurementInput>, Enumerable<MonosaturatedFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<MonosaturatedFatCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<MonosaturatedFatUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: MonosaturatedFatCreateManyMeasurementInputEnvelope
    set?: Enumerable<MonosaturatedFatWhereUniqueInput>
    disconnect?: Enumerable<MonosaturatedFatWhereUniqueInput>
    delete?: Enumerable<MonosaturatedFatWhereUniqueInput>
    connect?: Enumerable<MonosaturatedFatWhereUniqueInput>
    update?: Enumerable<MonosaturatedFatUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<MonosaturatedFatUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<MonosaturatedFatScalarWhereInput>
  }

  export type PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<PolyunsaturatedFatCreateWithoutMeasurementInput>, Enumerable<PolyunsaturatedFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<PolyunsaturatedFatCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<PolyunsaturatedFatUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: PolyunsaturatedFatCreateManyMeasurementInputEnvelope
    set?: Enumerable<PolyunsaturatedFatWhereUniqueInput>
    disconnect?: Enumerable<PolyunsaturatedFatWhereUniqueInput>
    delete?: Enumerable<PolyunsaturatedFatWhereUniqueInput>
    connect?: Enumerable<PolyunsaturatedFatWhereUniqueInput>
    update?: Enumerable<PolyunsaturatedFatUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<PolyunsaturatedFatUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<PolyunsaturatedFatScalarWhereInput>
  }

  export type TransFatUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<TransFatCreateWithoutMeasurementInput>, Enumerable<TransFatUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<TransFatCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<TransFatUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: TransFatCreateManyMeasurementInputEnvelope
    set?: Enumerable<TransFatWhereUniqueInput>
    disconnect?: Enumerable<TransFatWhereUniqueInput>
    delete?: Enumerable<TransFatWhereUniqueInput>
    connect?: Enumerable<TransFatWhereUniqueInput>
    update?: Enumerable<TransFatUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<TransFatUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<TransFatScalarWhereInput>
  }

  export type TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<TotalCarbohydrateCreateWithoutMeasurementInput>, Enumerable<TotalCarbohydrateUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<TotalCarbohydrateCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<TotalCarbohydrateUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: TotalCarbohydrateCreateManyMeasurementInputEnvelope
    set?: Enumerable<TotalCarbohydrateWhereUniqueInput>
    disconnect?: Enumerable<TotalCarbohydrateWhereUniqueInput>
    delete?: Enumerable<TotalCarbohydrateWhereUniqueInput>
    connect?: Enumerable<TotalCarbohydrateWhereUniqueInput>
    update?: Enumerable<TotalCarbohydrateUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<TotalCarbohydrateUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<TotalCarbohydrateScalarWhereInput>
  }

  export type SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<SugarCarbohydrateCreateWithoutMeasurementInput>, Enumerable<SugarCarbohydrateUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<SugarCarbohydrateCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<SugarCarbohydrateUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: SugarCarbohydrateCreateManyMeasurementInputEnvelope
    set?: Enumerable<SugarCarbohydrateWhereUniqueInput>
    disconnect?: Enumerable<SugarCarbohydrateWhereUniqueInput>
    delete?: Enumerable<SugarCarbohydrateWhereUniqueInput>
    connect?: Enumerable<SugarCarbohydrateWhereUniqueInput>
    update?: Enumerable<SugarCarbohydrateUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<SugarCarbohydrateUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<SugarCarbohydrateScalarWhereInput>
  }

  export type VitaminCUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminCCreateWithoutMeasurementInput>, Enumerable<VitaminCUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminCCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminCUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminCCreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminCWhereUniqueInput>
    disconnect?: Enumerable<VitaminCWhereUniqueInput>
    delete?: Enumerable<VitaminCWhereUniqueInput>
    connect?: Enumerable<VitaminCWhereUniqueInput>
    update?: Enumerable<VitaminCUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminCUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminCScalarWhereInput>
  }

  export type VitaminAUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminACreateWithoutMeasurementInput>, Enumerable<VitaminAUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminACreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminAUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminACreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminAWhereUniqueInput>
    disconnect?: Enumerable<VitaminAWhereUniqueInput>
    delete?: Enumerable<VitaminAWhereUniqueInput>
    connect?: Enumerable<VitaminAWhereUniqueInput>
    update?: Enumerable<VitaminAUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminAUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminAScalarWhereInput>
  }

  export type VitaminDUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminDCreateWithoutMeasurementInput>, Enumerable<VitaminDUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminDCreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminDUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminDCreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminDWhereUniqueInput>
    disconnect?: Enumerable<VitaminDWhereUniqueInput>
    delete?: Enumerable<VitaminDWhereUniqueInput>
    connect?: Enumerable<VitaminDWhereUniqueInput>
    update?: Enumerable<VitaminDUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminDUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminDScalarWhereInput>
  }

  export type VitaminEUncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminECreateWithoutMeasurementInput>, Enumerable<VitaminEUncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminECreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminEUpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminECreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminEWhereUniqueInput>
    disconnect?: Enumerable<VitaminEWhereUniqueInput>
    delete?: Enumerable<VitaminEWhereUniqueInput>
    connect?: Enumerable<VitaminEWhereUniqueInput>
    update?: Enumerable<VitaminEUpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminEUpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminEScalarWhereInput>
  }

  export type VitaminB1UncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB1CreateWithoutMeasurementInput>, Enumerable<VitaminB1UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB1CreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminB1UpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminB1CreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminB1WhereUniqueInput>
    disconnect?: Enumerable<VitaminB1WhereUniqueInput>
    delete?: Enumerable<VitaminB1WhereUniqueInput>
    connect?: Enumerable<VitaminB1WhereUniqueInput>
    update?: Enumerable<VitaminB1UpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminB1UpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminB1ScalarWhereInput>
  }

  export type VitaminB2UncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB2CreateWithoutMeasurementInput>, Enumerable<VitaminB2UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB2CreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminB2UpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminB2CreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminB2WhereUniqueInput>
    disconnect?: Enumerable<VitaminB2WhereUniqueInput>
    delete?: Enumerable<VitaminB2WhereUniqueInput>
    connect?: Enumerable<VitaminB2WhereUniqueInput>
    update?: Enumerable<VitaminB2UpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminB2UpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminB2ScalarWhereInput>
  }

  export type VitaminB6UncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB6CreateWithoutMeasurementInput>, Enumerable<VitaminB6UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB6CreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminB6UpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminB6CreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminB6WhereUniqueInput>
    disconnect?: Enumerable<VitaminB6WhereUniqueInput>
    delete?: Enumerable<VitaminB6WhereUniqueInput>
    connect?: Enumerable<VitaminB6WhereUniqueInput>
    update?: Enumerable<VitaminB6UpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminB6UpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminB6ScalarWhereInput>
  }

  export type VitaminB12UncheckedUpdateManyWithoutMeasurementInput = {
    create?: XOR<Enumerable<VitaminB12CreateWithoutMeasurementInput>, Enumerable<VitaminB12UncheckedCreateWithoutMeasurementInput>>
    connectOrCreate?: Enumerable<VitaminB12CreateOrConnectWithoutMeasurementInput>
    upsert?: Enumerable<VitaminB12UpsertWithWhereUniqueWithoutMeasurementInput>
    createMany?: VitaminB12CreateManyMeasurementInputEnvelope
    set?: Enumerable<VitaminB12WhereUniqueInput>
    disconnect?: Enumerable<VitaminB12WhereUniqueInput>
    delete?: Enumerable<VitaminB12WhereUniqueInput>
    connect?: Enumerable<VitaminB12WhereUniqueInput>
    update?: Enumerable<VitaminB12UpdateWithWhereUniqueWithoutMeasurementInput>
    updateMany?: Enumerable<VitaminB12UpdateManyWithWhereWithoutMeasurementInput>
    deleteMany?: Enumerable<VitaminB12ScalarWhereInput>
  }

  export type EnergyUncheckedUpdateManyWithoutMeasurementsInput = {
    create?: XOR<Enumerable<EnergyCreateWithoutMeasurementsInput>, Enumerable<EnergyUncheckedCreateWithoutMeasurementsInput>>
    connectOrCreate?: Enumerable<EnergyCreateOrConnectWithoutMeasurementsInput>
    upsert?: Enumerable<EnergyUpsertWithWhereUniqueWithoutMeasurementsInput>
    set?: Enumerable<EnergyWhereUniqueInput>
    disconnect?: Enumerable<EnergyWhereUniqueInput>
    delete?: Enumerable<EnergyWhereUniqueInput>
    connect?: Enumerable<EnergyWhereUniqueInput>
    update?: Enumerable<EnergyUpdateWithWhereUniqueWithoutMeasurementsInput>
    updateMany?: Enumerable<EnergyUpdateManyWithWhereWithoutMeasurementsInput>
    deleteMany?: Enumerable<EnergyScalarWhereInput>
  }

  export type MeasurementCreateNestedOneWithoutServingsInput = {
    create?: XOR<MeasurementCreateWithoutServingsInput, MeasurementUncheckedCreateWithoutServingsInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutServingsInput
    connect?: MeasurementWhereUniqueInput
  }

  export type ProductCreateNestedManyWithoutServingInput = {
    create?: XOR<Enumerable<ProductCreateWithoutServingInput>, Enumerable<ProductUncheckedCreateWithoutServingInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutServingInput>
    createMany?: ProductCreateManyServingInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type ProductUncheckedCreateNestedManyWithoutServingInput = {
    create?: XOR<Enumerable<ProductCreateWithoutServingInput>, Enumerable<ProductUncheckedCreateWithoutServingInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutServingInput>
    createMany?: ProductCreateManyServingInputEnvelope
    connect?: Enumerable<ProductWhereUniqueInput>
  }

  export type MeasurementUpdateOneRequiredWithoutServingsInput = {
    create?: XOR<MeasurementCreateWithoutServingsInput, MeasurementUncheckedCreateWithoutServingsInput>
    connectOrCreate?: MeasurementCreateOrConnectWithoutServingsInput
    upsert?: MeasurementUpsertWithoutServingsInput
    connect?: MeasurementWhereUniqueInput
    update?: XOR<MeasurementUpdateWithoutServingsInput, MeasurementUncheckedUpdateWithoutServingsInput>
  }

  export type ProductUpdateManyWithoutServingInput = {
    create?: XOR<Enumerable<ProductCreateWithoutServingInput>, Enumerable<ProductUncheckedCreateWithoutServingInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutServingInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutServingInput>
    createMany?: ProductCreateManyServingInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutServingInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutServingInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type ProductUncheckedUpdateManyWithoutServingInput = {
    create?: XOR<Enumerable<ProductCreateWithoutServingInput>, Enumerable<ProductUncheckedCreateWithoutServingInput>>
    connectOrCreate?: Enumerable<ProductCreateOrConnectWithoutServingInput>
    upsert?: Enumerable<ProductUpsertWithWhereUniqueWithoutServingInput>
    createMany?: ProductCreateManyServingInputEnvelope
    set?: Enumerable<ProductWhereUniqueInput>
    disconnect?: Enumerable<ProductWhereUniqueInput>
    delete?: Enumerable<ProductWhereUniqueInput>
    connect?: Enumerable<ProductWhereUniqueInput>
    update?: Enumerable<ProductUpdateWithWhereUniqueWithoutServingInput>
    updateMany?: Enumerable<ProductUpdateManyWithWhereWithoutServingInput>
    deleteMany?: Enumerable<ProductScalarWhereInput>
  }

  export type MeasurementCreateNestedManyWithoutEnergyInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutEnergyInput>, Enumerable<MeasurementUncheckedCreateWithoutEnergyInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutEnergyInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
  }

  export type NutritionFactCreateNestedOneWithoutEnergyInput = {
    create?: XOR<NutritionFactCreateWithoutEnergyInput, NutritionFactUncheckedCreateWithoutEnergyInput>
    connectOrCreate?: NutritionFactCreateOrConnectWithoutEnergyInput
    connect?: NutritionFactWhereUniqueInput
  }

  export type MeasurementUncheckedCreateNestedManyWithoutEnergyInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutEnergyInput>, Enumerable<MeasurementUncheckedCreateWithoutEnergyInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutEnergyInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
  }

  export type MeasurementUpdateManyWithoutEnergyInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutEnergyInput>, Enumerable<MeasurementUncheckedCreateWithoutEnergyInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutEnergyInput>
    upsert?: Enumerable<MeasurementUpsertWithWhereUniqueWithoutEnergyInput>
    set?: Enumerable<MeasurementWhereUniqueInput>
    disconnect?: Enumerable<MeasurementWhereUniqueInput>
    delete?: Enumerable<MeasurementWhereUniqueInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
    update?: Enumerable<MeasurementUpdateWithWhereUniqueWithoutEnergyInput>
    updateMany?: Enumerable<MeasurementUpdateManyWithWhereWithoutEnergyInput>
    deleteMany?: Enumerable<MeasurementScalarWhereInput>
  }

  export type NutritionFactUpdateOneRequiredWithoutEnergyInput = {
    create?: XOR<NutritionFactCreateWithoutEnergyInput, NutritionFactUncheckedCreateWithoutEnergyInput>
    connectOrCreate?: NutritionFactCreateOrConnectWithoutEnergyInput
    upsert?: NutritionFactUpsertWithoutEnergyInput
    connect?: NutritionFactWhereUniqueInput
    update?: XOR<NutritionFactUpdateWithoutEnergyInput, NutritionFactUncheckedUpdateWithoutEnergyInput>
  }

  export type MeasurementUncheckedUpdateManyWithoutEnergyInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutEnergyInput>, Enumerable<MeasurementUncheckedCreateWithoutEnergyInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutEnergyInput>
    upsert?: Enumerable<MeasurementUpsertWithWhereUniqueWithoutEnergyInput>
    set?: Enumerable<MeasurementWhereUniqueInput>
    disconnect?: Enumerable<MeasurementWhereUniqueInput>
    delete?: Enumerable<MeasurementWhereUniqueInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
    update?: Enumerable<MeasurementUpdateWithWhereUniqueWithoutEnergyInput>
    updateMany?: Enumerable<MeasurementUpdateManyWithWhereWithoutEnergyInput>
    deleteMany?: Enumerable<MeasurementScalarWhereInput>
  }

  export type MeasurementCreateNestedManyWithoutProteinInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutProteinInput>, Enumerable<MeasurementUncheckedCreateWithoutProteinInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutProteinInput>
    createMany?: MeasurementCreateManyProteinInputEnvelope
    connect?: Enumerable<MeasurementWhereUniqueInput>
  }

  export type NutritionFactCreateNestedManyWithoutProteinInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutProteinInput>, Enumerable<NutritionFactUncheckedCreateWithoutProteinInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutProteinInput>
    createMany?: NutritionFactCreateManyProteinInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type MeasurementUncheckedCreateNestedManyWithoutProteinInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutProteinInput>, Enumerable<MeasurementUncheckedCreateWithoutProteinInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutProteinInput>
    createMany?: MeasurementCreateManyProteinInputEnvelope
    connect?: Enumerable<MeasurementWhereUniqueInput>
  }

  export type NutritionFactUncheckedCreateNestedManyWithoutProteinInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutProteinInput>, Enumerable<NutritionFactUncheckedCreateWithoutProteinInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutProteinInput>
    createMany?: NutritionFactCreateManyProteinInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type MeasurementUpdateManyWithoutProteinInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutProteinInput>, Enumerable<MeasurementUncheckedCreateWithoutProteinInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutProteinInput>
    upsert?: Enumerable<MeasurementUpsertWithWhereUniqueWithoutProteinInput>
    createMany?: MeasurementCreateManyProteinInputEnvelope
    set?: Enumerable<MeasurementWhereUniqueInput>
    disconnect?: Enumerable<MeasurementWhereUniqueInput>
    delete?: Enumerable<MeasurementWhereUniqueInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
    update?: Enumerable<MeasurementUpdateWithWhereUniqueWithoutProteinInput>
    updateMany?: Enumerable<MeasurementUpdateManyWithWhereWithoutProteinInput>
    deleteMany?: Enumerable<MeasurementScalarWhereInput>
  }

  export type NutritionFactUpdateManyWithoutProteinInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutProteinInput>, Enumerable<NutritionFactUncheckedCreateWithoutProteinInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutProteinInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutProteinInput>
    createMany?: NutritionFactCreateManyProteinInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutProteinInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutProteinInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type MeasurementUncheckedUpdateManyWithoutProteinInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutProteinInput>, Enumerable<MeasurementUncheckedCreateWithoutProteinInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutProteinInput>
    upsert?: Enumerable<MeasurementUpsertWithWhereUniqueWithoutProteinInput>
    createMany?: MeasurementCreateManyProteinInputEnvelope
    set?: Enumerable<MeasurementWhereUniqueInput>
    disconnect?: Enumerable<MeasurementWhereUniqueInput>
    delete?: Enumerable<MeasurementWhereUniqueInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
    update?: Enumerable<MeasurementUpdateWithWhereUniqueWithoutProteinInput>
    updateMany?: Enumerable<MeasurementUpdateManyWithWhereWithoutProteinInput>
    deleteMany?: Enumerable<MeasurementScalarWhereInput>
  }

  export type NutritionFactUncheckedUpdateManyWithoutProteinInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutProteinInput>, Enumerable<NutritionFactUncheckedCreateWithoutProteinInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutProteinInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutProteinInput>
    createMany?: NutritionFactCreateManyProteinInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutProteinInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutProteinInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type MeasurementCreateNestedManyWithoutCholesterolInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutCholesterolInput>, Enumerable<MeasurementUncheckedCreateWithoutCholesterolInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutCholesterolInput>
    createMany?: MeasurementCreateManyCholesterolInputEnvelope
    connect?: Enumerable<MeasurementWhereUniqueInput>
  }

  export type NutritionFactCreateNestedManyWithoutCholesterolInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutCholesterolInput>, Enumerable<NutritionFactUncheckedCreateWithoutCholesterolInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutCholesterolInput>
    createMany?: NutritionFactCreateManyCholesterolInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type MeasurementUncheckedCreateNestedManyWithoutCholesterolInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutCholesterolInput>, Enumerable<MeasurementUncheckedCreateWithoutCholesterolInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutCholesterolInput>
    createMany?: MeasurementCreateManyCholesterolInputEnvelope
    connect?: Enumerable<MeasurementWhereUniqueInput>
  }

  export type NutritionFactUncheckedCreateNestedManyWithoutCholesterolInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutCholesterolInput>, Enumerable<NutritionFactUncheckedCreateWithoutCholesterolInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutCholesterolInput>
    createMany?: NutritionFactCreateManyCholesterolInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type MeasurementUpdateManyWithoutCholesterolInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutCholesterolInput>, Enumerable<MeasurementUncheckedCreateWithoutCholesterolInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutCholesterolInput>
    upsert?: Enumerable<MeasurementUpsertWithWhereUniqueWithoutCholesterolInput>
    createMany?: MeasurementCreateManyCholesterolInputEnvelope
    set?: Enumerable<MeasurementWhereUniqueInput>
    disconnect?: Enumerable<MeasurementWhereUniqueInput>
    delete?: Enumerable<MeasurementWhereUniqueInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
    update?: Enumerable<MeasurementUpdateWithWhereUniqueWithoutCholesterolInput>
    updateMany?: Enumerable<MeasurementUpdateManyWithWhereWithoutCholesterolInput>
    deleteMany?: Enumerable<MeasurementScalarWhereInput>
  }

  export type NutritionFactUpdateManyWithoutCholesterolInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutCholesterolInput>, Enumerable<NutritionFactUncheckedCreateWithoutCholesterolInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutCholesterolInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutCholesterolInput>
    createMany?: NutritionFactCreateManyCholesterolInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutCholesterolInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutCholesterolInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type MeasurementUncheckedUpdateManyWithoutCholesterolInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutCholesterolInput>, Enumerable<MeasurementUncheckedCreateWithoutCholesterolInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutCholesterolInput>
    upsert?: Enumerable<MeasurementUpsertWithWhereUniqueWithoutCholesterolInput>
    createMany?: MeasurementCreateManyCholesterolInputEnvelope
    set?: Enumerable<MeasurementWhereUniqueInput>
    disconnect?: Enumerable<MeasurementWhereUniqueInput>
    delete?: Enumerable<MeasurementWhereUniqueInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
    update?: Enumerable<MeasurementUpdateWithWhereUniqueWithoutCholesterolInput>
    updateMany?: Enumerable<MeasurementUpdateManyWithWhereWithoutCholesterolInput>
    deleteMany?: Enumerable<MeasurementScalarWhereInput>
  }

  export type NutritionFactUncheckedUpdateManyWithoutCholesterolInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutCholesterolInput>, Enumerable<NutritionFactUncheckedCreateWithoutCholesterolInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutCholesterolInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutCholesterolInput>
    createMany?: NutritionFactCreateManyCholesterolInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutCholesterolInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutCholesterolInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type MeasurementCreateNestedManyWithoutCiberInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutCiberInput>, Enumerable<MeasurementUncheckedCreateWithoutCiberInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutCiberInput>
    createMany?: MeasurementCreateManyCiberInputEnvelope
    connect?: Enumerable<MeasurementWhereUniqueInput>
  }

  export type NutritionFactCreateNestedManyWithoutFiberInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutFiberInput>, Enumerable<NutritionFactUncheckedCreateWithoutFiberInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutFiberInput>
    createMany?: NutritionFactCreateManyFiberInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type MeasurementUncheckedCreateNestedManyWithoutCiberInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutCiberInput>, Enumerable<MeasurementUncheckedCreateWithoutCiberInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutCiberInput>
    createMany?: MeasurementCreateManyCiberInputEnvelope
    connect?: Enumerable<MeasurementWhereUniqueInput>
  }

  export type NutritionFactUncheckedCreateNestedManyWithoutFiberInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutFiberInput>, Enumerable<NutritionFactUncheckedCreateWithoutFiberInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutFiberInput>
    createMany?: NutritionFactCreateManyFiberInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type MeasurementUpdateManyWithoutCiberInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutCiberInput>, Enumerable<MeasurementUncheckedCreateWithoutCiberInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutCiberInput>
    upsert?: Enumerable<MeasurementUpsertWithWhereUniqueWithoutCiberInput>
    createMany?: MeasurementCreateManyCiberInputEnvelope
    set?: Enumerable<MeasurementWhereUniqueInput>
    disconnect?: Enumerable<MeasurementWhereUniqueInput>
    delete?: Enumerable<MeasurementWhereUniqueInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
    update?: Enumerable<MeasurementUpdateWithWhereUniqueWithoutCiberInput>
    updateMany?: Enumerable<MeasurementUpdateManyWithWhereWithoutCiberInput>
    deleteMany?: Enumerable<MeasurementScalarWhereInput>
  }

  export type NutritionFactUpdateManyWithoutFiberInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutFiberInput>, Enumerable<NutritionFactUncheckedCreateWithoutFiberInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutFiberInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutFiberInput>
    createMany?: NutritionFactCreateManyFiberInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutFiberInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutFiberInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type MeasurementUncheckedUpdateManyWithoutCiberInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutCiberInput>, Enumerable<MeasurementUncheckedCreateWithoutCiberInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutCiberInput>
    upsert?: Enumerable<MeasurementUpsertWithWhereUniqueWithoutCiberInput>
    createMany?: MeasurementCreateManyCiberInputEnvelope
    set?: Enumerable<MeasurementWhereUniqueInput>
    disconnect?: Enumerable<MeasurementWhereUniqueInput>
    delete?: Enumerable<MeasurementWhereUniqueInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
    update?: Enumerable<MeasurementUpdateWithWhereUniqueWithoutCiberInput>
    updateMany?: Enumerable<MeasurementUpdateManyWithWhereWithoutCiberInput>
    deleteMany?: Enumerable<MeasurementScalarWhereInput>
  }

  export type NutritionFactUncheckedUpdateManyWithoutFiberInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutFiberInput>, Enumerable<NutritionFactUncheckedCreateWithoutFiberInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutFiberInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutFiberInput>
    createMany?: NutritionFactCreateManyFiberInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutFiberInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutFiberInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type MeasurementCreateNestedManyWithoutCaterInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutCaterInput>, Enumerable<MeasurementUncheckedCreateWithoutCaterInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutCaterInput>
    createMany?: MeasurementCreateManyCaterInputEnvelope
    connect?: Enumerable<MeasurementWhereUniqueInput>
  }

  export type NutritionFactCreateNestedManyWithoutWaterInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutWaterInput>, Enumerable<NutritionFactUncheckedCreateWithoutWaterInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutWaterInput>
    createMany?: NutritionFactCreateManyWaterInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type MeasurementUncheckedCreateNestedManyWithoutCaterInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutCaterInput>, Enumerable<MeasurementUncheckedCreateWithoutCaterInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutCaterInput>
    createMany?: MeasurementCreateManyCaterInputEnvelope
    connect?: Enumerable<MeasurementWhereUniqueInput>
  }

  export type NutritionFactUncheckedCreateNestedManyWithoutWaterInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutWaterInput>, Enumerable<NutritionFactUncheckedCreateWithoutWaterInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutWaterInput>
    createMany?: NutritionFactCreateManyWaterInputEnvelope
    connect?: Enumerable<NutritionFactWhereUniqueInput>
  }

  export type MeasurementUpdateManyWithoutCaterInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutCaterInput>, Enumerable<MeasurementUncheckedCreateWithoutCaterInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutCaterInput>
    upsert?: Enumerable<MeasurementUpsertWithWhereUniqueWithoutCaterInput>
    createMany?: MeasurementCreateManyCaterInputEnvelope
    set?: Enumerable<MeasurementWhereUniqueInput>
    disconnect?: Enumerable<MeasurementWhereUniqueInput>
    delete?: Enumerable<MeasurementWhereUniqueInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
    update?: Enumerable<MeasurementUpdateWithWhereUniqueWithoutCaterInput>
    updateMany?: Enumerable<MeasurementUpdateManyWithWhereWithoutCaterInput>
    deleteMany?: Enumerable<MeasurementScalarWhereInput>
  }

  export type NutritionFactUpdateManyWithoutWaterInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutWaterInput>, Enumerable<NutritionFactUncheckedCreateWithoutWaterInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutWaterInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutWaterInput>
    createMany?: NutritionFactCreateManyWaterInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutWaterInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutWaterInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type MeasurementUncheckedUpdateManyWithoutCaterInput = {
    create?: XOR<Enumerable<MeasurementCreateWithoutCaterInput>, Enumerable<MeasurementUncheckedCreateWithoutCaterInput>>
    connectOrCreate?: Enumerable<MeasurementCreateOrConnectWithoutCaterInput>
    upsert?: Enumerable<MeasurementUpsertWithWhereUniqueWithoutCaterInput>
    createMany?: MeasurementCreateManyCaterInputEnvelope
    set?: Enumerable<MeasurementWhereUniqueInput>
    disconnect?: Enumerable<MeasurementWhereUniqueInput>
    delete?: Enumerable<MeasurementWhereUniqueInput>
    connect?: Enumerable<MeasurementWhereUniqueInput>
    update?: Enumerable<MeasurementUpdateWithWhereUniqueWithoutCaterInput>
    updateMany?: Enumerable<MeasurementUpdateManyWithWhereWithoutCaterInput>
    deleteMany?: Enumerable<MeasurementScalarWhereInput>
  }

  export type NutritionFactUncheckedUpdateManyWithoutWaterInput = {
    create?: XOR<Enumerable<NutritionFactCreateWithoutWaterInput>, Enumerable<NutritionFactUncheckedCreateWithoutWaterInput>>
    connectOrCreate?: Enumerable<NutritionFactCreateOrConnectWithoutWaterInput>
    upsert?: Enumerable<NutritionFactUpsertWithWhereUniqueWithoutWaterInput>
    createMany?: NutritionFactCreateManyWaterInputEnvelope
    set?: Enumerable<NutritionFactWhereUniqueInput>
    disconnect?: Enumerable<NutritionFactWhereUniqueInput>
    delete?: Enumerable<NutritionFactWhereUniqueInput>
    connect?: Enumerable<NutritionFactWhereUniqueInput>
    update?: Enumerable<NutritionFactUpdateWithWhereUniqueWithoutWaterInput>
    updateMany?: Enumerable<NutritionFactUpdateManyWithWhereWithoutWaterInput>
    deleteMany?: Enumerable<NutritionFactScalarWhereInput>
  }

  export type EnergyCreateNestedManyWithoutNutritionFactInput = {
    create?: XOR<Enumerable<EnergyCreateWithoutNutritionFactInput>, Enumerable<EnergyUncheckedCreateWithoutNutritionFactInput>>
    connectOrCreate?: Enumerable<EnergyCreateOrConnectWithoutNutritionFactInput>
    createMany?: EnergyCreateManyNutritionFactInputEnvelope
    connect?: Enumerable<EnergyWhereUniqueInput>
  }

  export type ProteinCreateNestedOneWithoutNutritionFactInput = {
    create?: XOR<ProteinCreateWithoutNutritionFactInput, ProteinUncheckedCreateWithoutNutritionFactInput>
    connectOrCreate?: ProteinCreateOrConnectWithoutNutritionFactInput
    connect?: ProteinWhereUniqueInput
  }

  export type FatCreateNestedOneWithoutNutritionFactsInput = {
    create?: XOR<FatCreateWithoutNutritionFactsInput, FatUncheckedCreateWithoutNutritionFactsInput>
    connectOrCreate?: FatCreateOrConnectWithoutNutritionFactsInput
    connect?: FatWhereUniqueInput
  }

  export type CarbohydrateCreateNestedOneWithoutNutritionFactsInput = {
    create?: XOR<CarbohydrateCreateWithoutNutritionFactsInput, CarbohydrateUncheckedCreateWithoutNutritionFactsInput>
    connectOrCreate?: CarbohydrateCreateOrConnectWithoutNutritionFactsInput
    connect?: CarbohydrateWhereUniqueInput
  }

  export type FiberCreateNestedOneWithoutNutritionFactInput = {
    create?: XOR<FiberCreateWithoutNutritionFactInput, FiberUncheckedCreateWithoutNutritionFactInput>
    connectOrCreate?: FiberCreateOrConnectWithoutNutritionFactInput
    connect?: FiberWhereUniqueInput
  }

  export type WaterCreateNestedOneWithoutNutritionFactInput = {
    create?: XOR<WaterCreateWithoutNutritionFactInput, WaterUncheckedCreateWithoutNutritionFactInput>
    connectOrCreate?: WaterCreateOrConnectWithoutNutritionFactInput
    connect?: WaterWhereUniqueInput
  }

  export type VitaminCreateNestedOneWithoutNutritionFactsInput = {
    create?: XOR<VitaminCreateWithoutNutritionFactsInput, VitaminUncheckedCreateWithoutNutritionFactsInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutNutritionFactsInput
    connect?: VitaminWhereUniqueInput
  }

  export type MineralCreateNestedOneWithoutNutritionFactInput = {
    create?: XOR<MineralCreateWithoutNutritionFactInput, MineralUncheckedCreateWithoutNutritionFactInput>
    connectOrCreate?: MineralCreateOrConnectWithoutNutritionFactInput
    connect?: MineralWhereUniqueInput
  }

  export type CholesterolCreateNestedOneWithoutNutritionFactInput = {
    create?: XOR<CholesterolCreateWithoutNutritionFactInput, CholesterolUncheckedCreateWithoutNutritionFactInput>
    connectOrCreate?: CholesterolCreateOrConnectWithoutNutritionFactInput
    connect?: CholesterolWhereUniqueInput
  }

  export type ProductCreateNestedOneWithoutNutritionFactInput = {
    create?: XOR<ProductCreateWithoutNutritionFactInput, ProductUncheckedCreateWithoutNutritionFactInput>
    connectOrCreate?: ProductCreateOrConnectWithoutNutritionFactInput
    connect?: ProductWhereUniqueInput
  }

  export type EnergyUncheckedCreateNestedManyWithoutNutritionFactInput = {
    create?: XOR<Enumerable<EnergyCreateWithoutNutritionFactInput>, Enumerable<EnergyUncheckedCreateWithoutNutritionFactInput>>
    connectOrCreate?: Enumerable<EnergyCreateOrConnectWithoutNutritionFactInput>
    createMany?: EnergyCreateManyNutritionFactInputEnvelope
    connect?: Enumerable<EnergyWhereUniqueInput>
  }

  export type EnergyUpdateManyWithoutNutritionFactInput = {
    create?: XOR<Enumerable<EnergyCreateWithoutNutritionFactInput>, Enumerable<EnergyUncheckedCreateWithoutNutritionFactInput>>
    connectOrCreate?: Enumerable<EnergyCreateOrConnectWithoutNutritionFactInput>
    upsert?: Enumerable<EnergyUpsertWithWhereUniqueWithoutNutritionFactInput>
    createMany?: EnergyCreateManyNutritionFactInputEnvelope
    set?: Enumerable<EnergyWhereUniqueInput>
    disconnect?: Enumerable<EnergyWhereUniqueInput>
    delete?: Enumerable<EnergyWhereUniqueInput>
    connect?: Enumerable<EnergyWhereUniqueInput>
    update?: Enumerable<EnergyUpdateWithWhereUniqueWithoutNutritionFactInput>
    updateMany?: Enumerable<EnergyUpdateManyWithWhereWithoutNutritionFactInput>
    deleteMany?: Enumerable<EnergyScalarWhereInput>
  }

  export type ProteinUpdateOneWithoutNutritionFactInput = {
    create?: XOR<ProteinCreateWithoutNutritionFactInput, ProteinUncheckedCreateWithoutNutritionFactInput>
    connectOrCreate?: ProteinCreateOrConnectWithoutNutritionFactInput
    upsert?: ProteinUpsertWithoutNutritionFactInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProteinWhereUniqueInput
    update?: XOR<ProteinUpdateWithoutNutritionFactInput, ProteinUncheckedUpdateWithoutNutritionFactInput>
  }

  export type FatUpdateOneWithoutNutritionFactsInput = {
    create?: XOR<FatCreateWithoutNutritionFactsInput, FatUncheckedCreateWithoutNutritionFactsInput>
    connectOrCreate?: FatCreateOrConnectWithoutNutritionFactsInput
    upsert?: FatUpsertWithoutNutritionFactsInput
    disconnect?: boolean
    delete?: boolean
    connect?: FatWhereUniqueInput
    update?: XOR<FatUpdateWithoutNutritionFactsInput, FatUncheckedUpdateWithoutNutritionFactsInput>
  }

  export type CarbohydrateUpdateOneWithoutNutritionFactsInput = {
    create?: XOR<CarbohydrateCreateWithoutNutritionFactsInput, CarbohydrateUncheckedCreateWithoutNutritionFactsInput>
    connectOrCreate?: CarbohydrateCreateOrConnectWithoutNutritionFactsInput
    upsert?: CarbohydrateUpsertWithoutNutritionFactsInput
    disconnect?: boolean
    delete?: boolean
    connect?: CarbohydrateWhereUniqueInput
    update?: XOR<CarbohydrateUpdateWithoutNutritionFactsInput, CarbohydrateUncheckedUpdateWithoutNutritionFactsInput>
  }

  export type FiberUpdateOneWithoutNutritionFactInput = {
    create?: XOR<FiberCreateWithoutNutritionFactInput, FiberUncheckedCreateWithoutNutritionFactInput>
    connectOrCreate?: FiberCreateOrConnectWithoutNutritionFactInput
    upsert?: FiberUpsertWithoutNutritionFactInput
    disconnect?: boolean
    delete?: boolean
    connect?: FiberWhereUniqueInput
    update?: XOR<FiberUpdateWithoutNutritionFactInput, FiberUncheckedUpdateWithoutNutritionFactInput>
  }

  export type WaterUpdateOneWithoutNutritionFactInput = {
    create?: XOR<WaterCreateWithoutNutritionFactInput, WaterUncheckedCreateWithoutNutritionFactInput>
    connectOrCreate?: WaterCreateOrConnectWithoutNutritionFactInput
    upsert?: WaterUpsertWithoutNutritionFactInput
    disconnect?: boolean
    delete?: boolean
    connect?: WaterWhereUniqueInput
    update?: XOR<WaterUpdateWithoutNutritionFactInput, WaterUncheckedUpdateWithoutNutritionFactInput>
  }

  export type VitaminUpdateOneWithoutNutritionFactsInput = {
    create?: XOR<VitaminCreateWithoutNutritionFactsInput, VitaminUncheckedCreateWithoutNutritionFactsInput>
    connectOrCreate?: VitaminCreateOrConnectWithoutNutritionFactsInput
    upsert?: VitaminUpsertWithoutNutritionFactsInput
    disconnect?: boolean
    delete?: boolean
    connect?: VitaminWhereUniqueInput
    update?: XOR<VitaminUpdateWithoutNutritionFactsInput, VitaminUncheckedUpdateWithoutNutritionFactsInput>
  }

  export type MineralUpdateOneWithoutNutritionFactInput = {
    create?: XOR<MineralCreateWithoutNutritionFactInput, MineralUncheckedCreateWithoutNutritionFactInput>
    connectOrCreate?: MineralCreateOrConnectWithoutNutritionFactInput
    upsert?: MineralUpsertWithoutNutritionFactInput
    disconnect?: boolean
    delete?: boolean
    connect?: MineralWhereUniqueInput
    update?: XOR<MineralUpdateWithoutNutritionFactInput, MineralUncheckedUpdateWithoutNutritionFactInput>
  }

  export type CholesterolUpdateOneWithoutNutritionFactInput = {
    create?: XOR<CholesterolCreateWithoutNutritionFactInput, CholesterolUncheckedCreateWithoutNutritionFactInput>
    connectOrCreate?: CholesterolCreateOrConnectWithoutNutritionFactInput
    upsert?: CholesterolUpsertWithoutNutritionFactInput
    disconnect?: boolean
    delete?: boolean
    connect?: CholesterolWhereUniqueInput
    update?: XOR<CholesterolUpdateWithoutNutritionFactInput, CholesterolUncheckedUpdateWithoutNutritionFactInput>
  }

  export type ProductUpdateOneWithoutNutritionFactInput = {
    create?: XOR<ProductCreateWithoutNutritionFactInput, ProductUncheckedCreateWithoutNutritionFactInput>
    connectOrCreate?: ProductCreateOrConnectWithoutNutritionFactInput
    upsert?: ProductUpsertWithoutNutritionFactInput
    disconnect?: boolean
    delete?: boolean
    connect?: ProductWhereUniqueInput
    update?: XOR<ProductUpdateWithoutNutritionFactInput, ProductUncheckedUpdateWithoutNutritionFactInput>
  }

  export type EnergyUncheckedUpdateManyWithoutNutritionFactInput = {
    create?: XOR<Enumerable<EnergyCreateWithoutNutritionFactInput>, Enumerable<EnergyUncheckedCreateWithoutNutritionFactInput>>
    connectOrCreate?: Enumerable<EnergyCreateOrConnectWithoutNutritionFactInput>
    upsert?: Enumerable<EnergyUpsertWithWhereUniqueWithoutNutritionFactInput>
    createMany?: EnergyCreateManyNutritionFactInputEnvelope
    set?: Enumerable<EnergyWhereUniqueInput>
    disconnect?: Enumerable<EnergyWhereUniqueInput>
    delete?: Enumerable<EnergyWhereUniqueInput>
    connect?: Enumerable<EnergyWhereUniqueInput>
    update?: Enumerable<EnergyUpdateWithWhereUniqueWithoutNutritionFactInput>
    updateMany?: Enumerable<EnergyUpdateManyWithWhereWithoutNutritionFactInput>
    deleteMany?: Enumerable<EnergyScalarWhereInput>
  }

  export type LabelCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<LabelCreateWithoutProductsInput>, Enumerable<LabelUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<LabelWhereUniqueInput>
  }

  export type ServingCreateNestedOneWithoutProductsInput = {
    create?: XOR<ServingCreateWithoutProductsInput, ServingUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ServingCreateOrConnectWithoutProductsInput
    connect?: ServingWhereUniqueInput
  }

  export type NutritionFactCreateNestedOneWithoutProductInput = {
    create?: XOR<NutritionFactCreateWithoutProductInput, NutritionFactUncheckedCreateWithoutProductInput>
    connectOrCreate?: NutritionFactCreateOrConnectWithoutProductInput
    connect?: NutritionFactWhereUniqueInput
  }

  export type LabelUncheckedCreateNestedManyWithoutProductsInput = {
    create?: XOR<Enumerable<LabelCreateWithoutProductsInput>, Enumerable<LabelUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutProductsInput>
    connect?: Enumerable<LabelWhereUniqueInput>
  }

  export type NutritionFactUncheckedCreateNestedOneWithoutProductInput = {
    create?: XOR<NutritionFactCreateWithoutProductInput, NutritionFactUncheckedCreateWithoutProductInput>
    connectOrCreate?: NutritionFactCreateOrConnectWithoutProductInput
    connect?: NutritionFactWhereUniqueInput
  }

  export type LabelUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<LabelCreateWithoutProductsInput>, Enumerable<LabelUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<LabelUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<LabelWhereUniqueInput>
    disconnect?: Enumerable<LabelWhereUniqueInput>
    delete?: Enumerable<LabelWhereUniqueInput>
    connect?: Enumerable<LabelWhereUniqueInput>
    update?: Enumerable<LabelUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<LabelUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<LabelScalarWhereInput>
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type ServingUpdateOneRequiredWithoutProductsInput = {
    create?: XOR<ServingCreateWithoutProductsInput, ServingUncheckedCreateWithoutProductsInput>
    connectOrCreate?: ServingCreateOrConnectWithoutProductsInput
    upsert?: ServingUpsertWithoutProductsInput
    connect?: ServingWhereUniqueInput
    update?: XOR<ServingUpdateWithoutProductsInput, ServingUncheckedUpdateWithoutProductsInput>
  }

  export type NutritionFactUpdateOneWithoutProductInput = {
    create?: XOR<NutritionFactCreateWithoutProductInput, NutritionFactUncheckedCreateWithoutProductInput>
    connectOrCreate?: NutritionFactCreateOrConnectWithoutProductInput
    upsert?: NutritionFactUpsertWithoutProductInput
    disconnect?: boolean
    delete?: boolean
    connect?: NutritionFactWhereUniqueInput
    update?: XOR<NutritionFactUpdateWithoutProductInput, NutritionFactUncheckedUpdateWithoutProductInput>
  }

  export type LabelUncheckedUpdateManyWithoutProductsInput = {
    create?: XOR<Enumerable<LabelCreateWithoutProductsInput>, Enumerable<LabelUncheckedCreateWithoutProductsInput>>
    connectOrCreate?: Enumerable<LabelCreateOrConnectWithoutProductsInput>
    upsert?: Enumerable<LabelUpsertWithWhereUniqueWithoutProductsInput>
    set?: Enumerable<LabelWhereUniqueInput>
    disconnect?: Enumerable<LabelWhereUniqueInput>
    delete?: Enumerable<LabelWhereUniqueInput>
    connect?: Enumerable<LabelWhereUniqueInput>
    update?: Enumerable<LabelUpdateWithWhereUniqueWithoutProductsInput>
    updateMany?: Enumerable<LabelUpdateManyWithWhereWithoutProductsInput>
    deleteMany?: Enumerable<LabelScalarWhereInput>
  }

  export type NutritionFactUncheckedUpdateOneWithoutProductInput = {
    create?: XOR<NutritionFactCreateWithoutProductInput, NutritionFactUncheckedCreateWithoutProductInput>
    connectOrCreate?: NutritionFactCreateOrConnectWithoutProductInput
    upsert?: NutritionFactUpsertWithoutProductInput
    disconnect?: boolean
    delete?: boolean
    connect?: NutritionFactWhereUniqueInput
    update?: XOR<NutritionFactUpdateWithoutProductInput, NutritionFactUncheckedUpdateWithoutProductInput>
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number>
    notIn?: Enumerable<number>
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string>
    notIn?: Enumerable<string>
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | null
    notIn?: Enumerable<number> | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDecimalNullableFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableFilter | Decimal | number | string | null
  }

  export type NestedDecimalNullableWithAggregatesFilter = {
    equals?: Decimal | number | string | null
    in?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    notIn?: Enumerable<Decimal> | Enumerable<number> | Enumerable<string> | null
    lt?: Decimal | number | string
    lte?: Decimal | number | string
    gt?: Decimal | number | string
    gte?: Decimal | number | string
    not?: NestedDecimalNullableWithAggregatesFilter | Decimal | number | string | null
    _count?: NestedIntNullableFilter
    _avg?: NestedDecimalNullableFilter
    _sum?: NestedDecimalNullableFilter
    _min?: NestedDecimalNullableFilter
    _max?: NestedDecimalNullableFilter
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | null
    notIn?: Enumerable<string> | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type ProductCreateWithoutLabelsInput = {
    name: string
    ean?: string | null
    manufacturer: string
    group: string
    serving: ServingCreateNestedOneWithoutProductsInput
    nutritionFact?: NutritionFactCreateNestedOneWithoutProductInput
    nutritionFactId?: number | null
  }

  export type ProductUncheckedCreateWithoutLabelsInput = {
    id?: number
    name: string
    ean?: string | null
    manufacturer: string
    group: string
    servingId: number
    nutritionFact?: NutritionFactUncheckedCreateNestedOneWithoutProductInput
    nutritionFactId?: number | null
  }

  export type ProductCreateOrConnectWithoutLabelsInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutLabelsInput, ProductUncheckedCreateWithoutLabelsInput>
  }

  export type ProductUpsertWithWhereUniqueWithoutLabelsInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutLabelsInput, ProductUncheckedUpdateWithoutLabelsInput>
    create: XOR<ProductCreateWithoutLabelsInput, ProductUncheckedCreateWithoutLabelsInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutLabelsInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutLabelsInput, ProductUncheckedUpdateWithoutLabelsInput>
  }

  export type ProductUpdateManyWithWhereWithoutLabelsInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type ProductScalarWhereInput = {
    AND?: Enumerable<ProductScalarWhereInput>
    OR?: Enumerable<ProductScalarWhereInput>
    NOT?: Enumerable<ProductScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    ean?: StringNullableFilter | string | null
    manufacturer?: StringFilter | string
    group?: StringFilter | string
    servingId?: IntFilter | number
    nutritionFactId?: IntNullableFilter | number | null
  }

  export type TotalFatCreateWithoutFatInput = {
    measurement?: MeasurementCreateNestedOneWithoutTotalFatInput
  }

  export type TotalFatUncheckedCreateWithoutFatInput = {
    id?: number
    measurementId: number
  }

  export type TotalFatCreateOrConnectWithoutFatInput = {
    where: TotalFatWhereUniqueInput
    create: XOR<TotalFatCreateWithoutFatInput, TotalFatUncheckedCreateWithoutFatInput>
  }

  export type SaturatedFatCreateWithoutFatInput = {
    measurement: MeasurementCreateNestedOneWithoutSaturatedFatInput
  }

  export type SaturatedFatUncheckedCreateWithoutFatInput = {
    id?: number
    measurementId: number
  }

  export type SaturatedFatCreateOrConnectWithoutFatInput = {
    where: SaturatedFatWhereUniqueInput
    create: XOR<SaturatedFatCreateWithoutFatInput, SaturatedFatUncheckedCreateWithoutFatInput>
  }

  export type MonosaturatedFatCreateWithoutFatInput = {
    measurement: MeasurementCreateNestedOneWithoutMonosaturatedFatInput
  }

  export type MonosaturatedFatUncheckedCreateWithoutFatInput = {
    id?: number
    measurementId: number
  }

  export type MonosaturatedFatCreateOrConnectWithoutFatInput = {
    where: MonosaturatedFatWhereUniqueInput
    create: XOR<MonosaturatedFatCreateWithoutFatInput, MonosaturatedFatUncheckedCreateWithoutFatInput>
  }

  export type PolyunsaturatedFatCreateWithoutFatInput = {
    measurement: MeasurementCreateNestedOneWithoutPolyunsaturatedFatInput
  }

  export type PolyunsaturatedFatUncheckedCreateWithoutFatInput = {
    id?: number
    measurementId: number
  }

  export type PolyunsaturatedFatCreateOrConnectWithoutFatInput = {
    where: PolyunsaturatedFatWhereUniqueInput
    create: XOR<PolyunsaturatedFatCreateWithoutFatInput, PolyunsaturatedFatUncheckedCreateWithoutFatInput>
  }

  export type TransFatCreateWithoutFatInput = {
    measurement: MeasurementCreateNestedOneWithoutTransFatInput
  }

  export type TransFatUncheckedCreateWithoutFatInput = {
    id?: number
    measurementId: number
  }

  export type TransFatCreateOrConnectWithoutFatInput = {
    where: TransFatWhereUniqueInput
    create: XOR<TransFatCreateWithoutFatInput, TransFatUncheckedCreateWithoutFatInput>
  }

  export type NutritionFactCreateWithoutFatsInput = {
    energy?: EnergyCreateNestedManyWithoutNutritionFactInput
    protein?: ProteinCreateNestedOneWithoutNutritionFactInput
    carbohydrate?: CarbohydrateCreateNestedOneWithoutNutritionFactsInput
    fiber?: FiberCreateNestedOneWithoutNutritionFactInput
    water?: WaterCreateNestedOneWithoutNutritionFactInput
    vitamins?: VitaminCreateNestedOneWithoutNutritionFactsInput
    minerals?: MineralCreateNestedOneWithoutNutritionFactInput
    cholesterol?: CholesterolCreateNestedOneWithoutNutritionFactInput
    product?: ProductCreateNestedOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedCreateWithoutFatsInput = {
    id?: number
    energy?: EnergyUncheckedCreateNestedManyWithoutNutritionFactInput
    proteinId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type NutritionFactCreateOrConnectWithoutFatsInput = {
    where: NutritionFactWhereUniqueInput
    create: XOR<NutritionFactCreateWithoutFatsInput, NutritionFactUncheckedCreateWithoutFatsInput>
  }

  export type NutritionFactCreateManyFatsInputEnvelope = {
    data: Enumerable<NutritionFactCreateManyFatsInput>
    skipDuplicates?: boolean
  }

  export type TotalFatUpsertWithoutFatInput = {
    update: XOR<TotalFatUpdateWithoutFatInput, TotalFatUncheckedUpdateWithoutFatInput>
    create: XOR<TotalFatCreateWithoutFatInput, TotalFatUncheckedCreateWithoutFatInput>
  }

  export type TotalFatUpdateWithoutFatInput = {
    measurement?: MeasurementUpdateOneWithoutTotalFatInput
  }

  export type TotalFatUncheckedUpdateWithoutFatInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type SaturatedFatUpsertWithoutFatInput = {
    update: XOR<SaturatedFatUpdateWithoutFatInput, SaturatedFatUncheckedUpdateWithoutFatInput>
    create: XOR<SaturatedFatCreateWithoutFatInput, SaturatedFatUncheckedCreateWithoutFatInput>
  }

  export type SaturatedFatUpdateWithoutFatInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutSaturatedFatInput
  }

  export type SaturatedFatUncheckedUpdateWithoutFatInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type MonosaturatedFatUpsertWithoutFatInput = {
    update: XOR<MonosaturatedFatUpdateWithoutFatInput, MonosaturatedFatUncheckedUpdateWithoutFatInput>
    create: XOR<MonosaturatedFatCreateWithoutFatInput, MonosaturatedFatUncheckedCreateWithoutFatInput>
  }

  export type MonosaturatedFatUpdateWithoutFatInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutMonosaturatedFatInput
  }

  export type MonosaturatedFatUncheckedUpdateWithoutFatInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type PolyunsaturatedFatUpsertWithoutFatInput = {
    update: XOR<PolyunsaturatedFatUpdateWithoutFatInput, PolyunsaturatedFatUncheckedUpdateWithoutFatInput>
    create: XOR<PolyunsaturatedFatCreateWithoutFatInput, PolyunsaturatedFatUncheckedCreateWithoutFatInput>
  }

  export type PolyunsaturatedFatUpdateWithoutFatInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutPolyunsaturatedFatInput
  }

  export type PolyunsaturatedFatUncheckedUpdateWithoutFatInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type TransFatUpsertWithoutFatInput = {
    update: XOR<TransFatUpdateWithoutFatInput, TransFatUncheckedUpdateWithoutFatInput>
    create: XOR<TransFatCreateWithoutFatInput, TransFatUncheckedCreateWithoutFatInput>
  }

  export type TransFatUpdateWithoutFatInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutTransFatInput
  }

  export type TransFatUncheckedUpdateWithoutFatInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type NutritionFactUpsertWithWhereUniqueWithoutFatsInput = {
    where: NutritionFactWhereUniqueInput
    update: XOR<NutritionFactUpdateWithoutFatsInput, NutritionFactUncheckedUpdateWithoutFatsInput>
    create: XOR<NutritionFactCreateWithoutFatsInput, NutritionFactUncheckedCreateWithoutFatsInput>
  }

  export type NutritionFactUpdateWithWhereUniqueWithoutFatsInput = {
    where: NutritionFactWhereUniqueInput
    data: XOR<NutritionFactUpdateWithoutFatsInput, NutritionFactUncheckedUpdateWithoutFatsInput>
  }

  export type NutritionFactUpdateManyWithWhereWithoutFatsInput = {
    where: NutritionFactScalarWhereInput
    data: XOR<NutritionFactUpdateManyMutationInput, NutritionFactUncheckedUpdateManyWithoutNutritionFactsInput>
  }

  export type NutritionFactScalarWhereInput = {
    AND?: Enumerable<NutritionFactScalarWhereInput>
    OR?: Enumerable<NutritionFactScalarWhereInput>
    NOT?: Enumerable<NutritionFactScalarWhereInput>
    id?: IntFilter | number
    proteinId?: IntNullableFilter | number | null
    fatId?: IntNullableFilter | number | null
    carbohydrateId?: IntNullableFilter | number | null
    fiberId?: IntNullableFilter | number | null
    vitaminId?: IntNullableFilter | number | null
    mineralId?: IntNullableFilter | number | null
    cholesterolId?: IntNullableFilter | number | null
    waterId?: IntNullableFilter | number | null
    productId?: IntNullableFilter | number | null
  }

  export type MeasurementCreateWithoutTotalFatInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutTotalFatInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutTotalFatInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutTotalFatInput, MeasurementUncheckedCreateWithoutTotalFatInput>
  }

  export type FatCreateWithoutTotalInput = {
    saturated?: SaturatedFatCreateNestedOneWithoutFatInput
    monounsaturated?: MonosaturatedFatCreateNestedOneWithoutFatInput
    polyunsaturated?: PolyunsaturatedFatCreateNestedOneWithoutFatInput
    trans?: TransFatCreateNestedOneWithoutFatInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutFatsInput
  }

  export type FatUncheckedCreateWithoutTotalInput = {
    id?: number
    saturatedFatId?: number | null
    monosaturatedFatId?: number | null
    polyunsaturatedFatId?: number | null
    transFatId?: number | null
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutFatsInput
  }

  export type FatCreateOrConnectWithoutTotalInput = {
    where: FatWhereUniqueInput
    create: XOR<FatCreateWithoutTotalInput, FatUncheckedCreateWithoutTotalInput>
  }

  export type MeasurementUpsertWithoutTotalFatInput = {
    update: XOR<MeasurementUpdateWithoutTotalFatInput, MeasurementUncheckedUpdateWithoutTotalFatInput>
    create: XOR<MeasurementCreateWithoutTotalFatInput, MeasurementUncheckedCreateWithoutTotalFatInput>
  }

  export type MeasurementUpdateWithoutTotalFatInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutTotalFatInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FatUpsertWithoutTotalInput = {
    update: XOR<FatUpdateWithoutTotalInput, FatUncheckedUpdateWithoutTotalInput>
    create: XOR<FatCreateWithoutTotalInput, FatUncheckedCreateWithoutTotalInput>
  }

  export type FatUpdateWithoutTotalInput = {
    saturated?: SaturatedFatUpdateOneWithoutFatInput
    monounsaturated?: MonosaturatedFatUpdateOneWithoutFatInput
    polyunsaturated?: PolyunsaturatedFatUpdateOneWithoutFatInput
    trans?: TransFatUpdateOneWithoutFatInput
    nutritionFacts?: NutritionFactUpdateManyWithoutFatsInput
  }

  export type FatUncheckedUpdateWithoutTotalInput = {
    id?: IntFieldUpdateOperationsInput | number
    saturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    monosaturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    polyunsaturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    transFatId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutFatsInput
  }

  export type MeasurementCreateWithoutSaturatedFatInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutSaturatedFatInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutSaturatedFatInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutSaturatedFatInput, MeasurementUncheckedCreateWithoutSaturatedFatInput>
  }

  export type FatCreateWithoutSaturatedInput = {
    total?: TotalFatCreateNestedOneWithoutFatInput
    monounsaturated?: MonosaturatedFatCreateNestedOneWithoutFatInput
    polyunsaturated?: PolyunsaturatedFatCreateNestedOneWithoutFatInput
    trans?: TransFatCreateNestedOneWithoutFatInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutFatsInput
  }

  export type FatUncheckedCreateWithoutSaturatedInput = {
    id?: number
    totalFatId: number
    monosaturatedFatId?: number | null
    polyunsaturatedFatId?: number | null
    transFatId?: number | null
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutFatsInput
  }

  export type FatCreateOrConnectWithoutSaturatedInput = {
    where: FatWhereUniqueInput
    create: XOR<FatCreateWithoutSaturatedInput, FatUncheckedCreateWithoutSaturatedInput>
  }

  export type MeasurementUpsertWithoutSaturatedFatInput = {
    update: XOR<MeasurementUpdateWithoutSaturatedFatInput, MeasurementUncheckedUpdateWithoutSaturatedFatInput>
    create: XOR<MeasurementCreateWithoutSaturatedFatInput, MeasurementUncheckedCreateWithoutSaturatedFatInput>
  }

  export type MeasurementUpdateWithoutSaturatedFatInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutSaturatedFatInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FatUpsertWithoutSaturatedInput = {
    update: XOR<FatUpdateWithoutSaturatedInput, FatUncheckedUpdateWithoutSaturatedInput>
    create: XOR<FatCreateWithoutSaturatedInput, FatUncheckedCreateWithoutSaturatedInput>
  }

  export type FatUpdateWithoutSaturatedInput = {
    total?: TotalFatUpdateOneWithoutFatInput
    monounsaturated?: MonosaturatedFatUpdateOneWithoutFatInput
    polyunsaturated?: PolyunsaturatedFatUpdateOneWithoutFatInput
    trans?: TransFatUpdateOneWithoutFatInput
    nutritionFacts?: NutritionFactUpdateManyWithoutFatsInput
  }

  export type FatUncheckedUpdateWithoutSaturatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalFatId?: IntFieldUpdateOperationsInput | number
    monosaturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    polyunsaturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    transFatId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutFatsInput
  }

  export type MeasurementCreateWithoutMonosaturatedFatInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutMonosaturatedFatInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutMonosaturatedFatInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutMonosaturatedFatInput, MeasurementUncheckedCreateWithoutMonosaturatedFatInput>
  }

  export type FatCreateWithoutMonounsaturatedInput = {
    total?: TotalFatCreateNestedOneWithoutFatInput
    saturated?: SaturatedFatCreateNestedOneWithoutFatInput
    polyunsaturated?: PolyunsaturatedFatCreateNestedOneWithoutFatInput
    trans?: TransFatCreateNestedOneWithoutFatInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutFatsInput
  }

  export type FatUncheckedCreateWithoutMonounsaturatedInput = {
    id?: number
    totalFatId: number
    saturatedFatId?: number | null
    polyunsaturatedFatId?: number | null
    transFatId?: number | null
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutFatsInput
  }

  export type FatCreateOrConnectWithoutMonounsaturatedInput = {
    where: FatWhereUniqueInput
    create: XOR<FatCreateWithoutMonounsaturatedInput, FatUncheckedCreateWithoutMonounsaturatedInput>
  }

  export type MeasurementUpsertWithoutMonosaturatedFatInput = {
    update: XOR<MeasurementUpdateWithoutMonosaturatedFatInput, MeasurementUncheckedUpdateWithoutMonosaturatedFatInput>
    create: XOR<MeasurementCreateWithoutMonosaturatedFatInput, MeasurementUncheckedCreateWithoutMonosaturatedFatInput>
  }

  export type MeasurementUpdateWithoutMonosaturatedFatInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutMonosaturatedFatInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FatUpsertWithoutMonounsaturatedInput = {
    update: XOR<FatUpdateWithoutMonounsaturatedInput, FatUncheckedUpdateWithoutMonounsaturatedInput>
    create: XOR<FatCreateWithoutMonounsaturatedInput, FatUncheckedCreateWithoutMonounsaturatedInput>
  }

  export type FatUpdateWithoutMonounsaturatedInput = {
    total?: TotalFatUpdateOneWithoutFatInput
    saturated?: SaturatedFatUpdateOneWithoutFatInput
    polyunsaturated?: PolyunsaturatedFatUpdateOneWithoutFatInput
    trans?: TransFatUpdateOneWithoutFatInput
    nutritionFacts?: NutritionFactUpdateManyWithoutFatsInput
  }

  export type FatUncheckedUpdateWithoutMonounsaturatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalFatId?: IntFieldUpdateOperationsInput | number
    saturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    polyunsaturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    transFatId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutFatsInput
  }

  export type MeasurementCreateWithoutPolyunsaturatedFatInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutPolyunsaturatedFatInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutPolyunsaturatedFatInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutPolyunsaturatedFatInput, MeasurementUncheckedCreateWithoutPolyunsaturatedFatInput>
  }

  export type FatCreateWithoutPolyunsaturatedInput = {
    total?: TotalFatCreateNestedOneWithoutFatInput
    saturated?: SaturatedFatCreateNestedOneWithoutFatInput
    monounsaturated?: MonosaturatedFatCreateNestedOneWithoutFatInput
    trans?: TransFatCreateNestedOneWithoutFatInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutFatsInput
  }

  export type FatUncheckedCreateWithoutPolyunsaturatedInput = {
    id?: number
    totalFatId: number
    saturatedFatId?: number | null
    monosaturatedFatId?: number | null
    transFatId?: number | null
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutFatsInput
  }

  export type FatCreateOrConnectWithoutPolyunsaturatedInput = {
    where: FatWhereUniqueInput
    create: XOR<FatCreateWithoutPolyunsaturatedInput, FatUncheckedCreateWithoutPolyunsaturatedInput>
  }

  export type MeasurementUpsertWithoutPolyunsaturatedFatInput = {
    update: XOR<MeasurementUpdateWithoutPolyunsaturatedFatInput, MeasurementUncheckedUpdateWithoutPolyunsaturatedFatInput>
    create: XOR<MeasurementCreateWithoutPolyunsaturatedFatInput, MeasurementUncheckedCreateWithoutPolyunsaturatedFatInput>
  }

  export type MeasurementUpdateWithoutPolyunsaturatedFatInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutPolyunsaturatedFatInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FatUpsertWithoutPolyunsaturatedInput = {
    update: XOR<FatUpdateWithoutPolyunsaturatedInput, FatUncheckedUpdateWithoutPolyunsaturatedInput>
    create: XOR<FatCreateWithoutPolyunsaturatedInput, FatUncheckedCreateWithoutPolyunsaturatedInput>
  }

  export type FatUpdateWithoutPolyunsaturatedInput = {
    total?: TotalFatUpdateOneWithoutFatInput
    saturated?: SaturatedFatUpdateOneWithoutFatInput
    monounsaturated?: MonosaturatedFatUpdateOneWithoutFatInput
    trans?: TransFatUpdateOneWithoutFatInput
    nutritionFacts?: NutritionFactUpdateManyWithoutFatsInput
  }

  export type FatUncheckedUpdateWithoutPolyunsaturatedInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalFatId?: IntFieldUpdateOperationsInput | number
    saturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    monosaturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    transFatId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutFatsInput
  }

  export type MeasurementCreateWithoutTransFatInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutTransFatInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutTransFatInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutTransFatInput, MeasurementUncheckedCreateWithoutTransFatInput>
  }

  export type FatCreateWithoutTransInput = {
    total?: TotalFatCreateNestedOneWithoutFatInput
    saturated?: SaturatedFatCreateNestedOneWithoutFatInput
    monounsaturated?: MonosaturatedFatCreateNestedOneWithoutFatInput
    polyunsaturated?: PolyunsaturatedFatCreateNestedOneWithoutFatInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutFatsInput
  }

  export type FatUncheckedCreateWithoutTransInput = {
    id?: number
    totalFatId: number
    saturatedFatId?: number | null
    monosaturatedFatId?: number | null
    polyunsaturatedFatId?: number | null
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutFatsInput
  }

  export type FatCreateOrConnectWithoutTransInput = {
    where: FatWhereUniqueInput
    create: XOR<FatCreateWithoutTransInput, FatUncheckedCreateWithoutTransInput>
  }

  export type MeasurementUpsertWithoutTransFatInput = {
    update: XOR<MeasurementUpdateWithoutTransFatInput, MeasurementUncheckedUpdateWithoutTransFatInput>
    create: XOR<MeasurementCreateWithoutTransFatInput, MeasurementUncheckedCreateWithoutTransFatInput>
  }

  export type MeasurementUpdateWithoutTransFatInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutTransFatInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FatUpsertWithoutTransInput = {
    update: XOR<FatUpdateWithoutTransInput, FatUncheckedUpdateWithoutTransInput>
    create: XOR<FatCreateWithoutTransInput, FatUncheckedCreateWithoutTransInput>
  }

  export type FatUpdateWithoutTransInput = {
    total?: TotalFatUpdateOneWithoutFatInput
    saturated?: SaturatedFatUpdateOneWithoutFatInput
    monounsaturated?: MonosaturatedFatUpdateOneWithoutFatInput
    polyunsaturated?: PolyunsaturatedFatUpdateOneWithoutFatInput
    nutritionFacts?: NutritionFactUpdateManyWithoutFatsInput
  }

  export type FatUncheckedUpdateWithoutTransInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalFatId?: IntFieldUpdateOperationsInput | number
    saturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    monosaturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    polyunsaturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutFatsInput
  }

  export type TotalCarbohydrateCreateWithoutCarbohydrateInput = {
    measurement: MeasurementCreateNestedOneWithoutTotalCarbohydrateInput
  }

  export type TotalCarbohydrateUncheckedCreateWithoutCarbohydrateInput = {
    id?: number
    measurementId: number
  }

  export type TotalCarbohydrateCreateOrConnectWithoutCarbohydrateInput = {
    where: TotalCarbohydrateWhereUniqueInput
    create: XOR<TotalCarbohydrateCreateWithoutCarbohydrateInput, TotalCarbohydrateUncheckedCreateWithoutCarbohydrateInput>
  }

  export type SugarCarbohydrateCreateWithoutCarbohydrateInput = {
    measurement: MeasurementCreateNestedOneWithoutSugarCarbohydrateInput
  }

  export type SugarCarbohydrateUncheckedCreateWithoutCarbohydrateInput = {
    id?: number
    measurementId: number
  }

  export type SugarCarbohydrateCreateOrConnectWithoutCarbohydrateInput = {
    where: SugarCarbohydrateWhereUniqueInput
    create: XOR<SugarCarbohydrateCreateWithoutCarbohydrateInput, SugarCarbohydrateUncheckedCreateWithoutCarbohydrateInput>
  }

  export type NutritionFactCreateWithoutCarbohydrateInput = {
    energy?: EnergyCreateNestedManyWithoutNutritionFactInput
    protein?: ProteinCreateNestedOneWithoutNutritionFactInput
    fats?: FatCreateNestedOneWithoutNutritionFactsInput
    fiber?: FiberCreateNestedOneWithoutNutritionFactInput
    water?: WaterCreateNestedOneWithoutNutritionFactInput
    vitamins?: VitaminCreateNestedOneWithoutNutritionFactsInput
    minerals?: MineralCreateNestedOneWithoutNutritionFactInput
    cholesterol?: CholesterolCreateNestedOneWithoutNutritionFactInput
    product?: ProductCreateNestedOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedCreateWithoutCarbohydrateInput = {
    id?: number
    energy?: EnergyUncheckedCreateNestedManyWithoutNutritionFactInput
    proteinId?: number | null
    fatId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type NutritionFactCreateOrConnectWithoutCarbohydrateInput = {
    where: NutritionFactWhereUniqueInput
    create: XOR<NutritionFactCreateWithoutCarbohydrateInput, NutritionFactUncheckedCreateWithoutCarbohydrateInput>
  }

  export type NutritionFactCreateManyCarbohydrateInputEnvelope = {
    data: Enumerable<NutritionFactCreateManyCarbohydrateInput>
    skipDuplicates?: boolean
  }

  export type TotalCarbohydrateUpsertWithoutCarbohydrateInput = {
    update: XOR<TotalCarbohydrateUpdateWithoutCarbohydrateInput, TotalCarbohydrateUncheckedUpdateWithoutCarbohydrateInput>
    create: XOR<TotalCarbohydrateCreateWithoutCarbohydrateInput, TotalCarbohydrateUncheckedCreateWithoutCarbohydrateInput>
  }

  export type TotalCarbohydrateUpdateWithoutCarbohydrateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutTotalCarbohydrateInput
  }

  export type TotalCarbohydrateUncheckedUpdateWithoutCarbohydrateInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type SugarCarbohydrateUpsertWithoutCarbohydrateInput = {
    update: XOR<SugarCarbohydrateUpdateWithoutCarbohydrateInput, SugarCarbohydrateUncheckedUpdateWithoutCarbohydrateInput>
    create: XOR<SugarCarbohydrateCreateWithoutCarbohydrateInput, SugarCarbohydrateUncheckedCreateWithoutCarbohydrateInput>
  }

  export type SugarCarbohydrateUpdateWithoutCarbohydrateInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutSugarCarbohydrateInput
  }

  export type SugarCarbohydrateUncheckedUpdateWithoutCarbohydrateInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type NutritionFactUpsertWithWhereUniqueWithoutCarbohydrateInput = {
    where: NutritionFactWhereUniqueInput
    update: XOR<NutritionFactUpdateWithoutCarbohydrateInput, NutritionFactUncheckedUpdateWithoutCarbohydrateInput>
    create: XOR<NutritionFactCreateWithoutCarbohydrateInput, NutritionFactUncheckedCreateWithoutCarbohydrateInput>
  }

  export type NutritionFactUpdateWithWhereUniqueWithoutCarbohydrateInput = {
    where: NutritionFactWhereUniqueInput
    data: XOR<NutritionFactUpdateWithoutCarbohydrateInput, NutritionFactUncheckedUpdateWithoutCarbohydrateInput>
  }

  export type NutritionFactUpdateManyWithWhereWithoutCarbohydrateInput = {
    where: NutritionFactScalarWhereInput
    data: XOR<NutritionFactUpdateManyMutationInput, NutritionFactUncheckedUpdateManyWithoutNutritionFactsInput>
  }

  export type MeasurementCreateWithoutTotalCarbohydrateInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutTotalCarbohydrateInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutTotalCarbohydrateInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutTotalCarbohydrateInput, MeasurementUncheckedCreateWithoutTotalCarbohydrateInput>
  }

  export type CarbohydrateCreateWithoutTotalInput = {
    sugar?: SugarCarbohydrateCreateNestedOneWithoutCarbohydrateInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutCarbohydrateInput
  }

  export type CarbohydrateUncheckedCreateWithoutTotalInput = {
    id?: number
    sugarCarbohydrateId?: number | null
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutCarbohydrateInput
  }

  export type CarbohydrateCreateOrConnectWithoutTotalInput = {
    where: CarbohydrateWhereUniqueInput
    create: XOR<CarbohydrateCreateWithoutTotalInput, CarbohydrateUncheckedCreateWithoutTotalInput>
  }

  export type MeasurementUpsertWithoutTotalCarbohydrateInput = {
    update: XOR<MeasurementUpdateWithoutTotalCarbohydrateInput, MeasurementUncheckedUpdateWithoutTotalCarbohydrateInput>
    create: XOR<MeasurementCreateWithoutTotalCarbohydrateInput, MeasurementUncheckedCreateWithoutTotalCarbohydrateInput>
  }

  export type MeasurementUpdateWithoutTotalCarbohydrateInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutTotalCarbohydrateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CarbohydrateUpsertWithoutTotalInput = {
    update: XOR<CarbohydrateUpdateWithoutTotalInput, CarbohydrateUncheckedUpdateWithoutTotalInput>
    create: XOR<CarbohydrateCreateWithoutTotalInput, CarbohydrateUncheckedCreateWithoutTotalInput>
  }

  export type CarbohydrateUpdateWithoutTotalInput = {
    sugar?: SugarCarbohydrateUpdateOneWithoutCarbohydrateInput
    nutritionFacts?: NutritionFactUpdateManyWithoutCarbohydrateInput
  }

  export type CarbohydrateUncheckedUpdateWithoutTotalInput = {
    id?: IntFieldUpdateOperationsInput | number
    sugarCarbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutCarbohydrateInput
  }

  export type MeasurementCreateWithoutSugarCarbohydrateInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutSugarCarbohydrateInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutSugarCarbohydrateInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutSugarCarbohydrateInput, MeasurementUncheckedCreateWithoutSugarCarbohydrateInput>
  }

  export type CarbohydrateCreateWithoutSugarInput = {
    total?: TotalCarbohydrateCreateNestedOneWithoutCarbohydrateInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutCarbohydrateInput
  }

  export type CarbohydrateUncheckedCreateWithoutSugarInput = {
    id?: number
    totalCarbohydrateId?: number | null
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutCarbohydrateInput
  }

  export type CarbohydrateCreateOrConnectWithoutSugarInput = {
    where: CarbohydrateWhereUniqueInput
    create: XOR<CarbohydrateCreateWithoutSugarInput, CarbohydrateUncheckedCreateWithoutSugarInput>
  }

  export type MeasurementUpsertWithoutSugarCarbohydrateInput = {
    update: XOR<MeasurementUpdateWithoutSugarCarbohydrateInput, MeasurementUncheckedUpdateWithoutSugarCarbohydrateInput>
    create: XOR<MeasurementCreateWithoutSugarCarbohydrateInput, MeasurementUncheckedCreateWithoutSugarCarbohydrateInput>
  }

  export type MeasurementUpdateWithoutSugarCarbohydrateInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutSugarCarbohydrateInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CarbohydrateUpsertWithoutSugarInput = {
    update: XOR<CarbohydrateUpdateWithoutSugarInput, CarbohydrateUncheckedUpdateWithoutSugarInput>
    create: XOR<CarbohydrateCreateWithoutSugarInput, CarbohydrateUncheckedCreateWithoutSugarInput>
  }

  export type CarbohydrateUpdateWithoutSugarInput = {
    total?: TotalCarbohydrateUpdateOneWithoutCarbohydrateInput
    nutritionFacts?: NutritionFactUpdateManyWithoutCarbohydrateInput
  }

  export type CarbohydrateUncheckedUpdateWithoutSugarInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalCarbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutCarbohydrateInput
  }

  export type VitaminCCreateWithoutVitaminInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminCInput
  }

  export type VitaminCUncheckedCreateWithoutVitaminInput = {
    id?: number
    measurementId: number
  }

  export type VitaminCCreateOrConnectWithoutVitaminInput = {
    where: VitaminCWhereUniqueInput
    create: XOR<VitaminCCreateWithoutVitaminInput, VitaminCUncheckedCreateWithoutVitaminInput>
  }

  export type VitaminACreateWithoutVitaminInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminAInput
  }

  export type VitaminAUncheckedCreateWithoutVitaminInput = {
    id?: number
    measurementId: number
  }

  export type VitaminACreateOrConnectWithoutVitaminInput = {
    where: VitaminAWhereUniqueInput
    create: XOR<VitaminACreateWithoutVitaminInput, VitaminAUncheckedCreateWithoutVitaminInput>
  }

  export type VitaminDCreateWithoutVitaminInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminDInput
  }

  export type VitaminDUncheckedCreateWithoutVitaminInput = {
    id?: number
    measurementId: number
  }

  export type VitaminDCreateOrConnectWithoutVitaminInput = {
    where: VitaminDWhereUniqueInput
    create: XOR<VitaminDCreateWithoutVitaminInput, VitaminDUncheckedCreateWithoutVitaminInput>
  }

  export type VitaminECreateWithoutVitaminInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminEInput
  }

  export type VitaminEUncheckedCreateWithoutVitaminInput = {
    id?: number
    measurementId: number
  }

  export type VitaminECreateOrConnectWithoutVitaminInput = {
    where: VitaminEWhereUniqueInput
    create: XOR<VitaminECreateWithoutVitaminInput, VitaminEUncheckedCreateWithoutVitaminInput>
  }

  export type VitaminB1CreateWithoutVitaminInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminB1Input
  }

  export type VitaminB1UncheckedCreateWithoutVitaminInput = {
    id?: number
    measurementId: number
  }

  export type VitaminB1CreateOrConnectWithoutVitaminInput = {
    where: VitaminB1WhereUniqueInput
    create: XOR<VitaminB1CreateWithoutVitaminInput, VitaminB1UncheckedCreateWithoutVitaminInput>
  }

  export type VitaminB2CreateWithoutVitaminInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminB2Input
  }

  export type VitaminB2UncheckedCreateWithoutVitaminInput = {
    id?: number
    measurementId: number
  }

  export type VitaminB2CreateOrConnectWithoutVitaminInput = {
    where: VitaminB2WhereUniqueInput
    create: XOR<VitaminB2CreateWithoutVitaminInput, VitaminB2UncheckedCreateWithoutVitaminInput>
  }

  export type VitaminB6CreateWithoutVitaminInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminB6Input
  }

  export type VitaminB6UncheckedCreateWithoutVitaminInput = {
    id?: number
    measurementId: number
  }

  export type VitaminB6CreateOrConnectWithoutVitaminInput = {
    where: VitaminB6WhereUniqueInput
    create: XOR<VitaminB6CreateWithoutVitaminInput, VitaminB6UncheckedCreateWithoutVitaminInput>
  }

  export type VitaminB12CreateWithoutVitaminInput = {
    measurement: MeasurementCreateNestedOneWithoutVitaminB12Input
  }

  export type VitaminB12UncheckedCreateWithoutVitaminInput = {
    id?: number
    measurementId: number
  }

  export type VitaminB12CreateOrConnectWithoutVitaminInput = {
    where: VitaminB12WhereUniqueInput
    create: XOR<VitaminB12CreateWithoutVitaminInput, VitaminB12UncheckedCreateWithoutVitaminInput>
  }

  export type NutritionFactCreateWithoutVitaminsInput = {
    energy?: EnergyCreateNestedManyWithoutNutritionFactInput
    protein?: ProteinCreateNestedOneWithoutNutritionFactInput
    fats?: FatCreateNestedOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateCreateNestedOneWithoutNutritionFactsInput
    fiber?: FiberCreateNestedOneWithoutNutritionFactInput
    water?: WaterCreateNestedOneWithoutNutritionFactInput
    minerals?: MineralCreateNestedOneWithoutNutritionFactInput
    cholesterol?: CholesterolCreateNestedOneWithoutNutritionFactInput
    product?: ProductCreateNestedOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedCreateWithoutVitaminsInput = {
    id?: number
    energy?: EnergyUncheckedCreateNestedManyWithoutNutritionFactInput
    proteinId?: number | null
    fatId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type NutritionFactCreateOrConnectWithoutVitaminsInput = {
    where: NutritionFactWhereUniqueInput
    create: XOR<NutritionFactCreateWithoutVitaminsInput, NutritionFactUncheckedCreateWithoutVitaminsInput>
  }

  export type NutritionFactCreateManyVitaminsInputEnvelope = {
    data: Enumerable<NutritionFactCreateManyVitaminsInput>
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutVitaminInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutVitaminInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutVitaminInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutVitaminInput, MeasurementUncheckedCreateWithoutVitaminInput>
  }

  export type VitaminCUpsertWithoutVitaminInput = {
    update: XOR<VitaminCUpdateWithoutVitaminInput, VitaminCUncheckedUpdateWithoutVitaminInput>
    create: XOR<VitaminCCreateWithoutVitaminInput, VitaminCUncheckedCreateWithoutVitaminInput>
  }

  export type VitaminCUpdateWithoutVitaminInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminCInput
  }

  export type VitaminCUncheckedUpdateWithoutVitaminInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminAUpsertWithoutVitaminInput = {
    update: XOR<VitaminAUpdateWithoutVitaminInput, VitaminAUncheckedUpdateWithoutVitaminInput>
    create: XOR<VitaminACreateWithoutVitaminInput, VitaminAUncheckedCreateWithoutVitaminInput>
  }

  export type VitaminAUpdateWithoutVitaminInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminAInput
  }

  export type VitaminAUncheckedUpdateWithoutVitaminInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminDUpsertWithoutVitaminInput = {
    update: XOR<VitaminDUpdateWithoutVitaminInput, VitaminDUncheckedUpdateWithoutVitaminInput>
    create: XOR<VitaminDCreateWithoutVitaminInput, VitaminDUncheckedCreateWithoutVitaminInput>
  }

  export type VitaminDUpdateWithoutVitaminInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminDInput
  }

  export type VitaminDUncheckedUpdateWithoutVitaminInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminEUpsertWithoutVitaminInput = {
    update: XOR<VitaminEUpdateWithoutVitaminInput, VitaminEUncheckedUpdateWithoutVitaminInput>
    create: XOR<VitaminECreateWithoutVitaminInput, VitaminEUncheckedCreateWithoutVitaminInput>
  }

  export type VitaminEUpdateWithoutVitaminInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminEInput
  }

  export type VitaminEUncheckedUpdateWithoutVitaminInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB1UpsertWithoutVitaminInput = {
    update: XOR<VitaminB1UpdateWithoutVitaminInput, VitaminB1UncheckedUpdateWithoutVitaminInput>
    create: XOR<VitaminB1CreateWithoutVitaminInput, VitaminB1UncheckedCreateWithoutVitaminInput>
  }

  export type VitaminB1UpdateWithoutVitaminInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminB1Input
  }

  export type VitaminB1UncheckedUpdateWithoutVitaminInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB2UpsertWithoutVitaminInput = {
    update: XOR<VitaminB2UpdateWithoutVitaminInput, VitaminB2UncheckedUpdateWithoutVitaminInput>
    create: XOR<VitaminB2CreateWithoutVitaminInput, VitaminB2UncheckedCreateWithoutVitaminInput>
  }

  export type VitaminB2UpdateWithoutVitaminInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminB2Input
  }

  export type VitaminB2UncheckedUpdateWithoutVitaminInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB6UpsertWithoutVitaminInput = {
    update: XOR<VitaminB6UpdateWithoutVitaminInput, VitaminB6UncheckedUpdateWithoutVitaminInput>
    create: XOR<VitaminB6CreateWithoutVitaminInput, VitaminB6UncheckedCreateWithoutVitaminInput>
  }

  export type VitaminB6UpdateWithoutVitaminInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminB6Input
  }

  export type VitaminB6UncheckedUpdateWithoutVitaminInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB12UpsertWithoutVitaminInput = {
    update: XOR<VitaminB12UpdateWithoutVitaminInput, VitaminB12UncheckedUpdateWithoutVitaminInput>
    create: XOR<VitaminB12CreateWithoutVitaminInput, VitaminB12UncheckedCreateWithoutVitaminInput>
  }

  export type VitaminB12UpdateWithoutVitaminInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutVitaminB12Input
  }

  export type VitaminB12UncheckedUpdateWithoutVitaminInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type NutritionFactUpsertWithWhereUniqueWithoutVitaminsInput = {
    where: NutritionFactWhereUniqueInput
    update: XOR<NutritionFactUpdateWithoutVitaminsInput, NutritionFactUncheckedUpdateWithoutVitaminsInput>
    create: XOR<NutritionFactCreateWithoutVitaminsInput, NutritionFactUncheckedCreateWithoutVitaminsInput>
  }

  export type NutritionFactUpdateWithWhereUniqueWithoutVitaminsInput = {
    where: NutritionFactWhereUniqueInput
    data: XOR<NutritionFactUpdateWithoutVitaminsInput, NutritionFactUncheckedUpdateWithoutVitaminsInput>
  }

  export type NutritionFactUpdateManyWithWhereWithoutVitaminsInput = {
    where: NutritionFactScalarWhereInput
    data: XOR<NutritionFactUpdateManyMutationInput, NutritionFactUncheckedUpdateManyWithoutNutritionFactsInput>
  }

  export type MeasurementUpsertWithWhereUniqueWithoutVitaminInput = {
    where: MeasurementWhereUniqueInput
    update: XOR<MeasurementUpdateWithoutVitaminInput, MeasurementUncheckedUpdateWithoutVitaminInput>
    create: XOR<MeasurementCreateWithoutVitaminInput, MeasurementUncheckedCreateWithoutVitaminInput>
  }

  export type MeasurementUpdateWithWhereUniqueWithoutVitaminInput = {
    where: MeasurementWhereUniqueInput
    data: XOR<MeasurementUpdateWithoutVitaminInput, MeasurementUncheckedUpdateWithoutVitaminInput>
  }

  export type MeasurementUpdateManyWithWhereWithoutVitaminInput = {
    where: MeasurementScalarWhereInput
    data: XOR<MeasurementUpdateManyMutationInput, MeasurementUncheckedUpdateManyWithoutMeasurementsInput>
  }

  export type MeasurementScalarWhereInput = {
    AND?: Enumerable<MeasurementScalarWhereInput>
    OR?: Enumerable<MeasurementScalarWhereInput>
    NOT?: Enumerable<MeasurementScalarWhereInput>
    id?: IntFilter | number
    value?: DecimalNullableFilter | Decimal | number | string | null
    unitId?: IntFilter | number
    proteinId?: IntNullableFilter | number | null
    cholesterolId?: IntNullableFilter | number | null
    fiberId?: IntNullableFilter | number | null
    waterId?: IntNullableFilter | number | null
  }

  export type MeasurementCreateWithoutVitaminCInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutVitaminCInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutVitaminCInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutVitaminCInput, MeasurementUncheckedCreateWithoutVitaminCInput>
  }

  export type VitaminCreateWithoutCInput = {
    A?: VitaminACreateNestedOneWithoutVitaminInput
    D?: VitaminDCreateNestedOneWithoutVitaminInput
    E?: VitaminECreateNestedOneWithoutVitaminInput
    B1?: VitaminB1CreateNestedOneWithoutVitaminInput
    B2?: VitaminB2CreateNestedOneWithoutVitaminInput
    B6?: VitaminB6CreateNestedOneWithoutVitaminInput
    B12?: VitaminB12CreateNestedOneWithoutVitaminInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutVitaminsInput
    measurements?: MeasurementCreateNestedManyWithoutVitaminInput
  }

  export type VitaminUncheckedCreateWithoutCInput = {
    id?: number
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutVitaminsInput
    vitaminAId?: number | null
    vitaminDId?: number | null
    vitaminEId?: number | null
    vitaminB1Id?: number | null
    vitaminB2Id?: number | null
    vitaminB6Id?: number | null
    vitaminB12Id?: number | null
    measurements?: MeasurementUncheckedCreateNestedManyWithoutVitaminInput
  }

  export type VitaminCreateOrConnectWithoutCInput = {
    where: VitaminWhereUniqueInput
    create: XOR<VitaminCreateWithoutCInput, VitaminUncheckedCreateWithoutCInput>
  }

  export type MeasurementUpsertWithoutVitaminCInput = {
    update: XOR<MeasurementUpdateWithoutVitaminCInput, MeasurementUncheckedUpdateWithoutVitaminCInput>
    create: XOR<MeasurementCreateWithoutVitaminCInput, MeasurementUncheckedCreateWithoutVitaminCInput>
  }

  export type MeasurementUpdateWithoutVitaminCInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutVitaminCInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VitaminUpsertWithoutCInput = {
    update: XOR<VitaminUpdateWithoutCInput, VitaminUncheckedUpdateWithoutCInput>
    create: XOR<VitaminCreateWithoutCInput, VitaminUncheckedCreateWithoutCInput>
  }

  export type VitaminUpdateWithoutCInput = {
    A?: VitaminAUpdateOneWithoutVitaminInput
    D?: VitaminDUpdateOneWithoutVitaminInput
    E?: VitaminEUpdateOneWithoutVitaminInput
    B1?: VitaminB1UpdateOneWithoutVitaminInput
    B2?: VitaminB2UpdateOneWithoutVitaminInput
    B6?: VitaminB6UpdateOneWithoutVitaminInput
    B12?: VitaminB12UpdateOneWithoutVitaminInput
    nutritionFacts?: NutritionFactUpdateManyWithoutVitaminsInput
    measurements?: MeasurementUpdateManyWithoutVitaminInput
  }

  export type VitaminUncheckedUpdateWithoutCInput = {
    id?: IntFieldUpdateOperationsInput | number
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutVitaminsInput
    vitaminAId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminDId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminEId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB1Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB2Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB6Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB12Id?: NullableIntFieldUpdateOperationsInput | number | null
    measurements?: MeasurementUncheckedUpdateManyWithoutVitaminInput
  }

  export type MeasurementCreateWithoutVitaminAInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutVitaminAInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutVitaminAInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutVitaminAInput, MeasurementUncheckedCreateWithoutVitaminAInput>
  }

  export type VitaminCreateWithoutAInput = {
    C?: VitaminCCreateNestedOneWithoutVitaminInput
    D?: VitaminDCreateNestedOneWithoutVitaminInput
    E?: VitaminECreateNestedOneWithoutVitaminInput
    B1?: VitaminB1CreateNestedOneWithoutVitaminInput
    B2?: VitaminB2CreateNestedOneWithoutVitaminInput
    B6?: VitaminB6CreateNestedOneWithoutVitaminInput
    B12?: VitaminB12CreateNestedOneWithoutVitaminInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutVitaminsInput
    measurements?: MeasurementCreateNestedManyWithoutVitaminInput
  }

  export type VitaminUncheckedCreateWithoutAInput = {
    id?: number
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutVitaminsInput
    vitaminCId?: number | null
    vitaminDId?: number | null
    vitaminEId?: number | null
    vitaminB1Id?: number | null
    vitaminB2Id?: number | null
    vitaminB6Id?: number | null
    vitaminB12Id?: number | null
    measurements?: MeasurementUncheckedCreateNestedManyWithoutVitaminInput
  }

  export type VitaminCreateOrConnectWithoutAInput = {
    where: VitaminWhereUniqueInput
    create: XOR<VitaminCreateWithoutAInput, VitaminUncheckedCreateWithoutAInput>
  }

  export type MeasurementUpsertWithoutVitaminAInput = {
    update: XOR<MeasurementUpdateWithoutVitaminAInput, MeasurementUncheckedUpdateWithoutVitaminAInput>
    create: XOR<MeasurementCreateWithoutVitaminAInput, MeasurementUncheckedCreateWithoutVitaminAInput>
  }

  export type MeasurementUpdateWithoutVitaminAInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutVitaminAInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VitaminUpsertWithoutAInput = {
    update: XOR<VitaminUpdateWithoutAInput, VitaminUncheckedUpdateWithoutAInput>
    create: XOR<VitaminCreateWithoutAInput, VitaminUncheckedCreateWithoutAInput>
  }

  export type VitaminUpdateWithoutAInput = {
    C?: VitaminCUpdateOneWithoutVitaminInput
    D?: VitaminDUpdateOneWithoutVitaminInput
    E?: VitaminEUpdateOneWithoutVitaminInput
    B1?: VitaminB1UpdateOneWithoutVitaminInput
    B2?: VitaminB2UpdateOneWithoutVitaminInput
    B6?: VitaminB6UpdateOneWithoutVitaminInput
    B12?: VitaminB12UpdateOneWithoutVitaminInput
    nutritionFacts?: NutritionFactUpdateManyWithoutVitaminsInput
    measurements?: MeasurementUpdateManyWithoutVitaminInput
  }

  export type VitaminUncheckedUpdateWithoutAInput = {
    id?: IntFieldUpdateOperationsInput | number
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutVitaminsInput
    vitaminCId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminDId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminEId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB1Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB2Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB6Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB12Id?: NullableIntFieldUpdateOperationsInput | number | null
    measurements?: MeasurementUncheckedUpdateManyWithoutVitaminInput
  }

  export type MeasurementCreateWithoutVitaminDInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutVitaminDInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutVitaminDInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutVitaminDInput, MeasurementUncheckedCreateWithoutVitaminDInput>
  }

  export type VitaminCreateWithoutDInput = {
    C?: VitaminCCreateNestedOneWithoutVitaminInput
    A?: VitaminACreateNestedOneWithoutVitaminInput
    E?: VitaminECreateNestedOneWithoutVitaminInput
    B1?: VitaminB1CreateNestedOneWithoutVitaminInput
    B2?: VitaminB2CreateNestedOneWithoutVitaminInput
    B6?: VitaminB6CreateNestedOneWithoutVitaminInput
    B12?: VitaminB12CreateNestedOneWithoutVitaminInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutVitaminsInput
    measurements?: MeasurementCreateNestedManyWithoutVitaminInput
  }

  export type VitaminUncheckedCreateWithoutDInput = {
    id?: number
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutVitaminsInput
    vitaminCId?: number | null
    vitaminAId?: number | null
    vitaminEId?: number | null
    vitaminB1Id?: number | null
    vitaminB2Id?: number | null
    vitaminB6Id?: number | null
    vitaminB12Id?: number | null
    measurements?: MeasurementUncheckedCreateNestedManyWithoutVitaminInput
  }

  export type VitaminCreateOrConnectWithoutDInput = {
    where: VitaminWhereUniqueInput
    create: XOR<VitaminCreateWithoutDInput, VitaminUncheckedCreateWithoutDInput>
  }

  export type MeasurementUpsertWithoutVitaminDInput = {
    update: XOR<MeasurementUpdateWithoutVitaminDInput, MeasurementUncheckedUpdateWithoutVitaminDInput>
    create: XOR<MeasurementCreateWithoutVitaminDInput, MeasurementUncheckedCreateWithoutVitaminDInput>
  }

  export type MeasurementUpdateWithoutVitaminDInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutVitaminDInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VitaminUpsertWithoutDInput = {
    update: XOR<VitaminUpdateWithoutDInput, VitaminUncheckedUpdateWithoutDInput>
    create: XOR<VitaminCreateWithoutDInput, VitaminUncheckedCreateWithoutDInput>
  }

  export type VitaminUpdateWithoutDInput = {
    C?: VitaminCUpdateOneWithoutVitaminInput
    A?: VitaminAUpdateOneWithoutVitaminInput
    E?: VitaminEUpdateOneWithoutVitaminInput
    B1?: VitaminB1UpdateOneWithoutVitaminInput
    B2?: VitaminB2UpdateOneWithoutVitaminInput
    B6?: VitaminB6UpdateOneWithoutVitaminInput
    B12?: VitaminB12UpdateOneWithoutVitaminInput
    nutritionFacts?: NutritionFactUpdateManyWithoutVitaminsInput
    measurements?: MeasurementUpdateManyWithoutVitaminInput
  }

  export type VitaminUncheckedUpdateWithoutDInput = {
    id?: IntFieldUpdateOperationsInput | number
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutVitaminsInput
    vitaminCId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminAId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminEId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB1Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB2Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB6Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB12Id?: NullableIntFieldUpdateOperationsInput | number | null
    measurements?: MeasurementUncheckedUpdateManyWithoutVitaminInput
  }

  export type MeasurementCreateWithoutVitaminEInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutVitaminEInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutVitaminEInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutVitaminEInput, MeasurementUncheckedCreateWithoutVitaminEInput>
  }

  export type VitaminCreateWithoutEInput = {
    C?: VitaminCCreateNestedOneWithoutVitaminInput
    A?: VitaminACreateNestedOneWithoutVitaminInput
    D?: VitaminDCreateNestedOneWithoutVitaminInput
    B1?: VitaminB1CreateNestedOneWithoutVitaminInput
    B2?: VitaminB2CreateNestedOneWithoutVitaminInput
    B6?: VitaminB6CreateNestedOneWithoutVitaminInput
    B12?: VitaminB12CreateNestedOneWithoutVitaminInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutVitaminsInput
    measurements?: MeasurementCreateNestedManyWithoutVitaminInput
  }

  export type VitaminUncheckedCreateWithoutEInput = {
    id?: number
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutVitaminsInput
    vitaminCId?: number | null
    vitaminAId?: number | null
    vitaminDId?: number | null
    vitaminB1Id?: number | null
    vitaminB2Id?: number | null
    vitaminB6Id?: number | null
    vitaminB12Id?: number | null
    measurements?: MeasurementUncheckedCreateNestedManyWithoutVitaminInput
  }

  export type VitaminCreateOrConnectWithoutEInput = {
    where: VitaminWhereUniqueInput
    create: XOR<VitaminCreateWithoutEInput, VitaminUncheckedCreateWithoutEInput>
  }

  export type MeasurementUpsertWithoutVitaminEInput = {
    update: XOR<MeasurementUpdateWithoutVitaminEInput, MeasurementUncheckedUpdateWithoutVitaminEInput>
    create: XOR<MeasurementCreateWithoutVitaminEInput, MeasurementUncheckedCreateWithoutVitaminEInput>
  }

  export type MeasurementUpdateWithoutVitaminEInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutVitaminEInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VitaminUpsertWithoutEInput = {
    update: XOR<VitaminUpdateWithoutEInput, VitaminUncheckedUpdateWithoutEInput>
    create: XOR<VitaminCreateWithoutEInput, VitaminUncheckedCreateWithoutEInput>
  }

  export type VitaminUpdateWithoutEInput = {
    C?: VitaminCUpdateOneWithoutVitaminInput
    A?: VitaminAUpdateOneWithoutVitaminInput
    D?: VitaminDUpdateOneWithoutVitaminInput
    B1?: VitaminB1UpdateOneWithoutVitaminInput
    B2?: VitaminB2UpdateOneWithoutVitaminInput
    B6?: VitaminB6UpdateOneWithoutVitaminInput
    B12?: VitaminB12UpdateOneWithoutVitaminInput
    nutritionFacts?: NutritionFactUpdateManyWithoutVitaminsInput
    measurements?: MeasurementUpdateManyWithoutVitaminInput
  }

  export type VitaminUncheckedUpdateWithoutEInput = {
    id?: IntFieldUpdateOperationsInput | number
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutVitaminsInput
    vitaminCId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminAId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminDId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB1Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB2Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB6Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB12Id?: NullableIntFieldUpdateOperationsInput | number | null
    measurements?: MeasurementUncheckedUpdateManyWithoutVitaminInput
  }

  export type MeasurementCreateWithoutVitaminB1Input = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutVitaminB1Input = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutVitaminB1Input = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutVitaminB1Input, MeasurementUncheckedCreateWithoutVitaminB1Input>
  }

  export type VitaminCreateWithoutB1Input = {
    C?: VitaminCCreateNestedOneWithoutVitaminInput
    A?: VitaminACreateNestedOneWithoutVitaminInput
    D?: VitaminDCreateNestedOneWithoutVitaminInput
    E?: VitaminECreateNestedOneWithoutVitaminInput
    B2?: VitaminB2CreateNestedOneWithoutVitaminInput
    B6?: VitaminB6CreateNestedOneWithoutVitaminInput
    B12?: VitaminB12CreateNestedOneWithoutVitaminInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutVitaminsInput
    measurements?: MeasurementCreateNestedManyWithoutVitaminInput
  }

  export type VitaminUncheckedCreateWithoutB1Input = {
    id?: number
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutVitaminsInput
    vitaminCId?: number | null
    vitaminAId?: number | null
    vitaminDId?: number | null
    vitaminEId?: number | null
    vitaminB2Id?: number | null
    vitaminB6Id?: number | null
    vitaminB12Id?: number | null
    measurements?: MeasurementUncheckedCreateNestedManyWithoutVitaminInput
  }

  export type VitaminCreateOrConnectWithoutB1Input = {
    where: VitaminWhereUniqueInput
    create: XOR<VitaminCreateWithoutB1Input, VitaminUncheckedCreateWithoutB1Input>
  }

  export type MeasurementUpsertWithoutVitaminB1Input = {
    update: XOR<MeasurementUpdateWithoutVitaminB1Input, MeasurementUncheckedUpdateWithoutVitaminB1Input>
    create: XOR<MeasurementCreateWithoutVitaminB1Input, MeasurementUncheckedCreateWithoutVitaminB1Input>
  }

  export type MeasurementUpdateWithoutVitaminB1Input = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutVitaminB1Input = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VitaminUpsertWithoutB1Input = {
    update: XOR<VitaminUpdateWithoutB1Input, VitaminUncheckedUpdateWithoutB1Input>
    create: XOR<VitaminCreateWithoutB1Input, VitaminUncheckedCreateWithoutB1Input>
  }

  export type VitaminUpdateWithoutB1Input = {
    C?: VitaminCUpdateOneWithoutVitaminInput
    A?: VitaminAUpdateOneWithoutVitaminInput
    D?: VitaminDUpdateOneWithoutVitaminInput
    E?: VitaminEUpdateOneWithoutVitaminInput
    B2?: VitaminB2UpdateOneWithoutVitaminInput
    B6?: VitaminB6UpdateOneWithoutVitaminInput
    B12?: VitaminB12UpdateOneWithoutVitaminInput
    nutritionFacts?: NutritionFactUpdateManyWithoutVitaminsInput
    measurements?: MeasurementUpdateManyWithoutVitaminInput
  }

  export type VitaminUncheckedUpdateWithoutB1Input = {
    id?: IntFieldUpdateOperationsInput | number
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutVitaminsInput
    vitaminCId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminAId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminDId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminEId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB2Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB6Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB12Id?: NullableIntFieldUpdateOperationsInput | number | null
    measurements?: MeasurementUncheckedUpdateManyWithoutVitaminInput
  }

  export type MeasurementCreateWithoutVitaminB2Input = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutVitaminB2Input = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutVitaminB2Input = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutVitaminB2Input, MeasurementUncheckedCreateWithoutVitaminB2Input>
  }

  export type VitaminCreateWithoutB2Input = {
    C?: VitaminCCreateNestedOneWithoutVitaminInput
    A?: VitaminACreateNestedOneWithoutVitaminInput
    D?: VitaminDCreateNestedOneWithoutVitaminInput
    E?: VitaminECreateNestedOneWithoutVitaminInput
    B1?: VitaminB1CreateNestedOneWithoutVitaminInput
    B6?: VitaminB6CreateNestedOneWithoutVitaminInput
    B12?: VitaminB12CreateNestedOneWithoutVitaminInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutVitaminsInput
    measurements?: MeasurementCreateNestedManyWithoutVitaminInput
  }

  export type VitaminUncheckedCreateWithoutB2Input = {
    id?: number
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutVitaminsInput
    vitaminCId?: number | null
    vitaminAId?: number | null
    vitaminDId?: number | null
    vitaminEId?: number | null
    vitaminB1Id?: number | null
    vitaminB6Id?: number | null
    vitaminB12Id?: number | null
    measurements?: MeasurementUncheckedCreateNestedManyWithoutVitaminInput
  }

  export type VitaminCreateOrConnectWithoutB2Input = {
    where: VitaminWhereUniqueInput
    create: XOR<VitaminCreateWithoutB2Input, VitaminUncheckedCreateWithoutB2Input>
  }

  export type MeasurementUpsertWithoutVitaminB2Input = {
    update: XOR<MeasurementUpdateWithoutVitaminB2Input, MeasurementUncheckedUpdateWithoutVitaminB2Input>
    create: XOR<MeasurementCreateWithoutVitaminB2Input, MeasurementUncheckedCreateWithoutVitaminB2Input>
  }

  export type MeasurementUpdateWithoutVitaminB2Input = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutVitaminB2Input = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VitaminUpsertWithoutB2Input = {
    update: XOR<VitaminUpdateWithoutB2Input, VitaminUncheckedUpdateWithoutB2Input>
    create: XOR<VitaminCreateWithoutB2Input, VitaminUncheckedCreateWithoutB2Input>
  }

  export type VitaminUpdateWithoutB2Input = {
    C?: VitaminCUpdateOneWithoutVitaminInput
    A?: VitaminAUpdateOneWithoutVitaminInput
    D?: VitaminDUpdateOneWithoutVitaminInput
    E?: VitaminEUpdateOneWithoutVitaminInput
    B1?: VitaminB1UpdateOneWithoutVitaminInput
    B6?: VitaminB6UpdateOneWithoutVitaminInput
    B12?: VitaminB12UpdateOneWithoutVitaminInput
    nutritionFacts?: NutritionFactUpdateManyWithoutVitaminsInput
    measurements?: MeasurementUpdateManyWithoutVitaminInput
  }

  export type VitaminUncheckedUpdateWithoutB2Input = {
    id?: IntFieldUpdateOperationsInput | number
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutVitaminsInput
    vitaminCId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminAId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminDId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminEId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB1Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB6Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB12Id?: NullableIntFieldUpdateOperationsInput | number | null
    measurements?: MeasurementUncheckedUpdateManyWithoutVitaminInput
  }

  export type MeasurementCreateWithoutVitaminB6Input = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutVitaminB6Input = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutVitaminB6Input = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutVitaminB6Input, MeasurementUncheckedCreateWithoutVitaminB6Input>
  }

  export type VitaminCreateWithoutB6Input = {
    C?: VitaminCCreateNestedOneWithoutVitaminInput
    A?: VitaminACreateNestedOneWithoutVitaminInput
    D?: VitaminDCreateNestedOneWithoutVitaminInput
    E?: VitaminECreateNestedOneWithoutVitaminInput
    B1?: VitaminB1CreateNestedOneWithoutVitaminInput
    B2?: VitaminB2CreateNestedOneWithoutVitaminInput
    B12?: VitaminB12CreateNestedOneWithoutVitaminInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutVitaminsInput
    measurements?: MeasurementCreateNestedManyWithoutVitaminInput
  }

  export type VitaminUncheckedCreateWithoutB6Input = {
    id?: number
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutVitaminsInput
    vitaminCId?: number | null
    vitaminAId?: number | null
    vitaminDId?: number | null
    vitaminEId?: number | null
    vitaminB1Id?: number | null
    vitaminB2Id?: number | null
    vitaminB12Id?: number | null
    measurements?: MeasurementUncheckedCreateNestedManyWithoutVitaminInput
  }

  export type VitaminCreateOrConnectWithoutB6Input = {
    where: VitaminWhereUniqueInput
    create: XOR<VitaminCreateWithoutB6Input, VitaminUncheckedCreateWithoutB6Input>
  }

  export type MeasurementUpsertWithoutVitaminB6Input = {
    update: XOR<MeasurementUpdateWithoutVitaminB6Input, MeasurementUncheckedUpdateWithoutVitaminB6Input>
    create: XOR<MeasurementCreateWithoutVitaminB6Input, MeasurementUncheckedCreateWithoutVitaminB6Input>
  }

  export type MeasurementUpdateWithoutVitaminB6Input = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutVitaminB6Input = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VitaminUpsertWithoutB6Input = {
    update: XOR<VitaminUpdateWithoutB6Input, VitaminUncheckedUpdateWithoutB6Input>
    create: XOR<VitaminCreateWithoutB6Input, VitaminUncheckedCreateWithoutB6Input>
  }

  export type VitaminUpdateWithoutB6Input = {
    C?: VitaminCUpdateOneWithoutVitaminInput
    A?: VitaminAUpdateOneWithoutVitaminInput
    D?: VitaminDUpdateOneWithoutVitaminInput
    E?: VitaminEUpdateOneWithoutVitaminInput
    B1?: VitaminB1UpdateOneWithoutVitaminInput
    B2?: VitaminB2UpdateOneWithoutVitaminInput
    B12?: VitaminB12UpdateOneWithoutVitaminInput
    nutritionFacts?: NutritionFactUpdateManyWithoutVitaminsInput
    measurements?: MeasurementUpdateManyWithoutVitaminInput
  }

  export type VitaminUncheckedUpdateWithoutB6Input = {
    id?: IntFieldUpdateOperationsInput | number
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutVitaminsInput
    vitaminCId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminAId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminDId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminEId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB1Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB2Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB12Id?: NullableIntFieldUpdateOperationsInput | number | null
    measurements?: MeasurementUncheckedUpdateManyWithoutVitaminInput
  }

  export type MeasurementCreateWithoutVitaminB12Input = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutVitaminB12Input = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutVitaminB12Input = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutVitaminB12Input, MeasurementUncheckedCreateWithoutVitaminB12Input>
  }

  export type VitaminCreateWithoutB12Input = {
    C?: VitaminCCreateNestedOneWithoutVitaminInput
    A?: VitaminACreateNestedOneWithoutVitaminInput
    D?: VitaminDCreateNestedOneWithoutVitaminInput
    E?: VitaminECreateNestedOneWithoutVitaminInput
    B1?: VitaminB1CreateNestedOneWithoutVitaminInput
    B2?: VitaminB2CreateNestedOneWithoutVitaminInput
    B6?: VitaminB6CreateNestedOneWithoutVitaminInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutVitaminsInput
    measurements?: MeasurementCreateNestedManyWithoutVitaminInput
  }

  export type VitaminUncheckedCreateWithoutB12Input = {
    id?: number
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutVitaminsInput
    vitaminCId?: number | null
    vitaminAId?: number | null
    vitaminDId?: number | null
    vitaminEId?: number | null
    vitaminB1Id?: number | null
    vitaminB2Id?: number | null
    vitaminB6Id?: number | null
    measurements?: MeasurementUncheckedCreateNestedManyWithoutVitaminInput
  }

  export type VitaminCreateOrConnectWithoutB12Input = {
    where: VitaminWhereUniqueInput
    create: XOR<VitaminCreateWithoutB12Input, VitaminUncheckedCreateWithoutB12Input>
  }

  export type MeasurementUpsertWithoutVitaminB12Input = {
    update: XOR<MeasurementUpdateWithoutVitaminB12Input, MeasurementUncheckedUpdateWithoutVitaminB12Input>
    create: XOR<MeasurementCreateWithoutVitaminB12Input, MeasurementUncheckedCreateWithoutVitaminB12Input>
  }

  export type MeasurementUpdateWithoutVitaminB12Input = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutVitaminB12Input = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VitaminUpsertWithoutB12Input = {
    update: XOR<VitaminUpdateWithoutB12Input, VitaminUncheckedUpdateWithoutB12Input>
    create: XOR<VitaminCreateWithoutB12Input, VitaminUncheckedCreateWithoutB12Input>
  }

  export type VitaminUpdateWithoutB12Input = {
    C?: VitaminCUpdateOneWithoutVitaminInput
    A?: VitaminAUpdateOneWithoutVitaminInput
    D?: VitaminDUpdateOneWithoutVitaminInput
    E?: VitaminEUpdateOneWithoutVitaminInput
    B1?: VitaminB1UpdateOneWithoutVitaminInput
    B2?: VitaminB2UpdateOneWithoutVitaminInput
    B6?: VitaminB6UpdateOneWithoutVitaminInput
    nutritionFacts?: NutritionFactUpdateManyWithoutVitaminsInput
    measurements?: MeasurementUpdateManyWithoutVitaminInput
  }

  export type VitaminUncheckedUpdateWithoutB12Input = {
    id?: IntFieldUpdateOperationsInput | number
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutVitaminsInput
    vitaminCId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminAId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminDId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminEId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB1Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB2Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB6Id?: NullableIntFieldUpdateOperationsInput | number | null
    measurements?: MeasurementUncheckedUpdateManyWithoutVitaminInput
  }

  export type MineralCreateWithoutSaltInput = {
    nutritionFact?: NutritionFactCreateNestedManyWithoutMineralsInput
    iron?: IronCreateNestedOneWithoutMineralsInput
    zinc?: ZincCreateNestedOneWithoutMineralsInput
    magnesium?: MagnesiumCreateNestedOneWithoutMineralsInput
    chloride?: ChlorideCreateNestedOneWithoutMineralsInput
    manganese?: ManganeseCreateNestedOneWithoutMineralsInput
    sulfur?: SulfurCreateNestedOneWithoutMineralsInput
    potassium?: PotassiumCreateNestedOneWithoutMineralsInput
    fluoride?: FluorideCreateNestedOneWithoutMineralsInput
    phosphorous?: PhosphorousCreateNestedOneWithoutMineralsInput
    copper?: CopperCreateNestedOneWithoutMineralsInput
    iodine?: IodineCreateNestedOneWithoutMineralsInput
    calcium?: CalciumCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateWithoutSaltInput = {
    id?: number
    nutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutMineralsInput
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralCreateOrConnectWithoutSaltInput = {
    where: MineralWhereUniqueInput
    create: XOR<MineralCreateWithoutSaltInput, MineralUncheckedCreateWithoutSaltInput>
  }

  export type MineralCreateManySaltInputEnvelope = {
    data: Enumerable<MineralCreateManySaltInput>
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutSaltInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutSaltInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutSaltInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutSaltInput, MeasurementUncheckedCreateWithoutSaltInput>
  }

  export type MineralUpsertWithWhereUniqueWithoutSaltInput = {
    where: MineralWhereUniqueInput
    update: XOR<MineralUpdateWithoutSaltInput, MineralUncheckedUpdateWithoutSaltInput>
    create: XOR<MineralCreateWithoutSaltInput, MineralUncheckedCreateWithoutSaltInput>
  }

  export type MineralUpdateWithWhereUniqueWithoutSaltInput = {
    where: MineralWhereUniqueInput
    data: XOR<MineralUpdateWithoutSaltInput, MineralUncheckedUpdateWithoutSaltInput>
  }

  export type MineralUpdateManyWithWhereWithoutSaltInput = {
    where: MineralScalarWhereInput
    data: XOR<MineralUpdateManyMutationInput, MineralUncheckedUpdateManyWithoutMineralsInput>
  }

  export type MineralScalarWhereInput = {
    AND?: Enumerable<MineralScalarWhereInput>
    OR?: Enumerable<MineralScalarWhereInput>
    NOT?: Enumerable<MineralScalarWhereInput>
    id?: IntFilter | number
    saltId?: IntNullableFilter | number | null
    ironId?: IntNullableFilter | number | null
    zincId?: IntNullableFilter | number | null
    magnesiumId?: IntNullableFilter | number | null
    chlorideId?: IntNullableFilter | number | null
    manganeseId?: IntNullableFilter | number | null
    sulfurId?: IntNullableFilter | number | null
    potassiumId?: IntNullableFilter | number | null
    fluorideId?: IntNullableFilter | number | null
    phosphorousId?: IntNullableFilter | number | null
    copperId?: IntNullableFilter | number | null
    iodineId?: IntNullableFilter | number | null
    calciumId?: IntNullableFilter | number | null
  }

  export type MeasurementUpsertWithoutSaltInput = {
    update: XOR<MeasurementUpdateWithoutSaltInput, MeasurementUncheckedUpdateWithoutSaltInput>
    create: XOR<MeasurementCreateWithoutSaltInput, MeasurementUncheckedCreateWithoutSaltInput>
  }

  export type MeasurementUpdateWithoutSaltInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutSaltInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateWithoutZincInput = {
    salt?: SaltCreateNestedOneWithoutMineralsInput
    nutritionFact?: NutritionFactCreateNestedManyWithoutMineralsInput
    iron?: IronCreateNestedOneWithoutMineralsInput
    magnesium?: MagnesiumCreateNestedOneWithoutMineralsInput
    chloride?: ChlorideCreateNestedOneWithoutMineralsInput
    manganese?: ManganeseCreateNestedOneWithoutMineralsInput
    sulfur?: SulfurCreateNestedOneWithoutMineralsInput
    potassium?: PotassiumCreateNestedOneWithoutMineralsInput
    fluoride?: FluorideCreateNestedOneWithoutMineralsInput
    phosphorous?: PhosphorousCreateNestedOneWithoutMineralsInput
    copper?: CopperCreateNestedOneWithoutMineralsInput
    iodine?: IodineCreateNestedOneWithoutMineralsInput
    calcium?: CalciumCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateWithoutZincInput = {
    id?: number
    saltId?: number | null
    nutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutMineralsInput
    ironId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralCreateOrConnectWithoutZincInput = {
    where: MineralWhereUniqueInput
    create: XOR<MineralCreateWithoutZincInput, MineralUncheckedCreateWithoutZincInput>
  }

  export type MineralCreateManyZincInputEnvelope = {
    data: Enumerable<MineralCreateManyZincInput>
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutZincInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutZincInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutZincInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutZincInput, MeasurementUncheckedCreateWithoutZincInput>
  }

  export type MineralUpsertWithWhereUniqueWithoutZincInput = {
    where: MineralWhereUniqueInput
    update: XOR<MineralUpdateWithoutZincInput, MineralUncheckedUpdateWithoutZincInput>
    create: XOR<MineralCreateWithoutZincInput, MineralUncheckedCreateWithoutZincInput>
  }

  export type MineralUpdateWithWhereUniqueWithoutZincInput = {
    where: MineralWhereUniqueInput
    data: XOR<MineralUpdateWithoutZincInput, MineralUncheckedUpdateWithoutZincInput>
  }

  export type MineralUpdateManyWithWhereWithoutZincInput = {
    where: MineralScalarWhereInput
    data: XOR<MineralUpdateManyMutationInput, MineralUncheckedUpdateManyWithoutMineralsInput>
  }

  export type MeasurementUpsertWithoutZincInput = {
    update: XOR<MeasurementUpdateWithoutZincInput, MeasurementUncheckedUpdateWithoutZincInput>
    create: XOR<MeasurementCreateWithoutZincInput, MeasurementUncheckedCreateWithoutZincInput>
  }

  export type MeasurementUpdateWithoutZincInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutZincInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateWithoutIronInput = {
    salt?: SaltCreateNestedOneWithoutMineralsInput
    nutritionFact?: NutritionFactCreateNestedManyWithoutMineralsInput
    zinc?: ZincCreateNestedOneWithoutMineralsInput
    magnesium?: MagnesiumCreateNestedOneWithoutMineralsInput
    chloride?: ChlorideCreateNestedOneWithoutMineralsInput
    manganese?: ManganeseCreateNestedOneWithoutMineralsInput
    sulfur?: SulfurCreateNestedOneWithoutMineralsInput
    potassium?: PotassiumCreateNestedOneWithoutMineralsInput
    fluoride?: FluorideCreateNestedOneWithoutMineralsInput
    phosphorous?: PhosphorousCreateNestedOneWithoutMineralsInput
    copper?: CopperCreateNestedOneWithoutMineralsInput
    iodine?: IodineCreateNestedOneWithoutMineralsInput
    calcium?: CalciumCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateWithoutIronInput = {
    id?: number
    saltId?: number | null
    nutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutMineralsInput
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralCreateOrConnectWithoutIronInput = {
    where: MineralWhereUniqueInput
    create: XOR<MineralCreateWithoutIronInput, MineralUncheckedCreateWithoutIronInput>
  }

  export type MineralCreateManyIronInputEnvelope = {
    data: Enumerable<MineralCreateManyIronInput>
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutIronInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutIronInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutIronInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutIronInput, MeasurementUncheckedCreateWithoutIronInput>
  }

  export type MineralUpsertWithWhereUniqueWithoutIronInput = {
    where: MineralWhereUniqueInput
    update: XOR<MineralUpdateWithoutIronInput, MineralUncheckedUpdateWithoutIronInput>
    create: XOR<MineralCreateWithoutIronInput, MineralUncheckedCreateWithoutIronInput>
  }

  export type MineralUpdateWithWhereUniqueWithoutIronInput = {
    where: MineralWhereUniqueInput
    data: XOR<MineralUpdateWithoutIronInput, MineralUncheckedUpdateWithoutIronInput>
  }

  export type MineralUpdateManyWithWhereWithoutIronInput = {
    where: MineralScalarWhereInput
    data: XOR<MineralUpdateManyMutationInput, MineralUncheckedUpdateManyWithoutMineralsInput>
  }

  export type MeasurementUpsertWithoutIronInput = {
    update: XOR<MeasurementUpdateWithoutIronInput, MeasurementUncheckedUpdateWithoutIronInput>
    create: XOR<MeasurementCreateWithoutIronInput, MeasurementUncheckedCreateWithoutIronInput>
  }

  export type MeasurementUpdateWithoutIronInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutIronInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateWithoutMagnesiumInput = {
    salt?: SaltCreateNestedOneWithoutMineralsInput
    nutritionFact?: NutritionFactCreateNestedManyWithoutMineralsInput
    iron?: IronCreateNestedOneWithoutMineralsInput
    zinc?: ZincCreateNestedOneWithoutMineralsInput
    chloride?: ChlorideCreateNestedOneWithoutMineralsInput
    manganese?: ManganeseCreateNestedOneWithoutMineralsInput
    sulfur?: SulfurCreateNestedOneWithoutMineralsInput
    potassium?: PotassiumCreateNestedOneWithoutMineralsInput
    fluoride?: FluorideCreateNestedOneWithoutMineralsInput
    phosphorous?: PhosphorousCreateNestedOneWithoutMineralsInput
    copper?: CopperCreateNestedOneWithoutMineralsInput
    iodine?: IodineCreateNestedOneWithoutMineralsInput
    calcium?: CalciumCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateWithoutMagnesiumInput = {
    id?: number
    saltId?: number | null
    nutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutMineralsInput
    ironId?: number | null
    zincId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralCreateOrConnectWithoutMagnesiumInput = {
    where: MineralWhereUniqueInput
    create: XOR<MineralCreateWithoutMagnesiumInput, MineralUncheckedCreateWithoutMagnesiumInput>
  }

  export type MineralCreateManyMagnesiumInputEnvelope = {
    data: Enumerable<MineralCreateManyMagnesiumInput>
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutMagnesiumInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutMagnesiumInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutMagnesiumInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutMagnesiumInput, MeasurementUncheckedCreateWithoutMagnesiumInput>
  }

  export type MineralUpsertWithWhereUniqueWithoutMagnesiumInput = {
    where: MineralWhereUniqueInput
    update: XOR<MineralUpdateWithoutMagnesiumInput, MineralUncheckedUpdateWithoutMagnesiumInput>
    create: XOR<MineralCreateWithoutMagnesiumInput, MineralUncheckedCreateWithoutMagnesiumInput>
  }

  export type MineralUpdateWithWhereUniqueWithoutMagnesiumInput = {
    where: MineralWhereUniqueInput
    data: XOR<MineralUpdateWithoutMagnesiumInput, MineralUncheckedUpdateWithoutMagnesiumInput>
  }

  export type MineralUpdateManyWithWhereWithoutMagnesiumInput = {
    where: MineralScalarWhereInput
    data: XOR<MineralUpdateManyMutationInput, MineralUncheckedUpdateManyWithoutMineralsInput>
  }

  export type MeasurementUpsertWithoutMagnesiumInput = {
    update: XOR<MeasurementUpdateWithoutMagnesiumInput, MeasurementUncheckedUpdateWithoutMagnesiumInput>
    create: XOR<MeasurementCreateWithoutMagnesiumInput, MeasurementUncheckedCreateWithoutMagnesiumInput>
  }

  export type MeasurementUpdateWithoutMagnesiumInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutMagnesiumInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateWithoutChlorideInput = {
    salt?: SaltCreateNestedOneWithoutMineralsInput
    nutritionFact?: NutritionFactCreateNestedManyWithoutMineralsInput
    iron?: IronCreateNestedOneWithoutMineralsInput
    zinc?: ZincCreateNestedOneWithoutMineralsInput
    magnesium?: MagnesiumCreateNestedOneWithoutMineralsInput
    manganese?: ManganeseCreateNestedOneWithoutMineralsInput
    sulfur?: SulfurCreateNestedOneWithoutMineralsInput
    potassium?: PotassiumCreateNestedOneWithoutMineralsInput
    fluoride?: FluorideCreateNestedOneWithoutMineralsInput
    phosphorous?: PhosphorousCreateNestedOneWithoutMineralsInput
    copper?: CopperCreateNestedOneWithoutMineralsInput
    iodine?: IodineCreateNestedOneWithoutMineralsInput
    calcium?: CalciumCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateWithoutChlorideInput = {
    id?: number
    saltId?: number | null
    nutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutMineralsInput
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralCreateOrConnectWithoutChlorideInput = {
    where: MineralWhereUniqueInput
    create: XOR<MineralCreateWithoutChlorideInput, MineralUncheckedCreateWithoutChlorideInput>
  }

  export type MineralCreateManyChlorideInputEnvelope = {
    data: Enumerable<MineralCreateManyChlorideInput>
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutChlorideInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutChlorideInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutChlorideInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutChlorideInput, MeasurementUncheckedCreateWithoutChlorideInput>
  }

  export type MineralUpsertWithWhereUniqueWithoutChlorideInput = {
    where: MineralWhereUniqueInput
    update: XOR<MineralUpdateWithoutChlorideInput, MineralUncheckedUpdateWithoutChlorideInput>
    create: XOR<MineralCreateWithoutChlorideInput, MineralUncheckedCreateWithoutChlorideInput>
  }

  export type MineralUpdateWithWhereUniqueWithoutChlorideInput = {
    where: MineralWhereUniqueInput
    data: XOR<MineralUpdateWithoutChlorideInput, MineralUncheckedUpdateWithoutChlorideInput>
  }

  export type MineralUpdateManyWithWhereWithoutChlorideInput = {
    where: MineralScalarWhereInput
    data: XOR<MineralUpdateManyMutationInput, MineralUncheckedUpdateManyWithoutMineralsInput>
  }

  export type MeasurementUpsertWithoutChlorideInput = {
    update: XOR<MeasurementUpdateWithoutChlorideInput, MeasurementUncheckedUpdateWithoutChlorideInput>
    create: XOR<MeasurementCreateWithoutChlorideInput, MeasurementUncheckedCreateWithoutChlorideInput>
  }

  export type MeasurementUpdateWithoutChlorideInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutChlorideInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateWithoutManganeseInput = {
    salt?: SaltCreateNestedOneWithoutMineralsInput
    nutritionFact?: NutritionFactCreateNestedManyWithoutMineralsInput
    iron?: IronCreateNestedOneWithoutMineralsInput
    zinc?: ZincCreateNestedOneWithoutMineralsInput
    magnesium?: MagnesiumCreateNestedOneWithoutMineralsInput
    chloride?: ChlorideCreateNestedOneWithoutMineralsInput
    sulfur?: SulfurCreateNestedOneWithoutMineralsInput
    potassium?: PotassiumCreateNestedOneWithoutMineralsInput
    fluoride?: FluorideCreateNestedOneWithoutMineralsInput
    phosphorous?: PhosphorousCreateNestedOneWithoutMineralsInput
    copper?: CopperCreateNestedOneWithoutMineralsInput
    iodine?: IodineCreateNestedOneWithoutMineralsInput
    calcium?: CalciumCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateWithoutManganeseInput = {
    id?: number
    saltId?: number | null
    nutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutMineralsInput
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralCreateOrConnectWithoutManganeseInput = {
    where: MineralWhereUniqueInput
    create: XOR<MineralCreateWithoutManganeseInput, MineralUncheckedCreateWithoutManganeseInput>
  }

  export type MineralCreateManyManganeseInputEnvelope = {
    data: Enumerable<MineralCreateManyManganeseInput>
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutManganeseInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutManganeseInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutManganeseInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutManganeseInput, MeasurementUncheckedCreateWithoutManganeseInput>
  }

  export type MineralUpsertWithWhereUniqueWithoutManganeseInput = {
    where: MineralWhereUniqueInput
    update: XOR<MineralUpdateWithoutManganeseInput, MineralUncheckedUpdateWithoutManganeseInput>
    create: XOR<MineralCreateWithoutManganeseInput, MineralUncheckedCreateWithoutManganeseInput>
  }

  export type MineralUpdateWithWhereUniqueWithoutManganeseInput = {
    where: MineralWhereUniqueInput
    data: XOR<MineralUpdateWithoutManganeseInput, MineralUncheckedUpdateWithoutManganeseInput>
  }

  export type MineralUpdateManyWithWhereWithoutManganeseInput = {
    where: MineralScalarWhereInput
    data: XOR<MineralUpdateManyMutationInput, MineralUncheckedUpdateManyWithoutMineralsInput>
  }

  export type MeasurementUpsertWithoutManganeseInput = {
    update: XOR<MeasurementUpdateWithoutManganeseInput, MeasurementUncheckedUpdateWithoutManganeseInput>
    create: XOR<MeasurementCreateWithoutManganeseInput, MeasurementUncheckedCreateWithoutManganeseInput>
  }

  export type MeasurementUpdateWithoutManganeseInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutManganeseInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateWithoutSulfurInput = {
    salt?: SaltCreateNestedOneWithoutMineralsInput
    nutritionFact?: NutritionFactCreateNestedManyWithoutMineralsInput
    iron?: IronCreateNestedOneWithoutMineralsInput
    zinc?: ZincCreateNestedOneWithoutMineralsInput
    magnesium?: MagnesiumCreateNestedOneWithoutMineralsInput
    chloride?: ChlorideCreateNestedOneWithoutMineralsInput
    manganese?: ManganeseCreateNestedOneWithoutMineralsInput
    potassium?: PotassiumCreateNestedOneWithoutMineralsInput
    fluoride?: FluorideCreateNestedOneWithoutMineralsInput
    phosphorous?: PhosphorousCreateNestedOneWithoutMineralsInput
    copper?: CopperCreateNestedOneWithoutMineralsInput
    iodine?: IodineCreateNestedOneWithoutMineralsInput
    calcium?: CalciumCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateWithoutSulfurInput = {
    id?: number
    saltId?: number | null
    nutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutMineralsInput
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralCreateOrConnectWithoutSulfurInput = {
    where: MineralWhereUniqueInput
    create: XOR<MineralCreateWithoutSulfurInput, MineralUncheckedCreateWithoutSulfurInput>
  }

  export type MineralCreateManySulfurInputEnvelope = {
    data: Enumerable<MineralCreateManySulfurInput>
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutSulfurInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutSulfurInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutSulfurInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutSulfurInput, MeasurementUncheckedCreateWithoutSulfurInput>
  }

  export type MineralUpsertWithWhereUniqueWithoutSulfurInput = {
    where: MineralWhereUniqueInput
    update: XOR<MineralUpdateWithoutSulfurInput, MineralUncheckedUpdateWithoutSulfurInput>
    create: XOR<MineralCreateWithoutSulfurInput, MineralUncheckedCreateWithoutSulfurInput>
  }

  export type MineralUpdateWithWhereUniqueWithoutSulfurInput = {
    where: MineralWhereUniqueInput
    data: XOR<MineralUpdateWithoutSulfurInput, MineralUncheckedUpdateWithoutSulfurInput>
  }

  export type MineralUpdateManyWithWhereWithoutSulfurInput = {
    where: MineralScalarWhereInput
    data: XOR<MineralUpdateManyMutationInput, MineralUncheckedUpdateManyWithoutMineralsInput>
  }

  export type MeasurementUpsertWithoutSulfurInput = {
    update: XOR<MeasurementUpdateWithoutSulfurInput, MeasurementUncheckedUpdateWithoutSulfurInput>
    create: XOR<MeasurementCreateWithoutSulfurInput, MeasurementUncheckedCreateWithoutSulfurInput>
  }

  export type MeasurementUpdateWithoutSulfurInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutSulfurInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateWithoutPotassiumInput = {
    salt?: SaltCreateNestedOneWithoutMineralsInput
    nutritionFact?: NutritionFactCreateNestedManyWithoutMineralsInput
    iron?: IronCreateNestedOneWithoutMineralsInput
    zinc?: ZincCreateNestedOneWithoutMineralsInput
    magnesium?: MagnesiumCreateNestedOneWithoutMineralsInput
    chloride?: ChlorideCreateNestedOneWithoutMineralsInput
    manganese?: ManganeseCreateNestedOneWithoutMineralsInput
    sulfur?: SulfurCreateNestedOneWithoutMineralsInput
    fluoride?: FluorideCreateNestedOneWithoutMineralsInput
    phosphorous?: PhosphorousCreateNestedOneWithoutMineralsInput
    copper?: CopperCreateNestedOneWithoutMineralsInput
    iodine?: IodineCreateNestedOneWithoutMineralsInput
    calcium?: CalciumCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateWithoutPotassiumInput = {
    id?: number
    saltId?: number | null
    nutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutMineralsInput
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralCreateOrConnectWithoutPotassiumInput = {
    where: MineralWhereUniqueInput
    create: XOR<MineralCreateWithoutPotassiumInput, MineralUncheckedCreateWithoutPotassiumInput>
  }

  export type MineralCreateManyPotassiumInputEnvelope = {
    data: Enumerable<MineralCreateManyPotassiumInput>
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutPotassiumInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutPotassiumInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutPotassiumInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutPotassiumInput, MeasurementUncheckedCreateWithoutPotassiumInput>
  }

  export type MineralUpsertWithWhereUniqueWithoutPotassiumInput = {
    where: MineralWhereUniqueInput
    update: XOR<MineralUpdateWithoutPotassiumInput, MineralUncheckedUpdateWithoutPotassiumInput>
    create: XOR<MineralCreateWithoutPotassiumInput, MineralUncheckedCreateWithoutPotassiumInput>
  }

  export type MineralUpdateWithWhereUniqueWithoutPotassiumInput = {
    where: MineralWhereUniqueInput
    data: XOR<MineralUpdateWithoutPotassiumInput, MineralUncheckedUpdateWithoutPotassiumInput>
  }

  export type MineralUpdateManyWithWhereWithoutPotassiumInput = {
    where: MineralScalarWhereInput
    data: XOR<MineralUpdateManyMutationInput, MineralUncheckedUpdateManyWithoutMineralsInput>
  }

  export type MeasurementUpsertWithoutPotassiumInput = {
    update: XOR<MeasurementUpdateWithoutPotassiumInput, MeasurementUncheckedUpdateWithoutPotassiumInput>
    create: XOR<MeasurementCreateWithoutPotassiumInput, MeasurementUncheckedCreateWithoutPotassiumInput>
  }

  export type MeasurementUpdateWithoutPotassiumInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutPotassiumInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateWithoutFluorideInput = {
    salt?: SaltCreateNestedOneWithoutMineralsInput
    nutritionFact?: NutritionFactCreateNestedManyWithoutMineralsInput
    iron?: IronCreateNestedOneWithoutMineralsInput
    zinc?: ZincCreateNestedOneWithoutMineralsInput
    magnesium?: MagnesiumCreateNestedOneWithoutMineralsInput
    chloride?: ChlorideCreateNestedOneWithoutMineralsInput
    manganese?: ManganeseCreateNestedOneWithoutMineralsInput
    sulfur?: SulfurCreateNestedOneWithoutMineralsInput
    potassium?: PotassiumCreateNestedOneWithoutMineralsInput
    phosphorous?: PhosphorousCreateNestedOneWithoutMineralsInput
    copper?: CopperCreateNestedOneWithoutMineralsInput
    iodine?: IodineCreateNestedOneWithoutMineralsInput
    calcium?: CalciumCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateWithoutFluorideInput = {
    id?: number
    saltId?: number | null
    nutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutMineralsInput
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralCreateOrConnectWithoutFluorideInput = {
    where: MineralWhereUniqueInput
    create: XOR<MineralCreateWithoutFluorideInput, MineralUncheckedCreateWithoutFluorideInput>
  }

  export type MineralCreateManyFluorideInputEnvelope = {
    data: Enumerable<MineralCreateManyFluorideInput>
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutFluorideInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutFluorideInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutFluorideInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutFluorideInput, MeasurementUncheckedCreateWithoutFluorideInput>
  }

  export type MineralUpsertWithWhereUniqueWithoutFluorideInput = {
    where: MineralWhereUniqueInput
    update: XOR<MineralUpdateWithoutFluorideInput, MineralUncheckedUpdateWithoutFluorideInput>
    create: XOR<MineralCreateWithoutFluorideInput, MineralUncheckedCreateWithoutFluorideInput>
  }

  export type MineralUpdateWithWhereUniqueWithoutFluorideInput = {
    where: MineralWhereUniqueInput
    data: XOR<MineralUpdateWithoutFluorideInput, MineralUncheckedUpdateWithoutFluorideInput>
  }

  export type MineralUpdateManyWithWhereWithoutFluorideInput = {
    where: MineralScalarWhereInput
    data: XOR<MineralUpdateManyMutationInput, MineralUncheckedUpdateManyWithoutMineralsInput>
  }

  export type MeasurementUpsertWithoutFluorideInput = {
    update: XOR<MeasurementUpdateWithoutFluorideInput, MeasurementUncheckedUpdateWithoutFluorideInput>
    create: XOR<MeasurementCreateWithoutFluorideInput, MeasurementUncheckedCreateWithoutFluorideInput>
  }

  export type MeasurementUpdateWithoutFluorideInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutFluorideInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateWithoutPhosphorousInput = {
    salt?: SaltCreateNestedOneWithoutMineralsInput
    nutritionFact?: NutritionFactCreateNestedManyWithoutMineralsInput
    iron?: IronCreateNestedOneWithoutMineralsInput
    zinc?: ZincCreateNestedOneWithoutMineralsInput
    magnesium?: MagnesiumCreateNestedOneWithoutMineralsInput
    chloride?: ChlorideCreateNestedOneWithoutMineralsInput
    manganese?: ManganeseCreateNestedOneWithoutMineralsInput
    sulfur?: SulfurCreateNestedOneWithoutMineralsInput
    potassium?: PotassiumCreateNestedOneWithoutMineralsInput
    fluoride?: FluorideCreateNestedOneWithoutMineralsInput
    copper?: CopperCreateNestedOneWithoutMineralsInput
    iodine?: IodineCreateNestedOneWithoutMineralsInput
    calcium?: CalciumCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateWithoutPhosphorousInput = {
    id?: number
    saltId?: number | null
    nutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutMineralsInput
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralCreateOrConnectWithoutPhosphorousInput = {
    where: MineralWhereUniqueInput
    create: XOR<MineralCreateWithoutPhosphorousInput, MineralUncheckedCreateWithoutPhosphorousInput>
  }

  export type MineralCreateManyPhosphorousInputEnvelope = {
    data: Enumerable<MineralCreateManyPhosphorousInput>
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutPhosphorousInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutPhosphorousInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutPhosphorousInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutPhosphorousInput, MeasurementUncheckedCreateWithoutPhosphorousInput>
  }

  export type MineralUpsertWithWhereUniqueWithoutPhosphorousInput = {
    where: MineralWhereUniqueInput
    update: XOR<MineralUpdateWithoutPhosphorousInput, MineralUncheckedUpdateWithoutPhosphorousInput>
    create: XOR<MineralCreateWithoutPhosphorousInput, MineralUncheckedCreateWithoutPhosphorousInput>
  }

  export type MineralUpdateWithWhereUniqueWithoutPhosphorousInput = {
    where: MineralWhereUniqueInput
    data: XOR<MineralUpdateWithoutPhosphorousInput, MineralUncheckedUpdateWithoutPhosphorousInput>
  }

  export type MineralUpdateManyWithWhereWithoutPhosphorousInput = {
    where: MineralScalarWhereInput
    data: XOR<MineralUpdateManyMutationInput, MineralUncheckedUpdateManyWithoutMineralsInput>
  }

  export type MeasurementUpsertWithoutPhosphorousInput = {
    update: XOR<MeasurementUpdateWithoutPhosphorousInput, MeasurementUncheckedUpdateWithoutPhosphorousInput>
    create: XOR<MeasurementCreateWithoutPhosphorousInput, MeasurementUncheckedCreateWithoutPhosphorousInput>
  }

  export type MeasurementUpdateWithoutPhosphorousInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutPhosphorousInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateWithoutCopperInput = {
    salt?: SaltCreateNestedOneWithoutMineralsInput
    nutritionFact?: NutritionFactCreateNestedManyWithoutMineralsInput
    iron?: IronCreateNestedOneWithoutMineralsInput
    zinc?: ZincCreateNestedOneWithoutMineralsInput
    magnesium?: MagnesiumCreateNestedOneWithoutMineralsInput
    chloride?: ChlorideCreateNestedOneWithoutMineralsInput
    manganese?: ManganeseCreateNestedOneWithoutMineralsInput
    sulfur?: SulfurCreateNestedOneWithoutMineralsInput
    potassium?: PotassiumCreateNestedOneWithoutMineralsInput
    fluoride?: FluorideCreateNestedOneWithoutMineralsInput
    phosphorous?: PhosphorousCreateNestedOneWithoutMineralsInput
    iodine?: IodineCreateNestedOneWithoutMineralsInput
    calcium?: CalciumCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateWithoutCopperInput = {
    id?: number
    saltId?: number | null
    nutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutMineralsInput
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralCreateOrConnectWithoutCopperInput = {
    where: MineralWhereUniqueInput
    create: XOR<MineralCreateWithoutCopperInput, MineralUncheckedCreateWithoutCopperInput>
  }

  export type MineralCreateManyCopperInputEnvelope = {
    data: Enumerable<MineralCreateManyCopperInput>
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutCopperInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutCopperInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutCopperInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutCopperInput, MeasurementUncheckedCreateWithoutCopperInput>
  }

  export type MineralUpsertWithWhereUniqueWithoutCopperInput = {
    where: MineralWhereUniqueInput
    update: XOR<MineralUpdateWithoutCopperInput, MineralUncheckedUpdateWithoutCopperInput>
    create: XOR<MineralCreateWithoutCopperInput, MineralUncheckedCreateWithoutCopperInput>
  }

  export type MineralUpdateWithWhereUniqueWithoutCopperInput = {
    where: MineralWhereUniqueInput
    data: XOR<MineralUpdateWithoutCopperInput, MineralUncheckedUpdateWithoutCopperInput>
  }

  export type MineralUpdateManyWithWhereWithoutCopperInput = {
    where: MineralScalarWhereInput
    data: XOR<MineralUpdateManyMutationInput, MineralUncheckedUpdateManyWithoutMineralsInput>
  }

  export type MeasurementUpsertWithoutCopperInput = {
    update: XOR<MeasurementUpdateWithoutCopperInput, MeasurementUncheckedUpdateWithoutCopperInput>
    create: XOR<MeasurementCreateWithoutCopperInput, MeasurementUncheckedCreateWithoutCopperInput>
  }

  export type MeasurementUpdateWithoutCopperInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutCopperInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateWithoutIodineInput = {
    salt?: SaltCreateNestedOneWithoutMineralsInput
    nutritionFact?: NutritionFactCreateNestedManyWithoutMineralsInput
    iron?: IronCreateNestedOneWithoutMineralsInput
    zinc?: ZincCreateNestedOneWithoutMineralsInput
    magnesium?: MagnesiumCreateNestedOneWithoutMineralsInput
    chloride?: ChlorideCreateNestedOneWithoutMineralsInput
    manganese?: ManganeseCreateNestedOneWithoutMineralsInput
    sulfur?: SulfurCreateNestedOneWithoutMineralsInput
    potassium?: PotassiumCreateNestedOneWithoutMineralsInput
    fluoride?: FluorideCreateNestedOneWithoutMineralsInput
    phosphorous?: PhosphorousCreateNestedOneWithoutMineralsInput
    copper?: CopperCreateNestedOneWithoutMineralsInput
    calcium?: CalciumCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateWithoutIodineInput = {
    id?: number
    saltId?: number | null
    nutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutMineralsInput
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    calciumId?: number | null
  }

  export type MineralCreateOrConnectWithoutIodineInput = {
    where: MineralWhereUniqueInput
    create: XOR<MineralCreateWithoutIodineInput, MineralUncheckedCreateWithoutIodineInput>
  }

  export type MineralCreateManyIodineInputEnvelope = {
    data: Enumerable<MineralCreateManyIodineInput>
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutIodineInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutIodineInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutIodineInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutIodineInput, MeasurementUncheckedCreateWithoutIodineInput>
  }

  export type MineralUpsertWithWhereUniqueWithoutIodineInput = {
    where: MineralWhereUniqueInput
    update: XOR<MineralUpdateWithoutIodineInput, MineralUncheckedUpdateWithoutIodineInput>
    create: XOR<MineralCreateWithoutIodineInput, MineralUncheckedCreateWithoutIodineInput>
  }

  export type MineralUpdateWithWhereUniqueWithoutIodineInput = {
    where: MineralWhereUniqueInput
    data: XOR<MineralUpdateWithoutIodineInput, MineralUncheckedUpdateWithoutIodineInput>
  }

  export type MineralUpdateManyWithWhereWithoutIodineInput = {
    where: MineralScalarWhereInput
    data: XOR<MineralUpdateManyMutationInput, MineralUncheckedUpdateManyWithoutMineralsInput>
  }

  export type MeasurementUpsertWithoutIodineInput = {
    update: XOR<MeasurementUpdateWithoutIodineInput, MeasurementUncheckedUpdateWithoutIodineInput>
    create: XOR<MeasurementCreateWithoutIodineInput, MeasurementUncheckedCreateWithoutIodineInput>
  }

  export type MeasurementUpdateWithoutIodineInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutIodineInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateWithoutCalciumInput = {
    salt?: SaltCreateNestedOneWithoutMineralsInput
    nutritionFact?: NutritionFactCreateNestedManyWithoutMineralsInput
    iron?: IronCreateNestedOneWithoutMineralsInput
    zinc?: ZincCreateNestedOneWithoutMineralsInput
    magnesium?: MagnesiumCreateNestedOneWithoutMineralsInput
    chloride?: ChlorideCreateNestedOneWithoutMineralsInput
    manganese?: ManganeseCreateNestedOneWithoutMineralsInput
    sulfur?: SulfurCreateNestedOneWithoutMineralsInput
    potassium?: PotassiumCreateNestedOneWithoutMineralsInput
    fluoride?: FluorideCreateNestedOneWithoutMineralsInput
    phosphorous?: PhosphorousCreateNestedOneWithoutMineralsInput
    copper?: CopperCreateNestedOneWithoutMineralsInput
    iodine?: IodineCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateWithoutCalciumInput = {
    id?: number
    saltId?: number | null
    nutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutMineralsInput
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
  }

  export type MineralCreateOrConnectWithoutCalciumInput = {
    where: MineralWhereUniqueInput
    create: XOR<MineralCreateWithoutCalciumInput, MineralUncheckedCreateWithoutCalciumInput>
  }

  export type MineralCreateManyCalciumInputEnvelope = {
    data: Enumerable<MineralCreateManyCalciumInput>
    skipDuplicates?: boolean
  }

  export type MeasurementCreateWithoutCalciumInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutCalciumInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutCalciumInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutCalciumInput, MeasurementUncheckedCreateWithoutCalciumInput>
  }

  export type MineralUpsertWithWhereUniqueWithoutCalciumInput = {
    where: MineralWhereUniqueInput
    update: XOR<MineralUpdateWithoutCalciumInput, MineralUncheckedUpdateWithoutCalciumInput>
    create: XOR<MineralCreateWithoutCalciumInput, MineralUncheckedCreateWithoutCalciumInput>
  }

  export type MineralUpdateWithWhereUniqueWithoutCalciumInput = {
    where: MineralWhereUniqueInput
    data: XOR<MineralUpdateWithoutCalciumInput, MineralUncheckedUpdateWithoutCalciumInput>
  }

  export type MineralUpdateManyWithWhereWithoutCalciumInput = {
    where: MineralScalarWhereInput
    data: XOR<MineralUpdateManyMutationInput, MineralUncheckedUpdateManyWithoutMineralsInput>
  }

  export type MeasurementUpsertWithoutCalciumInput = {
    update: XOR<MeasurementUpdateWithoutCalciumInput, MeasurementUncheckedUpdateWithoutCalciumInput>
    create: XOR<MeasurementCreateWithoutCalciumInput, MeasurementUncheckedCreateWithoutCalciumInput>
  }

  export type MeasurementUpdateWithoutCalciumInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutCalciumInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SaltCreateWithoutMineralsInput = {
    measurement: MeasurementCreateNestedOneWithoutSaltInput
  }

  export type SaltUncheckedCreateWithoutMineralsInput = {
    id?: number
    measurementId: number
  }

  export type SaltCreateOrConnectWithoutMineralsInput = {
    where: SaltWhereUniqueInput
    create: XOR<SaltCreateWithoutMineralsInput, SaltUncheckedCreateWithoutMineralsInput>
  }

  export type NutritionFactCreateWithoutMineralsInput = {
    energy?: EnergyCreateNestedManyWithoutNutritionFactInput
    protein?: ProteinCreateNestedOneWithoutNutritionFactInput
    fats?: FatCreateNestedOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateCreateNestedOneWithoutNutritionFactsInput
    fiber?: FiberCreateNestedOneWithoutNutritionFactInput
    water?: WaterCreateNestedOneWithoutNutritionFactInput
    vitamins?: VitaminCreateNestedOneWithoutNutritionFactsInput
    cholesterol?: CholesterolCreateNestedOneWithoutNutritionFactInput
    product?: ProductCreateNestedOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedCreateWithoutMineralsInput = {
    id?: number
    energy?: EnergyUncheckedCreateNestedManyWithoutNutritionFactInput
    proteinId?: number | null
    fatId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type NutritionFactCreateOrConnectWithoutMineralsInput = {
    where: NutritionFactWhereUniqueInput
    create: XOR<NutritionFactCreateWithoutMineralsInput, NutritionFactUncheckedCreateWithoutMineralsInput>
  }

  export type NutritionFactCreateManyMineralsInputEnvelope = {
    data: Enumerable<NutritionFactCreateManyMineralsInput>
    skipDuplicates?: boolean
  }

  export type IronCreateWithoutMineralsInput = {
    measurement: MeasurementCreateNestedOneWithoutIronInput
  }

  export type IronUncheckedCreateWithoutMineralsInput = {
    id?: number
    measurementId: number
  }

  export type IronCreateOrConnectWithoutMineralsInput = {
    where: IronWhereUniqueInput
    create: XOR<IronCreateWithoutMineralsInput, IronUncheckedCreateWithoutMineralsInput>
  }

  export type ZincCreateWithoutMineralsInput = {
    measurement: MeasurementCreateNestedOneWithoutZincInput
  }

  export type ZincUncheckedCreateWithoutMineralsInput = {
    id?: number
    measurementId: number
  }

  export type ZincCreateOrConnectWithoutMineralsInput = {
    where: ZincWhereUniqueInput
    create: XOR<ZincCreateWithoutMineralsInput, ZincUncheckedCreateWithoutMineralsInput>
  }

  export type MagnesiumCreateWithoutMineralsInput = {
    measurement: MeasurementCreateNestedOneWithoutMagnesiumInput
  }

  export type MagnesiumUncheckedCreateWithoutMineralsInput = {
    id?: number
    measurementId: number
  }

  export type MagnesiumCreateOrConnectWithoutMineralsInput = {
    where: MagnesiumWhereUniqueInput
    create: XOR<MagnesiumCreateWithoutMineralsInput, MagnesiumUncheckedCreateWithoutMineralsInput>
  }

  export type ChlorideCreateWithoutMineralsInput = {
    measurement: MeasurementCreateNestedOneWithoutChlorideInput
  }

  export type ChlorideUncheckedCreateWithoutMineralsInput = {
    id?: number
    measurementId: number
  }

  export type ChlorideCreateOrConnectWithoutMineralsInput = {
    where: ChlorideWhereUniqueInput
    create: XOR<ChlorideCreateWithoutMineralsInput, ChlorideUncheckedCreateWithoutMineralsInput>
  }

  export type ManganeseCreateWithoutMineralsInput = {
    measurement: MeasurementCreateNestedOneWithoutManganeseInput
  }

  export type ManganeseUncheckedCreateWithoutMineralsInput = {
    id?: number
    measurementId: number
  }

  export type ManganeseCreateOrConnectWithoutMineralsInput = {
    where: ManganeseWhereUniqueInput
    create: XOR<ManganeseCreateWithoutMineralsInput, ManganeseUncheckedCreateWithoutMineralsInput>
  }

  export type SulfurCreateWithoutMineralsInput = {
    measurement: MeasurementCreateNestedOneWithoutSulfurInput
  }

  export type SulfurUncheckedCreateWithoutMineralsInput = {
    id?: number
    measurementId: number
  }

  export type SulfurCreateOrConnectWithoutMineralsInput = {
    where: SulfurWhereUniqueInput
    create: XOR<SulfurCreateWithoutMineralsInput, SulfurUncheckedCreateWithoutMineralsInput>
  }

  export type PotassiumCreateWithoutMineralsInput = {
    measurement: MeasurementCreateNestedOneWithoutPotassiumInput
  }

  export type PotassiumUncheckedCreateWithoutMineralsInput = {
    id?: number
    measurementId: number
  }

  export type PotassiumCreateOrConnectWithoutMineralsInput = {
    where: PotassiumWhereUniqueInput
    create: XOR<PotassiumCreateWithoutMineralsInput, PotassiumUncheckedCreateWithoutMineralsInput>
  }

  export type FluorideCreateWithoutMineralsInput = {
    measurement: MeasurementCreateNestedOneWithoutFluorideInput
  }

  export type FluorideUncheckedCreateWithoutMineralsInput = {
    id?: number
    measurementId: number
  }

  export type FluorideCreateOrConnectWithoutMineralsInput = {
    where: FluorideWhereUniqueInput
    create: XOR<FluorideCreateWithoutMineralsInput, FluorideUncheckedCreateWithoutMineralsInput>
  }

  export type PhosphorousCreateWithoutMineralsInput = {
    measurement: MeasurementCreateNestedOneWithoutPhosphorousInput
  }

  export type PhosphorousUncheckedCreateWithoutMineralsInput = {
    id?: number
    measurementId: number
  }

  export type PhosphorousCreateOrConnectWithoutMineralsInput = {
    where: PhosphorousWhereUniqueInput
    create: XOR<PhosphorousCreateWithoutMineralsInput, PhosphorousUncheckedCreateWithoutMineralsInput>
  }

  export type CopperCreateWithoutMineralsInput = {
    measurement: MeasurementCreateNestedOneWithoutCopperInput
  }

  export type CopperUncheckedCreateWithoutMineralsInput = {
    id?: number
    measurementId: number
  }

  export type CopperCreateOrConnectWithoutMineralsInput = {
    where: CopperWhereUniqueInput
    create: XOR<CopperCreateWithoutMineralsInput, CopperUncheckedCreateWithoutMineralsInput>
  }

  export type IodineCreateWithoutMineralsInput = {
    measurement: MeasurementCreateNestedOneWithoutIodineInput
  }

  export type IodineUncheckedCreateWithoutMineralsInput = {
    id?: number
    measurementId: number
  }

  export type IodineCreateOrConnectWithoutMineralsInput = {
    where: IodineWhereUniqueInput
    create: XOR<IodineCreateWithoutMineralsInput, IodineUncheckedCreateWithoutMineralsInput>
  }

  export type CalciumCreateWithoutMineralsInput = {
    measurement: MeasurementCreateNestedOneWithoutCalciumInput
  }

  export type CalciumUncheckedCreateWithoutMineralsInput = {
    id?: number
    measurementId: number
  }

  export type CalciumCreateOrConnectWithoutMineralsInput = {
    where: CalciumWhereUniqueInput
    create: XOR<CalciumCreateWithoutMineralsInput, CalciumUncheckedCreateWithoutMineralsInput>
  }

  export type SaltUpsertWithoutMineralsInput = {
    update: XOR<SaltUpdateWithoutMineralsInput, SaltUncheckedUpdateWithoutMineralsInput>
    create: XOR<SaltCreateWithoutMineralsInput, SaltUncheckedCreateWithoutMineralsInput>
  }

  export type SaltUpdateWithoutMineralsInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutSaltInput
  }

  export type SaltUncheckedUpdateWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type NutritionFactUpsertWithWhereUniqueWithoutMineralsInput = {
    where: NutritionFactWhereUniqueInput
    update: XOR<NutritionFactUpdateWithoutMineralsInput, NutritionFactUncheckedUpdateWithoutMineralsInput>
    create: XOR<NutritionFactCreateWithoutMineralsInput, NutritionFactUncheckedCreateWithoutMineralsInput>
  }

  export type NutritionFactUpdateWithWhereUniqueWithoutMineralsInput = {
    where: NutritionFactWhereUniqueInput
    data: XOR<NutritionFactUpdateWithoutMineralsInput, NutritionFactUncheckedUpdateWithoutMineralsInput>
  }

  export type NutritionFactUpdateManyWithWhereWithoutMineralsInput = {
    where: NutritionFactScalarWhereInput
    data: XOR<NutritionFactUpdateManyMutationInput, NutritionFactUncheckedUpdateManyWithoutNutritionFactInput>
  }

  export type IronUpsertWithoutMineralsInput = {
    update: XOR<IronUpdateWithoutMineralsInput, IronUncheckedUpdateWithoutMineralsInput>
    create: XOR<IronCreateWithoutMineralsInput, IronUncheckedCreateWithoutMineralsInput>
  }

  export type IronUpdateWithoutMineralsInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutIronInput
  }

  export type IronUncheckedUpdateWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type ZincUpsertWithoutMineralsInput = {
    update: XOR<ZincUpdateWithoutMineralsInput, ZincUncheckedUpdateWithoutMineralsInput>
    create: XOR<ZincCreateWithoutMineralsInput, ZincUncheckedCreateWithoutMineralsInput>
  }

  export type ZincUpdateWithoutMineralsInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutZincInput
  }

  export type ZincUncheckedUpdateWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type MagnesiumUpsertWithoutMineralsInput = {
    update: XOR<MagnesiumUpdateWithoutMineralsInput, MagnesiumUncheckedUpdateWithoutMineralsInput>
    create: XOR<MagnesiumCreateWithoutMineralsInput, MagnesiumUncheckedCreateWithoutMineralsInput>
  }

  export type MagnesiumUpdateWithoutMineralsInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutMagnesiumInput
  }

  export type MagnesiumUncheckedUpdateWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type ChlorideUpsertWithoutMineralsInput = {
    update: XOR<ChlorideUpdateWithoutMineralsInput, ChlorideUncheckedUpdateWithoutMineralsInput>
    create: XOR<ChlorideCreateWithoutMineralsInput, ChlorideUncheckedCreateWithoutMineralsInput>
  }

  export type ChlorideUpdateWithoutMineralsInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutChlorideInput
  }

  export type ChlorideUncheckedUpdateWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type ManganeseUpsertWithoutMineralsInput = {
    update: XOR<ManganeseUpdateWithoutMineralsInput, ManganeseUncheckedUpdateWithoutMineralsInput>
    create: XOR<ManganeseCreateWithoutMineralsInput, ManganeseUncheckedCreateWithoutMineralsInput>
  }

  export type ManganeseUpdateWithoutMineralsInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutManganeseInput
  }

  export type ManganeseUncheckedUpdateWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type SulfurUpsertWithoutMineralsInput = {
    update: XOR<SulfurUpdateWithoutMineralsInput, SulfurUncheckedUpdateWithoutMineralsInput>
    create: XOR<SulfurCreateWithoutMineralsInput, SulfurUncheckedCreateWithoutMineralsInput>
  }

  export type SulfurUpdateWithoutMineralsInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutSulfurInput
  }

  export type SulfurUncheckedUpdateWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type PotassiumUpsertWithoutMineralsInput = {
    update: XOR<PotassiumUpdateWithoutMineralsInput, PotassiumUncheckedUpdateWithoutMineralsInput>
    create: XOR<PotassiumCreateWithoutMineralsInput, PotassiumUncheckedCreateWithoutMineralsInput>
  }

  export type PotassiumUpdateWithoutMineralsInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutPotassiumInput
  }

  export type PotassiumUncheckedUpdateWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type FluorideUpsertWithoutMineralsInput = {
    update: XOR<FluorideUpdateWithoutMineralsInput, FluorideUncheckedUpdateWithoutMineralsInput>
    create: XOR<FluorideCreateWithoutMineralsInput, FluorideUncheckedCreateWithoutMineralsInput>
  }

  export type FluorideUpdateWithoutMineralsInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutFluorideInput
  }

  export type FluorideUncheckedUpdateWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type PhosphorousUpsertWithoutMineralsInput = {
    update: XOR<PhosphorousUpdateWithoutMineralsInput, PhosphorousUncheckedUpdateWithoutMineralsInput>
    create: XOR<PhosphorousCreateWithoutMineralsInput, PhosphorousUncheckedCreateWithoutMineralsInput>
  }

  export type PhosphorousUpdateWithoutMineralsInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutPhosphorousInput
  }

  export type PhosphorousUncheckedUpdateWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type CopperUpsertWithoutMineralsInput = {
    update: XOR<CopperUpdateWithoutMineralsInput, CopperUncheckedUpdateWithoutMineralsInput>
    create: XOR<CopperCreateWithoutMineralsInput, CopperUncheckedCreateWithoutMineralsInput>
  }

  export type CopperUpdateWithoutMineralsInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutCopperInput
  }

  export type CopperUncheckedUpdateWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type IodineUpsertWithoutMineralsInput = {
    update: XOR<IodineUpdateWithoutMineralsInput, IodineUncheckedUpdateWithoutMineralsInput>
    create: XOR<IodineCreateWithoutMineralsInput, IodineUncheckedCreateWithoutMineralsInput>
  }

  export type IodineUpdateWithoutMineralsInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutIodineInput
  }

  export type IodineUncheckedUpdateWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type CalciumUpsertWithoutMineralsInput = {
    update: XOR<CalciumUpdateWithoutMineralsInput, CalciumUncheckedUpdateWithoutMineralsInput>
    create: XOR<CalciumCreateWithoutMineralsInput, CalciumUncheckedCreateWithoutMineralsInput>
  }

  export type CalciumUpdateWithoutMineralsInput = {
    measurement?: MeasurementUpdateOneRequiredWithoutCalciumInput
  }

  export type CalciumUncheckedUpdateWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type MeasurementCreateWithoutUnitInput = {
    value?: Decimal | number | string | null
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutUnitInput = {
    id?: number
    value?: Decimal | number | string | null
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutUnitInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutUnitInput, MeasurementUncheckedCreateWithoutUnitInput>
  }

  export type MeasurementCreateManyUnitInputEnvelope = {
    data: Enumerable<MeasurementCreateManyUnitInput>
    skipDuplicates?: boolean
  }

  export type MeasurementUpsertWithWhereUniqueWithoutUnitInput = {
    where: MeasurementWhereUniqueInput
    update: XOR<MeasurementUpdateWithoutUnitInput, MeasurementUncheckedUpdateWithoutUnitInput>
    create: XOR<MeasurementCreateWithoutUnitInput, MeasurementUncheckedCreateWithoutUnitInput>
  }

  export type MeasurementUpdateWithWhereUniqueWithoutUnitInput = {
    where: MeasurementWhereUniqueInput
    data: XOR<MeasurementUpdateWithoutUnitInput, MeasurementUncheckedUpdateWithoutUnitInput>
  }

  export type MeasurementUpdateManyWithWhereWithoutUnitInput = {
    where: MeasurementScalarWhereInput
    data: XOR<MeasurementUpdateManyMutationInput, MeasurementUncheckedUpdateManyWithoutMeasurementsInput>
  }

  export type UnitCreateWithoutMeasurementsInput = {
    name: string
    abbreviation: string
  }

  export type UnitUncheckedCreateWithoutMeasurementsInput = {
    id?: number
    name: string
    abbreviation: string
  }

  export type UnitCreateOrConnectWithoutMeasurementsInput = {
    where: UnitWhereUniqueInput
    create: XOR<UnitCreateWithoutMeasurementsInput, UnitUncheckedCreateWithoutMeasurementsInput>
  }

  export type ServingCreateWithoutMeasurementInput = {
    name: string
    products?: ProductCreateNestedManyWithoutServingInput
  }

  export type ServingUncheckedCreateWithoutMeasurementInput = {
    id?: number
    name: string
    products?: ProductUncheckedCreateNestedManyWithoutServingInput
  }

  export type ServingCreateOrConnectWithoutMeasurementInput = {
    where: ServingWhereUniqueInput
    create: XOR<ServingCreateWithoutMeasurementInput, ServingUncheckedCreateWithoutMeasurementInput>
  }

  export type ServingCreateManyMeasurementInputEnvelope = {
    data: Enumerable<ServingCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type VitaminCreateWithoutMeasurementsInput = {
    C?: VitaminCCreateNestedOneWithoutVitaminInput
    A?: VitaminACreateNestedOneWithoutVitaminInput
    D?: VitaminDCreateNestedOneWithoutVitaminInput
    E?: VitaminECreateNestedOneWithoutVitaminInput
    B1?: VitaminB1CreateNestedOneWithoutVitaminInput
    B2?: VitaminB2CreateNestedOneWithoutVitaminInput
    B6?: VitaminB6CreateNestedOneWithoutVitaminInput
    B12?: VitaminB12CreateNestedOneWithoutVitaminInput
    nutritionFacts?: NutritionFactCreateNestedManyWithoutVitaminsInput
  }

  export type VitaminUncheckedCreateWithoutMeasurementsInput = {
    id?: number
    nutritionFacts?: NutritionFactUncheckedCreateNestedManyWithoutVitaminsInput
    vitaminCId?: number | null
    vitaminAId?: number | null
    vitaminDId?: number | null
    vitaminEId?: number | null
    vitaminB1Id?: number | null
    vitaminB2Id?: number | null
    vitaminB6Id?: number | null
    vitaminB12Id?: number | null
  }

  export type VitaminCreateOrConnectWithoutMeasurementsInput = {
    where: VitaminWhereUniqueInput
    create: XOR<VitaminCreateWithoutMeasurementsInput, VitaminUncheckedCreateWithoutMeasurementsInput>
  }

  export type SaltCreateWithoutMeasurementInput = {
    minerals?: MineralCreateNestedManyWithoutSaltInput
  }

  export type SaltUncheckedCreateWithoutMeasurementInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutSaltInput
  }

  export type SaltCreateOrConnectWithoutMeasurementInput = {
    where: SaltWhereUniqueInput
    create: XOR<SaltCreateWithoutMeasurementInput, SaltUncheckedCreateWithoutMeasurementInput>
  }

  export type SaltCreateManyMeasurementInputEnvelope = {
    data: Enumerable<SaltCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type ZincCreateWithoutMeasurementInput = {
    minerals?: MineralCreateNestedManyWithoutZincInput
  }

  export type ZincUncheckedCreateWithoutMeasurementInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutZincInput
  }

  export type ZincCreateOrConnectWithoutMeasurementInput = {
    where: ZincWhereUniqueInput
    create: XOR<ZincCreateWithoutMeasurementInput, ZincUncheckedCreateWithoutMeasurementInput>
  }

  export type ZincCreateManyMeasurementInputEnvelope = {
    data: Enumerable<ZincCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type IronCreateWithoutMeasurementInput = {
    minerals?: MineralCreateNestedManyWithoutIronInput
  }

  export type IronUncheckedCreateWithoutMeasurementInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutIronInput
  }

  export type IronCreateOrConnectWithoutMeasurementInput = {
    where: IronWhereUniqueInput
    create: XOR<IronCreateWithoutMeasurementInput, IronUncheckedCreateWithoutMeasurementInput>
  }

  export type IronCreateManyMeasurementInputEnvelope = {
    data: Enumerable<IronCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type MagnesiumCreateWithoutMeasurementInput = {
    minerals?: MineralCreateNestedManyWithoutMagnesiumInput
  }

  export type MagnesiumUncheckedCreateWithoutMeasurementInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutMagnesiumInput
  }

  export type MagnesiumCreateOrConnectWithoutMeasurementInput = {
    where: MagnesiumWhereUniqueInput
    create: XOR<MagnesiumCreateWithoutMeasurementInput, MagnesiumUncheckedCreateWithoutMeasurementInput>
  }

  export type MagnesiumCreateManyMeasurementInputEnvelope = {
    data: Enumerable<MagnesiumCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type ChlorideCreateWithoutMeasurementInput = {
    minerals?: MineralCreateNestedManyWithoutChlorideInput
  }

  export type ChlorideUncheckedCreateWithoutMeasurementInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutChlorideInput
  }

  export type ChlorideCreateOrConnectWithoutMeasurementInput = {
    where: ChlorideWhereUniqueInput
    create: XOR<ChlorideCreateWithoutMeasurementInput, ChlorideUncheckedCreateWithoutMeasurementInput>
  }

  export type ChlorideCreateManyMeasurementInputEnvelope = {
    data: Enumerable<ChlorideCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type ManganeseCreateWithoutMeasurementInput = {
    minerals?: MineralCreateNestedManyWithoutManganeseInput
  }

  export type ManganeseUncheckedCreateWithoutMeasurementInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutManganeseInput
  }

  export type ManganeseCreateOrConnectWithoutMeasurementInput = {
    where: ManganeseWhereUniqueInput
    create: XOR<ManganeseCreateWithoutMeasurementInput, ManganeseUncheckedCreateWithoutMeasurementInput>
  }

  export type ManganeseCreateManyMeasurementInputEnvelope = {
    data: Enumerable<ManganeseCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type SulfurCreateWithoutMeasurementInput = {
    minerals?: MineralCreateNestedManyWithoutSulfurInput
  }

  export type SulfurUncheckedCreateWithoutMeasurementInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutSulfurInput
  }

  export type SulfurCreateOrConnectWithoutMeasurementInput = {
    where: SulfurWhereUniqueInput
    create: XOR<SulfurCreateWithoutMeasurementInput, SulfurUncheckedCreateWithoutMeasurementInput>
  }

  export type SulfurCreateManyMeasurementInputEnvelope = {
    data: Enumerable<SulfurCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type PotassiumCreateWithoutMeasurementInput = {
    minerals?: MineralCreateNestedManyWithoutPotassiumInput
  }

  export type PotassiumUncheckedCreateWithoutMeasurementInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutPotassiumInput
  }

  export type PotassiumCreateOrConnectWithoutMeasurementInput = {
    where: PotassiumWhereUniqueInput
    create: XOR<PotassiumCreateWithoutMeasurementInput, PotassiumUncheckedCreateWithoutMeasurementInput>
  }

  export type PotassiumCreateManyMeasurementInputEnvelope = {
    data: Enumerable<PotassiumCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type FluorideCreateWithoutMeasurementInput = {
    minerals?: MineralCreateNestedManyWithoutFluorideInput
  }

  export type FluorideUncheckedCreateWithoutMeasurementInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutFluorideInput
  }

  export type FluorideCreateOrConnectWithoutMeasurementInput = {
    where: FluorideWhereUniqueInput
    create: XOR<FluorideCreateWithoutMeasurementInput, FluorideUncheckedCreateWithoutMeasurementInput>
  }

  export type FluorideCreateManyMeasurementInputEnvelope = {
    data: Enumerable<FluorideCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type PhosphorousCreateWithoutMeasurementInput = {
    minerals?: MineralCreateNestedManyWithoutPhosphorousInput
  }

  export type PhosphorousUncheckedCreateWithoutMeasurementInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutPhosphorousInput
  }

  export type PhosphorousCreateOrConnectWithoutMeasurementInput = {
    where: PhosphorousWhereUniqueInput
    create: XOR<PhosphorousCreateWithoutMeasurementInput, PhosphorousUncheckedCreateWithoutMeasurementInput>
  }

  export type PhosphorousCreateManyMeasurementInputEnvelope = {
    data: Enumerable<PhosphorousCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type CopperCreateWithoutMeasurementInput = {
    minerals?: MineralCreateNestedManyWithoutCopperInput
  }

  export type CopperUncheckedCreateWithoutMeasurementInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutCopperInput
  }

  export type CopperCreateOrConnectWithoutMeasurementInput = {
    where: CopperWhereUniqueInput
    create: XOR<CopperCreateWithoutMeasurementInput, CopperUncheckedCreateWithoutMeasurementInput>
  }

  export type CopperCreateManyMeasurementInputEnvelope = {
    data: Enumerable<CopperCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type IodineCreateWithoutMeasurementInput = {
    minerals?: MineralCreateNestedManyWithoutIodineInput
  }

  export type IodineUncheckedCreateWithoutMeasurementInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutIodineInput
  }

  export type IodineCreateOrConnectWithoutMeasurementInput = {
    where: IodineWhereUniqueInput
    create: XOR<IodineCreateWithoutMeasurementInput, IodineUncheckedCreateWithoutMeasurementInput>
  }

  export type IodineCreateManyMeasurementInputEnvelope = {
    data: Enumerable<IodineCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type CalciumCreateWithoutMeasurementInput = {
    minerals?: MineralCreateNestedManyWithoutCalciumInput
  }

  export type CalciumUncheckedCreateWithoutMeasurementInput = {
    id?: number
    minerals?: MineralUncheckedCreateNestedManyWithoutCalciumInput
  }

  export type CalciumCreateOrConnectWithoutMeasurementInput = {
    where: CalciumWhereUniqueInput
    create: XOR<CalciumCreateWithoutMeasurementInput, CalciumUncheckedCreateWithoutMeasurementInput>
  }

  export type CalciumCreateManyMeasurementInputEnvelope = {
    data: Enumerable<CalciumCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type TotalFatCreateWithoutMeasurementInput = {
    fat?: FatCreateNestedOneWithoutTotalInput
  }

  export type TotalFatUncheckedCreateWithoutMeasurementInput = {
    id?: number
    fat?: FatUncheckedCreateNestedOneWithoutTotalInput
  }

  export type TotalFatCreateOrConnectWithoutMeasurementInput = {
    where: TotalFatWhereUniqueInput
    create: XOR<TotalFatCreateWithoutMeasurementInput, TotalFatUncheckedCreateWithoutMeasurementInput>
  }

  export type TotalFatCreateManyMeasurementInputEnvelope = {
    data: Enumerable<TotalFatCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type SaturatedFatCreateWithoutMeasurementInput = {
    fat?: FatCreateNestedOneWithoutSaturatedInput
  }

  export type SaturatedFatUncheckedCreateWithoutMeasurementInput = {
    id?: number
    fat?: FatUncheckedCreateNestedOneWithoutSaturatedInput
  }

  export type SaturatedFatCreateOrConnectWithoutMeasurementInput = {
    where: SaturatedFatWhereUniqueInput
    create: XOR<SaturatedFatCreateWithoutMeasurementInput, SaturatedFatUncheckedCreateWithoutMeasurementInput>
  }

  export type SaturatedFatCreateManyMeasurementInputEnvelope = {
    data: Enumerable<SaturatedFatCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type MonosaturatedFatCreateWithoutMeasurementInput = {
    fat?: FatCreateNestedOneWithoutMonounsaturatedInput
  }

  export type MonosaturatedFatUncheckedCreateWithoutMeasurementInput = {
    id?: number
    fat?: FatUncheckedCreateNestedOneWithoutMonounsaturatedInput
  }

  export type MonosaturatedFatCreateOrConnectWithoutMeasurementInput = {
    where: MonosaturatedFatWhereUniqueInput
    create: XOR<MonosaturatedFatCreateWithoutMeasurementInput, MonosaturatedFatUncheckedCreateWithoutMeasurementInput>
  }

  export type MonosaturatedFatCreateManyMeasurementInputEnvelope = {
    data: Enumerable<MonosaturatedFatCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type PolyunsaturatedFatCreateWithoutMeasurementInput = {
    fat?: FatCreateNestedOneWithoutPolyunsaturatedInput
  }

  export type PolyunsaturatedFatUncheckedCreateWithoutMeasurementInput = {
    id?: number
    fat?: FatUncheckedCreateNestedOneWithoutPolyunsaturatedInput
  }

  export type PolyunsaturatedFatCreateOrConnectWithoutMeasurementInput = {
    where: PolyunsaturatedFatWhereUniqueInput
    create: XOR<PolyunsaturatedFatCreateWithoutMeasurementInput, PolyunsaturatedFatUncheckedCreateWithoutMeasurementInput>
  }

  export type PolyunsaturatedFatCreateManyMeasurementInputEnvelope = {
    data: Enumerable<PolyunsaturatedFatCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type TransFatCreateWithoutMeasurementInput = {
    fat?: FatCreateNestedOneWithoutTransInput
  }

  export type TransFatUncheckedCreateWithoutMeasurementInput = {
    id?: number
    fat?: FatUncheckedCreateNestedOneWithoutTransInput
  }

  export type TransFatCreateOrConnectWithoutMeasurementInput = {
    where: TransFatWhereUniqueInput
    create: XOR<TransFatCreateWithoutMeasurementInput, TransFatUncheckedCreateWithoutMeasurementInput>
  }

  export type TransFatCreateManyMeasurementInputEnvelope = {
    data: Enumerable<TransFatCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type TotalCarbohydrateCreateWithoutMeasurementInput = {
    carbohydrate?: CarbohydrateCreateNestedOneWithoutTotalInput
  }

  export type TotalCarbohydrateUncheckedCreateWithoutMeasurementInput = {
    id?: number
    carbohydrate?: CarbohydrateUncheckedCreateNestedOneWithoutTotalInput
  }

  export type TotalCarbohydrateCreateOrConnectWithoutMeasurementInput = {
    where: TotalCarbohydrateWhereUniqueInput
    create: XOR<TotalCarbohydrateCreateWithoutMeasurementInput, TotalCarbohydrateUncheckedCreateWithoutMeasurementInput>
  }

  export type TotalCarbohydrateCreateManyMeasurementInputEnvelope = {
    data: Enumerable<TotalCarbohydrateCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type SugarCarbohydrateCreateWithoutMeasurementInput = {
    carbohydrate?: CarbohydrateCreateNestedOneWithoutSugarInput
  }

  export type SugarCarbohydrateUncheckedCreateWithoutMeasurementInput = {
    id?: number
    carbohydrate?: CarbohydrateUncheckedCreateNestedOneWithoutSugarInput
  }

  export type SugarCarbohydrateCreateOrConnectWithoutMeasurementInput = {
    where: SugarCarbohydrateWhereUniqueInput
    create: XOR<SugarCarbohydrateCreateWithoutMeasurementInput, SugarCarbohydrateUncheckedCreateWithoutMeasurementInput>
  }

  export type SugarCarbohydrateCreateManyMeasurementInputEnvelope = {
    data: Enumerable<SugarCarbohydrateCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type VitaminCCreateWithoutMeasurementInput = {
    vitamin?: VitaminCreateNestedOneWithoutCInput
  }

  export type VitaminCUncheckedCreateWithoutMeasurementInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutCInput
  }

  export type VitaminCCreateOrConnectWithoutMeasurementInput = {
    where: VitaminCWhereUniqueInput
    create: XOR<VitaminCCreateWithoutMeasurementInput, VitaminCUncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminCCreateManyMeasurementInputEnvelope = {
    data: Enumerable<VitaminCCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type VitaminACreateWithoutMeasurementInput = {
    vitamin?: VitaminCreateNestedOneWithoutAInput
  }

  export type VitaminAUncheckedCreateWithoutMeasurementInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutAInput
  }

  export type VitaminACreateOrConnectWithoutMeasurementInput = {
    where: VitaminAWhereUniqueInput
    create: XOR<VitaminACreateWithoutMeasurementInput, VitaminAUncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminACreateManyMeasurementInputEnvelope = {
    data: Enumerable<VitaminACreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type VitaminDCreateWithoutMeasurementInput = {
    vitamin?: VitaminCreateNestedOneWithoutDInput
  }

  export type VitaminDUncheckedCreateWithoutMeasurementInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutDInput
  }

  export type VitaminDCreateOrConnectWithoutMeasurementInput = {
    where: VitaminDWhereUniqueInput
    create: XOR<VitaminDCreateWithoutMeasurementInput, VitaminDUncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminDCreateManyMeasurementInputEnvelope = {
    data: Enumerable<VitaminDCreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type VitaminECreateWithoutMeasurementInput = {
    vitamin?: VitaminCreateNestedOneWithoutEInput
  }

  export type VitaminEUncheckedCreateWithoutMeasurementInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutEInput
  }

  export type VitaminECreateOrConnectWithoutMeasurementInput = {
    where: VitaminEWhereUniqueInput
    create: XOR<VitaminECreateWithoutMeasurementInput, VitaminEUncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminECreateManyMeasurementInputEnvelope = {
    data: Enumerable<VitaminECreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type VitaminB1CreateWithoutMeasurementInput = {
    vitamin?: VitaminCreateNestedOneWithoutB1Input
  }

  export type VitaminB1UncheckedCreateWithoutMeasurementInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutB1Input
  }

  export type VitaminB1CreateOrConnectWithoutMeasurementInput = {
    where: VitaminB1WhereUniqueInput
    create: XOR<VitaminB1CreateWithoutMeasurementInput, VitaminB1UncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminB1CreateManyMeasurementInputEnvelope = {
    data: Enumerable<VitaminB1CreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type VitaminB2CreateWithoutMeasurementInput = {
    vitamin?: VitaminCreateNestedOneWithoutB2Input
  }

  export type VitaminB2UncheckedCreateWithoutMeasurementInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutB2Input
  }

  export type VitaminB2CreateOrConnectWithoutMeasurementInput = {
    where: VitaminB2WhereUniqueInput
    create: XOR<VitaminB2CreateWithoutMeasurementInput, VitaminB2UncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminB2CreateManyMeasurementInputEnvelope = {
    data: Enumerable<VitaminB2CreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type VitaminB6CreateWithoutMeasurementInput = {
    vitamin?: VitaminCreateNestedOneWithoutB6Input
  }

  export type VitaminB6UncheckedCreateWithoutMeasurementInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutB6Input
  }

  export type VitaminB6CreateOrConnectWithoutMeasurementInput = {
    where: VitaminB6WhereUniqueInput
    create: XOR<VitaminB6CreateWithoutMeasurementInput, VitaminB6UncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminB6CreateManyMeasurementInputEnvelope = {
    data: Enumerable<VitaminB6CreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type VitaminB12CreateWithoutMeasurementInput = {
    vitamin?: VitaminCreateNestedOneWithoutB12Input
  }

  export type VitaminB12UncheckedCreateWithoutMeasurementInput = {
    id?: number
    vitamin?: VitaminUncheckedCreateNestedOneWithoutB12Input
  }

  export type VitaminB12CreateOrConnectWithoutMeasurementInput = {
    where: VitaminB12WhereUniqueInput
    create: XOR<VitaminB12CreateWithoutMeasurementInput, VitaminB12UncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminB12CreateManyMeasurementInputEnvelope = {
    data: Enumerable<VitaminB12CreateManyMeasurementInput>
    skipDuplicates?: boolean
  }

  export type EnergyCreateWithoutMeasurementsInput = {
    nutritionFact: NutritionFactCreateNestedOneWithoutEnergyInput
  }

  export type EnergyUncheckedCreateWithoutMeasurementsInput = {
    id?: number
    nutritionFactId: number
  }

  export type EnergyCreateOrConnectWithoutMeasurementsInput = {
    where: EnergyWhereUniqueInput
    create: XOR<EnergyCreateWithoutMeasurementsInput, EnergyUncheckedCreateWithoutMeasurementsInput>
  }

  export type ProteinCreateWithoutMeasurementsInput = {
    NutritionFact?: NutritionFactCreateNestedManyWithoutProteinInput
  }

  export type ProteinUncheckedCreateWithoutMeasurementsInput = {
    id?: number
    NutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutProteinInput
  }

  export type ProteinCreateOrConnectWithoutMeasurementsInput = {
    where: ProteinWhereUniqueInput
    create: XOR<ProteinCreateWithoutMeasurementsInput, ProteinUncheckedCreateWithoutMeasurementsInput>
  }

  export type CholesterolCreateWithoutMeasurementsInput = {
    NutritionFact?: NutritionFactCreateNestedManyWithoutCholesterolInput
  }

  export type CholesterolUncheckedCreateWithoutMeasurementsInput = {
    id?: number
    NutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutCholesterolInput
  }

  export type CholesterolCreateOrConnectWithoutMeasurementsInput = {
    where: CholesterolWhereUniqueInput
    create: XOR<CholesterolCreateWithoutMeasurementsInput, CholesterolUncheckedCreateWithoutMeasurementsInput>
  }

  export type FiberCreateWithoutMeasurementsInput = {
    NutritionFact?: NutritionFactCreateNestedManyWithoutFiberInput
  }

  export type FiberUncheckedCreateWithoutMeasurementsInput = {
    id?: number
    NutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutFiberInput
  }

  export type FiberCreateOrConnectWithoutMeasurementsInput = {
    where: FiberWhereUniqueInput
    create: XOR<FiberCreateWithoutMeasurementsInput, FiberUncheckedCreateWithoutMeasurementsInput>
  }

  export type WaterCreateWithoutMeasurementsInput = {
    NutritionFact?: NutritionFactCreateNestedManyWithoutWaterInput
  }

  export type WaterUncheckedCreateWithoutMeasurementsInput = {
    id?: number
    NutritionFact?: NutritionFactUncheckedCreateNestedManyWithoutWaterInput
  }

  export type WaterCreateOrConnectWithoutMeasurementsInput = {
    where: WaterWhereUniqueInput
    create: XOR<WaterCreateWithoutMeasurementsInput, WaterUncheckedCreateWithoutMeasurementsInput>
  }

  export type UnitUpsertWithoutMeasurementsInput = {
    update: XOR<UnitUpdateWithoutMeasurementsInput, UnitUncheckedUpdateWithoutMeasurementsInput>
    create: XOR<UnitCreateWithoutMeasurementsInput, UnitUncheckedCreateWithoutMeasurementsInput>
  }

  export type UnitUpdateWithoutMeasurementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type UnitUncheckedUpdateWithoutMeasurementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    abbreviation?: StringFieldUpdateOperationsInput | string
  }

  export type ServingUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: ServingWhereUniqueInput
    update: XOR<ServingUpdateWithoutMeasurementInput, ServingUncheckedUpdateWithoutMeasurementInput>
    create: XOR<ServingCreateWithoutMeasurementInput, ServingUncheckedCreateWithoutMeasurementInput>
  }

  export type ServingUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: ServingWhereUniqueInput
    data: XOR<ServingUpdateWithoutMeasurementInput, ServingUncheckedUpdateWithoutMeasurementInput>
  }

  export type ServingUpdateManyWithWhereWithoutMeasurementInput = {
    where: ServingScalarWhereInput
    data: XOR<ServingUpdateManyMutationInput, ServingUncheckedUpdateManyWithoutServingsInput>
  }

  export type ServingScalarWhereInput = {
    AND?: Enumerable<ServingScalarWhereInput>
    OR?: Enumerable<ServingScalarWhereInput>
    NOT?: Enumerable<ServingScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
    measurementId?: IntFilter | number
  }

  export type VitaminUpsertWithWhereUniqueWithoutMeasurementsInput = {
    where: VitaminWhereUniqueInput
    update: XOR<VitaminUpdateWithoutMeasurementsInput, VitaminUncheckedUpdateWithoutMeasurementsInput>
    create: XOR<VitaminCreateWithoutMeasurementsInput, VitaminUncheckedCreateWithoutMeasurementsInput>
  }

  export type VitaminUpdateWithWhereUniqueWithoutMeasurementsInput = {
    where: VitaminWhereUniqueInput
    data: XOR<VitaminUpdateWithoutMeasurementsInput, VitaminUncheckedUpdateWithoutMeasurementsInput>
  }

  export type VitaminUpdateManyWithWhereWithoutMeasurementsInput = {
    where: VitaminScalarWhereInput
    data: XOR<VitaminUpdateManyMutationInput, VitaminUncheckedUpdateManyWithoutVitaminInput>
  }

  export type VitaminScalarWhereInput = {
    AND?: Enumerable<VitaminScalarWhereInput>
    OR?: Enumerable<VitaminScalarWhereInput>
    NOT?: Enumerable<VitaminScalarWhereInput>
    id?: IntFilter | number
    vitaminCId?: IntNullableFilter | number | null
    vitaminAId?: IntNullableFilter | number | null
    vitaminDId?: IntNullableFilter | number | null
    vitaminEId?: IntNullableFilter | number | null
    vitaminB1Id?: IntNullableFilter | number | null
    vitaminB2Id?: IntNullableFilter | number | null
    vitaminB6Id?: IntNullableFilter | number | null
    vitaminB12Id?: IntNullableFilter | number | null
  }

  export type SaltUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: SaltWhereUniqueInput
    update: XOR<SaltUpdateWithoutMeasurementInput, SaltUncheckedUpdateWithoutMeasurementInput>
    create: XOR<SaltCreateWithoutMeasurementInput, SaltUncheckedCreateWithoutMeasurementInput>
  }

  export type SaltUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: SaltWhereUniqueInput
    data: XOR<SaltUpdateWithoutMeasurementInput, SaltUncheckedUpdateWithoutMeasurementInput>
  }

  export type SaltUpdateManyWithWhereWithoutMeasurementInput = {
    where: SaltScalarWhereInput
    data: XOR<SaltUpdateManyMutationInput, SaltUncheckedUpdateManyWithoutSaltInput>
  }

  export type SaltScalarWhereInput = {
    AND?: Enumerable<SaltScalarWhereInput>
    OR?: Enumerable<SaltScalarWhereInput>
    NOT?: Enumerable<SaltScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type ZincUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: ZincWhereUniqueInput
    update: XOR<ZincUpdateWithoutMeasurementInput, ZincUncheckedUpdateWithoutMeasurementInput>
    create: XOR<ZincCreateWithoutMeasurementInput, ZincUncheckedCreateWithoutMeasurementInput>
  }

  export type ZincUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: ZincWhereUniqueInput
    data: XOR<ZincUpdateWithoutMeasurementInput, ZincUncheckedUpdateWithoutMeasurementInput>
  }

  export type ZincUpdateManyWithWhereWithoutMeasurementInput = {
    where: ZincScalarWhereInput
    data: XOR<ZincUpdateManyMutationInput, ZincUncheckedUpdateManyWithoutZincInput>
  }

  export type ZincScalarWhereInput = {
    AND?: Enumerable<ZincScalarWhereInput>
    OR?: Enumerable<ZincScalarWhereInput>
    NOT?: Enumerable<ZincScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type IronUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: IronWhereUniqueInput
    update: XOR<IronUpdateWithoutMeasurementInput, IronUncheckedUpdateWithoutMeasurementInput>
    create: XOR<IronCreateWithoutMeasurementInput, IronUncheckedCreateWithoutMeasurementInput>
  }

  export type IronUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: IronWhereUniqueInput
    data: XOR<IronUpdateWithoutMeasurementInput, IronUncheckedUpdateWithoutMeasurementInput>
  }

  export type IronUpdateManyWithWhereWithoutMeasurementInput = {
    where: IronScalarWhereInput
    data: XOR<IronUpdateManyMutationInput, IronUncheckedUpdateManyWithoutIronInput>
  }

  export type IronScalarWhereInput = {
    AND?: Enumerable<IronScalarWhereInput>
    OR?: Enumerable<IronScalarWhereInput>
    NOT?: Enumerable<IronScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type MagnesiumUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: MagnesiumWhereUniqueInput
    update: XOR<MagnesiumUpdateWithoutMeasurementInput, MagnesiumUncheckedUpdateWithoutMeasurementInput>
    create: XOR<MagnesiumCreateWithoutMeasurementInput, MagnesiumUncheckedCreateWithoutMeasurementInput>
  }

  export type MagnesiumUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: MagnesiumWhereUniqueInput
    data: XOR<MagnesiumUpdateWithoutMeasurementInput, MagnesiumUncheckedUpdateWithoutMeasurementInput>
  }

  export type MagnesiumUpdateManyWithWhereWithoutMeasurementInput = {
    where: MagnesiumScalarWhereInput
    data: XOR<MagnesiumUpdateManyMutationInput, MagnesiumUncheckedUpdateManyWithoutMagnesiumInput>
  }

  export type MagnesiumScalarWhereInput = {
    AND?: Enumerable<MagnesiumScalarWhereInput>
    OR?: Enumerable<MagnesiumScalarWhereInput>
    NOT?: Enumerable<MagnesiumScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type ChlorideUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: ChlorideWhereUniqueInput
    update: XOR<ChlorideUpdateWithoutMeasurementInput, ChlorideUncheckedUpdateWithoutMeasurementInput>
    create: XOR<ChlorideCreateWithoutMeasurementInput, ChlorideUncheckedCreateWithoutMeasurementInput>
  }

  export type ChlorideUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: ChlorideWhereUniqueInput
    data: XOR<ChlorideUpdateWithoutMeasurementInput, ChlorideUncheckedUpdateWithoutMeasurementInput>
  }

  export type ChlorideUpdateManyWithWhereWithoutMeasurementInput = {
    where: ChlorideScalarWhereInput
    data: XOR<ChlorideUpdateManyMutationInput, ChlorideUncheckedUpdateManyWithoutChlorideInput>
  }

  export type ChlorideScalarWhereInput = {
    AND?: Enumerable<ChlorideScalarWhereInput>
    OR?: Enumerable<ChlorideScalarWhereInput>
    NOT?: Enumerable<ChlorideScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type ManganeseUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: ManganeseWhereUniqueInput
    update: XOR<ManganeseUpdateWithoutMeasurementInput, ManganeseUncheckedUpdateWithoutMeasurementInput>
    create: XOR<ManganeseCreateWithoutMeasurementInput, ManganeseUncheckedCreateWithoutMeasurementInput>
  }

  export type ManganeseUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: ManganeseWhereUniqueInput
    data: XOR<ManganeseUpdateWithoutMeasurementInput, ManganeseUncheckedUpdateWithoutMeasurementInput>
  }

  export type ManganeseUpdateManyWithWhereWithoutMeasurementInput = {
    where: ManganeseScalarWhereInput
    data: XOR<ManganeseUpdateManyMutationInput, ManganeseUncheckedUpdateManyWithoutManganeseInput>
  }

  export type ManganeseScalarWhereInput = {
    AND?: Enumerable<ManganeseScalarWhereInput>
    OR?: Enumerable<ManganeseScalarWhereInput>
    NOT?: Enumerable<ManganeseScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type SulfurUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: SulfurWhereUniqueInput
    update: XOR<SulfurUpdateWithoutMeasurementInput, SulfurUncheckedUpdateWithoutMeasurementInput>
    create: XOR<SulfurCreateWithoutMeasurementInput, SulfurUncheckedCreateWithoutMeasurementInput>
  }

  export type SulfurUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: SulfurWhereUniqueInput
    data: XOR<SulfurUpdateWithoutMeasurementInput, SulfurUncheckedUpdateWithoutMeasurementInput>
  }

  export type SulfurUpdateManyWithWhereWithoutMeasurementInput = {
    where: SulfurScalarWhereInput
    data: XOR<SulfurUpdateManyMutationInput, SulfurUncheckedUpdateManyWithoutSulfurInput>
  }

  export type SulfurScalarWhereInput = {
    AND?: Enumerable<SulfurScalarWhereInput>
    OR?: Enumerable<SulfurScalarWhereInput>
    NOT?: Enumerable<SulfurScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type PotassiumUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: PotassiumWhereUniqueInput
    update: XOR<PotassiumUpdateWithoutMeasurementInput, PotassiumUncheckedUpdateWithoutMeasurementInput>
    create: XOR<PotassiumCreateWithoutMeasurementInput, PotassiumUncheckedCreateWithoutMeasurementInput>
  }

  export type PotassiumUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: PotassiumWhereUniqueInput
    data: XOR<PotassiumUpdateWithoutMeasurementInput, PotassiumUncheckedUpdateWithoutMeasurementInput>
  }

  export type PotassiumUpdateManyWithWhereWithoutMeasurementInput = {
    where: PotassiumScalarWhereInput
    data: XOR<PotassiumUpdateManyMutationInput, PotassiumUncheckedUpdateManyWithoutPotassiumInput>
  }

  export type PotassiumScalarWhereInput = {
    AND?: Enumerable<PotassiumScalarWhereInput>
    OR?: Enumerable<PotassiumScalarWhereInput>
    NOT?: Enumerable<PotassiumScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type FluorideUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: FluorideWhereUniqueInput
    update: XOR<FluorideUpdateWithoutMeasurementInput, FluorideUncheckedUpdateWithoutMeasurementInput>
    create: XOR<FluorideCreateWithoutMeasurementInput, FluorideUncheckedCreateWithoutMeasurementInput>
  }

  export type FluorideUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: FluorideWhereUniqueInput
    data: XOR<FluorideUpdateWithoutMeasurementInput, FluorideUncheckedUpdateWithoutMeasurementInput>
  }

  export type FluorideUpdateManyWithWhereWithoutMeasurementInput = {
    where: FluorideScalarWhereInput
    data: XOR<FluorideUpdateManyMutationInput, FluorideUncheckedUpdateManyWithoutFluorideInput>
  }

  export type FluorideScalarWhereInput = {
    AND?: Enumerable<FluorideScalarWhereInput>
    OR?: Enumerable<FluorideScalarWhereInput>
    NOT?: Enumerable<FluorideScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type PhosphorousUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: PhosphorousWhereUniqueInput
    update: XOR<PhosphorousUpdateWithoutMeasurementInput, PhosphorousUncheckedUpdateWithoutMeasurementInput>
    create: XOR<PhosphorousCreateWithoutMeasurementInput, PhosphorousUncheckedCreateWithoutMeasurementInput>
  }

  export type PhosphorousUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: PhosphorousWhereUniqueInput
    data: XOR<PhosphorousUpdateWithoutMeasurementInput, PhosphorousUncheckedUpdateWithoutMeasurementInput>
  }

  export type PhosphorousUpdateManyWithWhereWithoutMeasurementInput = {
    where: PhosphorousScalarWhereInput
    data: XOR<PhosphorousUpdateManyMutationInput, PhosphorousUncheckedUpdateManyWithoutPhosphorousInput>
  }

  export type PhosphorousScalarWhereInput = {
    AND?: Enumerable<PhosphorousScalarWhereInput>
    OR?: Enumerable<PhosphorousScalarWhereInput>
    NOT?: Enumerable<PhosphorousScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type CopperUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: CopperWhereUniqueInput
    update: XOR<CopperUpdateWithoutMeasurementInput, CopperUncheckedUpdateWithoutMeasurementInput>
    create: XOR<CopperCreateWithoutMeasurementInput, CopperUncheckedCreateWithoutMeasurementInput>
  }

  export type CopperUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: CopperWhereUniqueInput
    data: XOR<CopperUpdateWithoutMeasurementInput, CopperUncheckedUpdateWithoutMeasurementInput>
  }

  export type CopperUpdateManyWithWhereWithoutMeasurementInput = {
    where: CopperScalarWhereInput
    data: XOR<CopperUpdateManyMutationInput, CopperUncheckedUpdateManyWithoutCopperInput>
  }

  export type CopperScalarWhereInput = {
    AND?: Enumerable<CopperScalarWhereInput>
    OR?: Enumerable<CopperScalarWhereInput>
    NOT?: Enumerable<CopperScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type IodineUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: IodineWhereUniqueInput
    update: XOR<IodineUpdateWithoutMeasurementInput, IodineUncheckedUpdateWithoutMeasurementInput>
    create: XOR<IodineCreateWithoutMeasurementInput, IodineUncheckedCreateWithoutMeasurementInput>
  }

  export type IodineUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: IodineWhereUniqueInput
    data: XOR<IodineUpdateWithoutMeasurementInput, IodineUncheckedUpdateWithoutMeasurementInput>
  }

  export type IodineUpdateManyWithWhereWithoutMeasurementInput = {
    where: IodineScalarWhereInput
    data: XOR<IodineUpdateManyMutationInput, IodineUncheckedUpdateManyWithoutIodineInput>
  }

  export type IodineScalarWhereInput = {
    AND?: Enumerable<IodineScalarWhereInput>
    OR?: Enumerable<IodineScalarWhereInput>
    NOT?: Enumerable<IodineScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type CalciumUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: CalciumWhereUniqueInput
    update: XOR<CalciumUpdateWithoutMeasurementInput, CalciumUncheckedUpdateWithoutMeasurementInput>
    create: XOR<CalciumCreateWithoutMeasurementInput, CalciumUncheckedCreateWithoutMeasurementInput>
  }

  export type CalciumUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: CalciumWhereUniqueInput
    data: XOR<CalciumUpdateWithoutMeasurementInput, CalciumUncheckedUpdateWithoutMeasurementInput>
  }

  export type CalciumUpdateManyWithWhereWithoutMeasurementInput = {
    where: CalciumScalarWhereInput
    data: XOR<CalciumUpdateManyMutationInput, CalciumUncheckedUpdateManyWithoutCalciumInput>
  }

  export type CalciumScalarWhereInput = {
    AND?: Enumerable<CalciumScalarWhereInput>
    OR?: Enumerable<CalciumScalarWhereInput>
    NOT?: Enumerable<CalciumScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type TotalFatUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: TotalFatWhereUniqueInput
    update: XOR<TotalFatUpdateWithoutMeasurementInput, TotalFatUncheckedUpdateWithoutMeasurementInput>
    create: XOR<TotalFatCreateWithoutMeasurementInput, TotalFatUncheckedCreateWithoutMeasurementInput>
  }

  export type TotalFatUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: TotalFatWhereUniqueInput
    data: XOR<TotalFatUpdateWithoutMeasurementInput, TotalFatUncheckedUpdateWithoutMeasurementInput>
  }

  export type TotalFatUpdateManyWithWhereWithoutMeasurementInput = {
    where: TotalFatScalarWhereInput
    data: XOR<TotalFatUpdateManyMutationInput, TotalFatUncheckedUpdateManyWithoutTotalFatInput>
  }

  export type TotalFatScalarWhereInput = {
    AND?: Enumerable<TotalFatScalarWhereInput>
    OR?: Enumerable<TotalFatScalarWhereInput>
    NOT?: Enumerable<TotalFatScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type SaturatedFatUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: SaturatedFatWhereUniqueInput
    update: XOR<SaturatedFatUpdateWithoutMeasurementInput, SaturatedFatUncheckedUpdateWithoutMeasurementInput>
    create: XOR<SaturatedFatCreateWithoutMeasurementInput, SaturatedFatUncheckedCreateWithoutMeasurementInput>
  }

  export type SaturatedFatUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: SaturatedFatWhereUniqueInput
    data: XOR<SaturatedFatUpdateWithoutMeasurementInput, SaturatedFatUncheckedUpdateWithoutMeasurementInput>
  }

  export type SaturatedFatUpdateManyWithWhereWithoutMeasurementInput = {
    where: SaturatedFatScalarWhereInput
    data: XOR<SaturatedFatUpdateManyMutationInput, SaturatedFatUncheckedUpdateManyWithoutSaturatedFatInput>
  }

  export type SaturatedFatScalarWhereInput = {
    AND?: Enumerable<SaturatedFatScalarWhereInput>
    OR?: Enumerable<SaturatedFatScalarWhereInput>
    NOT?: Enumerable<SaturatedFatScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type MonosaturatedFatUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: MonosaturatedFatWhereUniqueInput
    update: XOR<MonosaturatedFatUpdateWithoutMeasurementInput, MonosaturatedFatUncheckedUpdateWithoutMeasurementInput>
    create: XOR<MonosaturatedFatCreateWithoutMeasurementInput, MonosaturatedFatUncheckedCreateWithoutMeasurementInput>
  }

  export type MonosaturatedFatUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: MonosaturatedFatWhereUniqueInput
    data: XOR<MonosaturatedFatUpdateWithoutMeasurementInput, MonosaturatedFatUncheckedUpdateWithoutMeasurementInput>
  }

  export type MonosaturatedFatUpdateManyWithWhereWithoutMeasurementInput = {
    where: MonosaturatedFatScalarWhereInput
    data: XOR<MonosaturatedFatUpdateManyMutationInput, MonosaturatedFatUncheckedUpdateManyWithoutMonosaturatedFatInput>
  }

  export type MonosaturatedFatScalarWhereInput = {
    AND?: Enumerable<MonosaturatedFatScalarWhereInput>
    OR?: Enumerable<MonosaturatedFatScalarWhereInput>
    NOT?: Enumerable<MonosaturatedFatScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type PolyunsaturatedFatUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: PolyunsaturatedFatWhereUniqueInput
    update: XOR<PolyunsaturatedFatUpdateWithoutMeasurementInput, PolyunsaturatedFatUncheckedUpdateWithoutMeasurementInput>
    create: XOR<PolyunsaturatedFatCreateWithoutMeasurementInput, PolyunsaturatedFatUncheckedCreateWithoutMeasurementInput>
  }

  export type PolyunsaturatedFatUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: PolyunsaturatedFatWhereUniqueInput
    data: XOR<PolyunsaturatedFatUpdateWithoutMeasurementInput, PolyunsaturatedFatUncheckedUpdateWithoutMeasurementInput>
  }

  export type PolyunsaturatedFatUpdateManyWithWhereWithoutMeasurementInput = {
    where: PolyunsaturatedFatScalarWhereInput
    data: XOR<PolyunsaturatedFatUpdateManyMutationInput, PolyunsaturatedFatUncheckedUpdateManyWithoutPolyunsaturatedFatInput>
  }

  export type PolyunsaturatedFatScalarWhereInput = {
    AND?: Enumerable<PolyunsaturatedFatScalarWhereInput>
    OR?: Enumerable<PolyunsaturatedFatScalarWhereInput>
    NOT?: Enumerable<PolyunsaturatedFatScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type TransFatUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: TransFatWhereUniqueInput
    update: XOR<TransFatUpdateWithoutMeasurementInput, TransFatUncheckedUpdateWithoutMeasurementInput>
    create: XOR<TransFatCreateWithoutMeasurementInput, TransFatUncheckedCreateWithoutMeasurementInput>
  }

  export type TransFatUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: TransFatWhereUniqueInput
    data: XOR<TransFatUpdateWithoutMeasurementInput, TransFatUncheckedUpdateWithoutMeasurementInput>
  }

  export type TransFatUpdateManyWithWhereWithoutMeasurementInput = {
    where: TransFatScalarWhereInput
    data: XOR<TransFatUpdateManyMutationInput, TransFatUncheckedUpdateManyWithoutTransFatInput>
  }

  export type TransFatScalarWhereInput = {
    AND?: Enumerable<TransFatScalarWhereInput>
    OR?: Enumerable<TransFatScalarWhereInput>
    NOT?: Enumerable<TransFatScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type TotalCarbohydrateUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: TotalCarbohydrateWhereUniqueInput
    update: XOR<TotalCarbohydrateUpdateWithoutMeasurementInput, TotalCarbohydrateUncheckedUpdateWithoutMeasurementInput>
    create: XOR<TotalCarbohydrateCreateWithoutMeasurementInput, TotalCarbohydrateUncheckedCreateWithoutMeasurementInput>
  }

  export type TotalCarbohydrateUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: TotalCarbohydrateWhereUniqueInput
    data: XOR<TotalCarbohydrateUpdateWithoutMeasurementInput, TotalCarbohydrateUncheckedUpdateWithoutMeasurementInput>
  }

  export type TotalCarbohydrateUpdateManyWithWhereWithoutMeasurementInput = {
    where: TotalCarbohydrateScalarWhereInput
    data: XOR<TotalCarbohydrateUpdateManyMutationInput, TotalCarbohydrateUncheckedUpdateManyWithoutTotalCarbohydrateInput>
  }

  export type TotalCarbohydrateScalarWhereInput = {
    AND?: Enumerable<TotalCarbohydrateScalarWhereInput>
    OR?: Enumerable<TotalCarbohydrateScalarWhereInput>
    NOT?: Enumerable<TotalCarbohydrateScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type SugarCarbohydrateUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: SugarCarbohydrateWhereUniqueInput
    update: XOR<SugarCarbohydrateUpdateWithoutMeasurementInput, SugarCarbohydrateUncheckedUpdateWithoutMeasurementInput>
    create: XOR<SugarCarbohydrateCreateWithoutMeasurementInput, SugarCarbohydrateUncheckedCreateWithoutMeasurementInput>
  }

  export type SugarCarbohydrateUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: SugarCarbohydrateWhereUniqueInput
    data: XOR<SugarCarbohydrateUpdateWithoutMeasurementInput, SugarCarbohydrateUncheckedUpdateWithoutMeasurementInput>
  }

  export type SugarCarbohydrateUpdateManyWithWhereWithoutMeasurementInput = {
    where: SugarCarbohydrateScalarWhereInput
    data: XOR<SugarCarbohydrateUpdateManyMutationInput, SugarCarbohydrateUncheckedUpdateManyWithoutSugarCarbohydrateInput>
  }

  export type SugarCarbohydrateScalarWhereInput = {
    AND?: Enumerable<SugarCarbohydrateScalarWhereInput>
    OR?: Enumerable<SugarCarbohydrateScalarWhereInput>
    NOT?: Enumerable<SugarCarbohydrateScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type VitaminCUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminCWhereUniqueInput
    update: XOR<VitaminCUpdateWithoutMeasurementInput, VitaminCUncheckedUpdateWithoutMeasurementInput>
    create: XOR<VitaminCCreateWithoutMeasurementInput, VitaminCUncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminCUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminCWhereUniqueInput
    data: XOR<VitaminCUpdateWithoutMeasurementInput, VitaminCUncheckedUpdateWithoutMeasurementInput>
  }

  export type VitaminCUpdateManyWithWhereWithoutMeasurementInput = {
    where: VitaminCScalarWhereInput
    data: XOR<VitaminCUpdateManyMutationInput, VitaminCUncheckedUpdateManyWithoutVitaminCInput>
  }

  export type VitaminCScalarWhereInput = {
    AND?: Enumerable<VitaminCScalarWhereInput>
    OR?: Enumerable<VitaminCScalarWhereInput>
    NOT?: Enumerable<VitaminCScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type VitaminAUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminAWhereUniqueInput
    update: XOR<VitaminAUpdateWithoutMeasurementInput, VitaminAUncheckedUpdateWithoutMeasurementInput>
    create: XOR<VitaminACreateWithoutMeasurementInput, VitaminAUncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminAUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminAWhereUniqueInput
    data: XOR<VitaminAUpdateWithoutMeasurementInput, VitaminAUncheckedUpdateWithoutMeasurementInput>
  }

  export type VitaminAUpdateManyWithWhereWithoutMeasurementInput = {
    where: VitaminAScalarWhereInput
    data: XOR<VitaminAUpdateManyMutationInput, VitaminAUncheckedUpdateManyWithoutVitaminAInput>
  }

  export type VitaminAScalarWhereInput = {
    AND?: Enumerable<VitaminAScalarWhereInput>
    OR?: Enumerable<VitaminAScalarWhereInput>
    NOT?: Enumerable<VitaminAScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type VitaminDUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminDWhereUniqueInput
    update: XOR<VitaminDUpdateWithoutMeasurementInput, VitaminDUncheckedUpdateWithoutMeasurementInput>
    create: XOR<VitaminDCreateWithoutMeasurementInput, VitaminDUncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminDUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminDWhereUniqueInput
    data: XOR<VitaminDUpdateWithoutMeasurementInput, VitaminDUncheckedUpdateWithoutMeasurementInput>
  }

  export type VitaminDUpdateManyWithWhereWithoutMeasurementInput = {
    where: VitaminDScalarWhereInput
    data: XOR<VitaminDUpdateManyMutationInput, VitaminDUncheckedUpdateManyWithoutVitaminDInput>
  }

  export type VitaminDScalarWhereInput = {
    AND?: Enumerable<VitaminDScalarWhereInput>
    OR?: Enumerable<VitaminDScalarWhereInput>
    NOT?: Enumerable<VitaminDScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type VitaminEUpsertWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminEWhereUniqueInput
    update: XOR<VitaminEUpdateWithoutMeasurementInput, VitaminEUncheckedUpdateWithoutMeasurementInput>
    create: XOR<VitaminECreateWithoutMeasurementInput, VitaminEUncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminEUpdateWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminEWhereUniqueInput
    data: XOR<VitaminEUpdateWithoutMeasurementInput, VitaminEUncheckedUpdateWithoutMeasurementInput>
  }

  export type VitaminEUpdateManyWithWhereWithoutMeasurementInput = {
    where: VitaminEScalarWhereInput
    data: XOR<VitaminEUpdateManyMutationInput, VitaminEUncheckedUpdateManyWithoutVitaminEInput>
  }

  export type VitaminEScalarWhereInput = {
    AND?: Enumerable<VitaminEScalarWhereInput>
    OR?: Enumerable<VitaminEScalarWhereInput>
    NOT?: Enumerable<VitaminEScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type VitaminB1UpsertWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminB1WhereUniqueInput
    update: XOR<VitaminB1UpdateWithoutMeasurementInput, VitaminB1UncheckedUpdateWithoutMeasurementInput>
    create: XOR<VitaminB1CreateWithoutMeasurementInput, VitaminB1UncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminB1UpdateWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminB1WhereUniqueInput
    data: XOR<VitaminB1UpdateWithoutMeasurementInput, VitaminB1UncheckedUpdateWithoutMeasurementInput>
  }

  export type VitaminB1UpdateManyWithWhereWithoutMeasurementInput = {
    where: VitaminB1ScalarWhereInput
    data: XOR<VitaminB1UpdateManyMutationInput, VitaminB1UncheckedUpdateManyWithoutVitaminB1Input>
  }

  export type VitaminB1ScalarWhereInput = {
    AND?: Enumerable<VitaminB1ScalarWhereInput>
    OR?: Enumerable<VitaminB1ScalarWhereInput>
    NOT?: Enumerable<VitaminB1ScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type VitaminB2UpsertWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminB2WhereUniqueInput
    update: XOR<VitaminB2UpdateWithoutMeasurementInput, VitaminB2UncheckedUpdateWithoutMeasurementInput>
    create: XOR<VitaminB2CreateWithoutMeasurementInput, VitaminB2UncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminB2UpdateWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminB2WhereUniqueInput
    data: XOR<VitaminB2UpdateWithoutMeasurementInput, VitaminB2UncheckedUpdateWithoutMeasurementInput>
  }

  export type VitaminB2UpdateManyWithWhereWithoutMeasurementInput = {
    where: VitaminB2ScalarWhereInput
    data: XOR<VitaminB2UpdateManyMutationInput, VitaminB2UncheckedUpdateManyWithoutVitaminB2Input>
  }

  export type VitaminB2ScalarWhereInput = {
    AND?: Enumerable<VitaminB2ScalarWhereInput>
    OR?: Enumerable<VitaminB2ScalarWhereInput>
    NOT?: Enumerable<VitaminB2ScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type VitaminB6UpsertWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminB6WhereUniqueInput
    update: XOR<VitaminB6UpdateWithoutMeasurementInput, VitaminB6UncheckedUpdateWithoutMeasurementInput>
    create: XOR<VitaminB6CreateWithoutMeasurementInput, VitaminB6UncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminB6UpdateWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminB6WhereUniqueInput
    data: XOR<VitaminB6UpdateWithoutMeasurementInput, VitaminB6UncheckedUpdateWithoutMeasurementInput>
  }

  export type VitaminB6UpdateManyWithWhereWithoutMeasurementInput = {
    where: VitaminB6ScalarWhereInput
    data: XOR<VitaminB6UpdateManyMutationInput, VitaminB6UncheckedUpdateManyWithoutVitaminB6Input>
  }

  export type VitaminB6ScalarWhereInput = {
    AND?: Enumerable<VitaminB6ScalarWhereInput>
    OR?: Enumerable<VitaminB6ScalarWhereInput>
    NOT?: Enumerable<VitaminB6ScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type VitaminB12UpsertWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminB12WhereUniqueInput
    update: XOR<VitaminB12UpdateWithoutMeasurementInput, VitaminB12UncheckedUpdateWithoutMeasurementInput>
    create: XOR<VitaminB12CreateWithoutMeasurementInput, VitaminB12UncheckedCreateWithoutMeasurementInput>
  }

  export type VitaminB12UpdateWithWhereUniqueWithoutMeasurementInput = {
    where: VitaminB12WhereUniqueInput
    data: XOR<VitaminB12UpdateWithoutMeasurementInput, VitaminB12UncheckedUpdateWithoutMeasurementInput>
  }

  export type VitaminB12UpdateManyWithWhereWithoutMeasurementInput = {
    where: VitaminB12ScalarWhereInput
    data: XOR<VitaminB12UpdateManyMutationInput, VitaminB12UncheckedUpdateManyWithoutVitaminB12Input>
  }

  export type VitaminB12ScalarWhereInput = {
    AND?: Enumerable<VitaminB12ScalarWhereInput>
    OR?: Enumerable<VitaminB12ScalarWhereInput>
    NOT?: Enumerable<VitaminB12ScalarWhereInput>
    id?: IntFilter | number
    measurementId?: IntFilter | number
  }

  export type EnergyUpsertWithWhereUniqueWithoutMeasurementsInput = {
    where: EnergyWhereUniqueInput
    update: XOR<EnergyUpdateWithoutMeasurementsInput, EnergyUncheckedUpdateWithoutMeasurementsInput>
    create: XOR<EnergyCreateWithoutMeasurementsInput, EnergyUncheckedCreateWithoutMeasurementsInput>
  }

  export type EnergyUpdateWithWhereUniqueWithoutMeasurementsInput = {
    where: EnergyWhereUniqueInput
    data: XOR<EnergyUpdateWithoutMeasurementsInput, EnergyUncheckedUpdateWithoutMeasurementsInput>
  }

  export type EnergyUpdateManyWithWhereWithoutMeasurementsInput = {
    where: EnergyScalarWhereInput
    data: XOR<EnergyUpdateManyMutationInput, EnergyUncheckedUpdateManyWithoutEnergyInput>
  }

  export type EnergyScalarWhereInput = {
    AND?: Enumerable<EnergyScalarWhereInput>
    OR?: Enumerable<EnergyScalarWhereInput>
    NOT?: Enumerable<EnergyScalarWhereInput>
    id?: IntFilter | number
    nutritionFactId?: IntFilter | number
  }

  export type ProteinUpsertWithoutMeasurementsInput = {
    update: XOR<ProteinUpdateWithoutMeasurementsInput, ProteinUncheckedUpdateWithoutMeasurementsInput>
    create: XOR<ProteinCreateWithoutMeasurementsInput, ProteinUncheckedCreateWithoutMeasurementsInput>
  }

  export type ProteinUpdateWithoutMeasurementsInput = {
    NutritionFact?: NutritionFactUpdateManyWithoutProteinInput
  }

  export type ProteinUncheckedUpdateWithoutMeasurementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    NutritionFact?: NutritionFactUncheckedUpdateManyWithoutProteinInput
  }

  export type CholesterolUpsertWithoutMeasurementsInput = {
    update: XOR<CholesterolUpdateWithoutMeasurementsInput, CholesterolUncheckedUpdateWithoutMeasurementsInput>
    create: XOR<CholesterolCreateWithoutMeasurementsInput, CholesterolUncheckedCreateWithoutMeasurementsInput>
  }

  export type CholesterolUpdateWithoutMeasurementsInput = {
    NutritionFact?: NutritionFactUpdateManyWithoutCholesterolInput
  }

  export type CholesterolUncheckedUpdateWithoutMeasurementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    NutritionFact?: NutritionFactUncheckedUpdateManyWithoutCholesterolInput
  }

  export type FiberUpsertWithoutMeasurementsInput = {
    update: XOR<FiberUpdateWithoutMeasurementsInput, FiberUncheckedUpdateWithoutMeasurementsInput>
    create: XOR<FiberCreateWithoutMeasurementsInput, FiberUncheckedCreateWithoutMeasurementsInput>
  }

  export type FiberUpdateWithoutMeasurementsInput = {
    NutritionFact?: NutritionFactUpdateManyWithoutFiberInput
  }

  export type FiberUncheckedUpdateWithoutMeasurementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    NutritionFact?: NutritionFactUncheckedUpdateManyWithoutFiberInput
  }

  export type WaterUpsertWithoutMeasurementsInput = {
    update: XOR<WaterUpdateWithoutMeasurementsInput, WaterUncheckedUpdateWithoutMeasurementsInput>
    create: XOR<WaterCreateWithoutMeasurementsInput, WaterUncheckedCreateWithoutMeasurementsInput>
  }

  export type WaterUpdateWithoutMeasurementsInput = {
    NutritionFact?: NutritionFactUpdateManyWithoutWaterInput
  }

  export type WaterUncheckedUpdateWithoutMeasurementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    NutritionFact?: NutritionFactUncheckedUpdateManyWithoutWaterInput
  }

  export type MeasurementCreateWithoutServingsInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutServingsInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutServingsInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutServingsInput, MeasurementUncheckedCreateWithoutServingsInput>
  }

  export type ProductCreateWithoutServingInput = {
    name: string
    labels?: LabelCreateNestedManyWithoutProductsInput
    ean?: string | null
    manufacturer: string
    group: string
    nutritionFact?: NutritionFactCreateNestedOneWithoutProductInput
    nutritionFactId?: number | null
  }

  export type ProductUncheckedCreateWithoutServingInput = {
    id?: number
    name: string
    labels?: LabelUncheckedCreateNestedManyWithoutProductsInput
    ean?: string | null
    manufacturer: string
    group: string
    nutritionFact?: NutritionFactUncheckedCreateNestedOneWithoutProductInput
    nutritionFactId?: number | null
  }

  export type ProductCreateOrConnectWithoutServingInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutServingInput, ProductUncheckedCreateWithoutServingInput>
  }

  export type ProductCreateManyServingInputEnvelope = {
    data: Enumerable<ProductCreateManyServingInput>
    skipDuplicates?: boolean
  }

  export type MeasurementUpsertWithoutServingsInput = {
    update: XOR<MeasurementUpdateWithoutServingsInput, MeasurementUncheckedUpdateWithoutServingsInput>
    create: XOR<MeasurementCreateWithoutServingsInput, MeasurementUncheckedCreateWithoutServingsInput>
  }

  export type MeasurementUpdateWithoutServingsInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutServingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductUpsertWithWhereUniqueWithoutServingInput = {
    where: ProductWhereUniqueInput
    update: XOR<ProductUpdateWithoutServingInput, ProductUncheckedUpdateWithoutServingInput>
    create: XOR<ProductCreateWithoutServingInput, ProductUncheckedCreateWithoutServingInput>
  }

  export type ProductUpdateWithWhereUniqueWithoutServingInput = {
    where: ProductWhereUniqueInput
    data: XOR<ProductUpdateWithoutServingInput, ProductUncheckedUpdateWithoutServingInput>
  }

  export type ProductUpdateManyWithWhereWithoutServingInput = {
    where: ProductScalarWhereInput
    data: XOR<ProductUpdateManyMutationInput, ProductUncheckedUpdateManyWithoutProductsInput>
  }

  export type MeasurementCreateWithoutEnergyInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutEnergyInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutEnergyInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutEnergyInput, MeasurementUncheckedCreateWithoutEnergyInput>
  }

  export type NutritionFactCreateWithoutEnergyInput = {
    protein?: ProteinCreateNestedOneWithoutNutritionFactInput
    fats?: FatCreateNestedOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateCreateNestedOneWithoutNutritionFactsInput
    fiber?: FiberCreateNestedOneWithoutNutritionFactInput
    water?: WaterCreateNestedOneWithoutNutritionFactInput
    vitamins?: VitaminCreateNestedOneWithoutNutritionFactsInput
    minerals?: MineralCreateNestedOneWithoutNutritionFactInput
    cholesterol?: CholesterolCreateNestedOneWithoutNutritionFactInput
    product?: ProductCreateNestedOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedCreateWithoutEnergyInput = {
    id?: number
    proteinId?: number | null
    fatId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type NutritionFactCreateOrConnectWithoutEnergyInput = {
    where: NutritionFactWhereUniqueInput
    create: XOR<NutritionFactCreateWithoutEnergyInput, NutritionFactUncheckedCreateWithoutEnergyInput>
  }

  export type MeasurementUpsertWithWhereUniqueWithoutEnergyInput = {
    where: MeasurementWhereUniqueInput
    update: XOR<MeasurementUpdateWithoutEnergyInput, MeasurementUncheckedUpdateWithoutEnergyInput>
    create: XOR<MeasurementCreateWithoutEnergyInput, MeasurementUncheckedCreateWithoutEnergyInput>
  }

  export type MeasurementUpdateWithWhereUniqueWithoutEnergyInput = {
    where: MeasurementWhereUniqueInput
    data: XOR<MeasurementUpdateWithoutEnergyInput, MeasurementUncheckedUpdateWithoutEnergyInput>
  }

  export type MeasurementUpdateManyWithWhereWithoutEnergyInput = {
    where: MeasurementScalarWhereInput
    data: XOR<MeasurementUpdateManyMutationInput, MeasurementUncheckedUpdateManyWithoutMeasurementsInput>
  }

  export type NutritionFactUpsertWithoutEnergyInput = {
    update: XOR<NutritionFactUpdateWithoutEnergyInput, NutritionFactUncheckedUpdateWithoutEnergyInput>
    create: XOR<NutritionFactCreateWithoutEnergyInput, NutritionFactUncheckedCreateWithoutEnergyInput>
  }

  export type NutritionFactUpdateWithoutEnergyInput = {
    protein?: ProteinUpdateOneWithoutNutritionFactInput
    fats?: FatUpdateOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateUpdateOneWithoutNutritionFactsInput
    fiber?: FiberUpdateOneWithoutNutritionFactInput
    water?: WaterUpdateOneWithoutNutritionFactInput
    vitamins?: VitaminUpdateOneWithoutNutritionFactsInput
    minerals?: MineralUpdateOneWithoutNutritionFactInput
    cholesterol?: CholesterolUpdateOneWithoutNutritionFactInput
    product?: ProductUpdateOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedUpdateWithoutEnergyInput = {
    id?: IntFieldUpdateOperationsInput | number
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    fatId?: NullableIntFieldUpdateOperationsInput | number | null
    carbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminId?: NullableIntFieldUpdateOperationsInput | number | null
    mineralId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasurementCreateWithoutProteinInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutProteinInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutProteinInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutProteinInput, MeasurementUncheckedCreateWithoutProteinInput>
  }

  export type MeasurementCreateManyProteinInputEnvelope = {
    data: Enumerable<MeasurementCreateManyProteinInput>
    skipDuplicates?: boolean
  }

  export type NutritionFactCreateWithoutProteinInput = {
    energy?: EnergyCreateNestedManyWithoutNutritionFactInput
    fats?: FatCreateNestedOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateCreateNestedOneWithoutNutritionFactsInput
    fiber?: FiberCreateNestedOneWithoutNutritionFactInput
    water?: WaterCreateNestedOneWithoutNutritionFactInput
    vitamins?: VitaminCreateNestedOneWithoutNutritionFactsInput
    minerals?: MineralCreateNestedOneWithoutNutritionFactInput
    cholesterol?: CholesterolCreateNestedOneWithoutNutritionFactInput
    product?: ProductCreateNestedOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedCreateWithoutProteinInput = {
    id?: number
    energy?: EnergyUncheckedCreateNestedManyWithoutNutritionFactInput
    fatId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type NutritionFactCreateOrConnectWithoutProteinInput = {
    where: NutritionFactWhereUniqueInput
    create: XOR<NutritionFactCreateWithoutProteinInput, NutritionFactUncheckedCreateWithoutProteinInput>
  }

  export type NutritionFactCreateManyProteinInputEnvelope = {
    data: Enumerable<NutritionFactCreateManyProteinInput>
    skipDuplicates?: boolean
  }

  export type MeasurementUpsertWithWhereUniqueWithoutProteinInput = {
    where: MeasurementWhereUniqueInput
    update: XOR<MeasurementUpdateWithoutProteinInput, MeasurementUncheckedUpdateWithoutProteinInput>
    create: XOR<MeasurementCreateWithoutProteinInput, MeasurementUncheckedCreateWithoutProteinInput>
  }

  export type MeasurementUpdateWithWhereUniqueWithoutProteinInput = {
    where: MeasurementWhereUniqueInput
    data: XOR<MeasurementUpdateWithoutProteinInput, MeasurementUncheckedUpdateWithoutProteinInput>
  }

  export type MeasurementUpdateManyWithWhereWithoutProteinInput = {
    where: MeasurementScalarWhereInput
    data: XOR<MeasurementUpdateManyMutationInput, MeasurementUncheckedUpdateManyWithoutMeasurementsInput>
  }

  export type NutritionFactUpsertWithWhereUniqueWithoutProteinInput = {
    where: NutritionFactWhereUniqueInput
    update: XOR<NutritionFactUpdateWithoutProteinInput, NutritionFactUncheckedUpdateWithoutProteinInput>
    create: XOR<NutritionFactCreateWithoutProteinInput, NutritionFactUncheckedCreateWithoutProteinInput>
  }

  export type NutritionFactUpdateWithWhereUniqueWithoutProteinInput = {
    where: NutritionFactWhereUniqueInput
    data: XOR<NutritionFactUpdateWithoutProteinInput, NutritionFactUncheckedUpdateWithoutProteinInput>
  }

  export type NutritionFactUpdateManyWithWhereWithoutProteinInput = {
    where: NutritionFactScalarWhereInput
    data: XOR<NutritionFactUpdateManyMutationInput, NutritionFactUncheckedUpdateManyWithoutNutritionFactInput>
  }

  export type MeasurementCreateWithoutCholesterolInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutCholesterolInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutCholesterolInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutCholesterolInput, MeasurementUncheckedCreateWithoutCholesterolInput>
  }

  export type MeasurementCreateManyCholesterolInputEnvelope = {
    data: Enumerable<MeasurementCreateManyCholesterolInput>
    skipDuplicates?: boolean
  }

  export type NutritionFactCreateWithoutCholesterolInput = {
    energy?: EnergyCreateNestedManyWithoutNutritionFactInput
    protein?: ProteinCreateNestedOneWithoutNutritionFactInput
    fats?: FatCreateNestedOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateCreateNestedOneWithoutNutritionFactsInput
    fiber?: FiberCreateNestedOneWithoutNutritionFactInput
    water?: WaterCreateNestedOneWithoutNutritionFactInput
    vitamins?: VitaminCreateNestedOneWithoutNutritionFactsInput
    minerals?: MineralCreateNestedOneWithoutNutritionFactInput
    product?: ProductCreateNestedOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedCreateWithoutCholesterolInput = {
    id?: number
    energy?: EnergyUncheckedCreateNestedManyWithoutNutritionFactInput
    proteinId?: number | null
    fatId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type NutritionFactCreateOrConnectWithoutCholesterolInput = {
    where: NutritionFactWhereUniqueInput
    create: XOR<NutritionFactCreateWithoutCholesterolInput, NutritionFactUncheckedCreateWithoutCholesterolInput>
  }

  export type NutritionFactCreateManyCholesterolInputEnvelope = {
    data: Enumerable<NutritionFactCreateManyCholesterolInput>
    skipDuplicates?: boolean
  }

  export type MeasurementUpsertWithWhereUniqueWithoutCholesterolInput = {
    where: MeasurementWhereUniqueInput
    update: XOR<MeasurementUpdateWithoutCholesterolInput, MeasurementUncheckedUpdateWithoutCholesterolInput>
    create: XOR<MeasurementCreateWithoutCholesterolInput, MeasurementUncheckedCreateWithoutCholesterolInput>
  }

  export type MeasurementUpdateWithWhereUniqueWithoutCholesterolInput = {
    where: MeasurementWhereUniqueInput
    data: XOR<MeasurementUpdateWithoutCholesterolInput, MeasurementUncheckedUpdateWithoutCholesterolInput>
  }

  export type MeasurementUpdateManyWithWhereWithoutCholesterolInput = {
    where: MeasurementScalarWhereInput
    data: XOR<MeasurementUpdateManyMutationInput, MeasurementUncheckedUpdateManyWithoutMeasurementsInput>
  }

  export type NutritionFactUpsertWithWhereUniqueWithoutCholesterolInput = {
    where: NutritionFactWhereUniqueInput
    update: XOR<NutritionFactUpdateWithoutCholesterolInput, NutritionFactUncheckedUpdateWithoutCholesterolInput>
    create: XOR<NutritionFactCreateWithoutCholesterolInput, NutritionFactUncheckedCreateWithoutCholesterolInput>
  }

  export type NutritionFactUpdateWithWhereUniqueWithoutCholesterolInput = {
    where: NutritionFactWhereUniqueInput
    data: XOR<NutritionFactUpdateWithoutCholesterolInput, NutritionFactUncheckedUpdateWithoutCholesterolInput>
  }

  export type NutritionFactUpdateManyWithWhereWithoutCholesterolInput = {
    where: NutritionFactScalarWhereInput
    data: XOR<NutritionFactUpdateManyMutationInput, NutritionFactUncheckedUpdateManyWithoutNutritionFactInput>
  }

  export type MeasurementCreateWithoutCiberInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    cater?: WaterCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutCiberInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutCiberInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutCiberInput, MeasurementUncheckedCreateWithoutCiberInput>
  }

  export type MeasurementCreateManyCiberInputEnvelope = {
    data: Enumerable<MeasurementCreateManyCiberInput>
    skipDuplicates?: boolean
  }

  export type NutritionFactCreateWithoutFiberInput = {
    energy?: EnergyCreateNestedManyWithoutNutritionFactInput
    protein?: ProteinCreateNestedOneWithoutNutritionFactInput
    fats?: FatCreateNestedOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateCreateNestedOneWithoutNutritionFactsInput
    water?: WaterCreateNestedOneWithoutNutritionFactInput
    vitamins?: VitaminCreateNestedOneWithoutNutritionFactsInput
    minerals?: MineralCreateNestedOneWithoutNutritionFactInput
    cholesterol?: CholesterolCreateNestedOneWithoutNutritionFactInput
    product?: ProductCreateNestedOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedCreateWithoutFiberInput = {
    id?: number
    energy?: EnergyUncheckedCreateNestedManyWithoutNutritionFactInput
    proteinId?: number | null
    fatId?: number | null
    carbohydrateId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type NutritionFactCreateOrConnectWithoutFiberInput = {
    where: NutritionFactWhereUniqueInput
    create: XOR<NutritionFactCreateWithoutFiberInput, NutritionFactUncheckedCreateWithoutFiberInput>
  }

  export type NutritionFactCreateManyFiberInputEnvelope = {
    data: Enumerable<NutritionFactCreateManyFiberInput>
    skipDuplicates?: boolean
  }

  export type MeasurementUpsertWithWhereUniqueWithoutCiberInput = {
    where: MeasurementWhereUniqueInput
    update: XOR<MeasurementUpdateWithoutCiberInput, MeasurementUncheckedUpdateWithoutCiberInput>
    create: XOR<MeasurementCreateWithoutCiberInput, MeasurementUncheckedCreateWithoutCiberInput>
  }

  export type MeasurementUpdateWithWhereUniqueWithoutCiberInput = {
    where: MeasurementWhereUniqueInput
    data: XOR<MeasurementUpdateWithoutCiberInput, MeasurementUncheckedUpdateWithoutCiberInput>
  }

  export type MeasurementUpdateManyWithWhereWithoutCiberInput = {
    where: MeasurementScalarWhereInput
    data: XOR<MeasurementUpdateManyMutationInput, MeasurementUncheckedUpdateManyWithoutMeasurementsInput>
  }

  export type NutritionFactUpsertWithWhereUniqueWithoutFiberInput = {
    where: NutritionFactWhereUniqueInput
    update: XOR<NutritionFactUpdateWithoutFiberInput, NutritionFactUncheckedUpdateWithoutFiberInput>
    create: XOR<NutritionFactCreateWithoutFiberInput, NutritionFactUncheckedCreateWithoutFiberInput>
  }

  export type NutritionFactUpdateWithWhereUniqueWithoutFiberInput = {
    where: NutritionFactWhereUniqueInput
    data: XOR<NutritionFactUpdateWithoutFiberInput, NutritionFactUncheckedUpdateWithoutFiberInput>
  }

  export type NutritionFactUpdateManyWithWhereWithoutFiberInput = {
    where: NutritionFactScalarWhereInput
    data: XOR<NutritionFactUpdateManyMutationInput, NutritionFactUncheckedUpdateManyWithoutNutritionFactInput>
  }

  export type MeasurementCreateWithoutCaterInput = {
    value?: Decimal | number | string | null
    unit: UnitCreateNestedOneWithoutMeasurementsInput
    servings?: ServingCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminCreateNestedManyWithoutMeasurementsInput
    salt?: SaltCreateNestedManyWithoutMeasurementInput
    zinc?: ZincCreateNestedManyWithoutMeasurementInput
    iron?: IronCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousCreateNestedManyWithoutMeasurementInput
    copper?: CopperCreateNestedManyWithoutMeasurementInput
    iodine?: IodineCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminACreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminECreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1CreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2CreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6CreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12CreateNestedManyWithoutMeasurementInput
    energy?: EnergyCreateNestedManyWithoutMeasurementsInput
    protein?: ProteinCreateNestedOneWithoutMeasurementsInput
    cholesterol?: CholesterolCreateNestedOneWithoutMeasurementsInput
    ciber?: FiberCreateNestedOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedCreateWithoutCaterInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    servings?: ServingUncheckedCreateNestedManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedCreateNestedManyWithoutMeasurementsInput
    salt?: SaltUncheckedCreateNestedManyWithoutMeasurementInput
    zinc?: ZincUncheckedCreateNestedManyWithoutMeasurementInput
    iron?: IronUncheckedCreateNestedManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedCreateNestedManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedCreateNestedManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedCreateNestedManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedCreateNestedManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedCreateNestedManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedCreateNestedManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedCreateNestedManyWithoutMeasurementInput
    copper?: CopperUncheckedCreateNestedManyWithoutMeasurementInput
    iodine?: IodineUncheckedCreateNestedManyWithoutMeasurementInput
    calcium?: CalciumUncheckedCreateNestedManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedCreateNestedManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedCreateNestedManyWithoutMeasurementInput
    transFat?: TransFatUncheckedCreateNestedManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedCreateNestedManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedCreateNestedManyWithoutMeasurementInput
    energy?: EnergyUncheckedCreateNestedManyWithoutMeasurementsInput
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
  }

  export type MeasurementCreateOrConnectWithoutCaterInput = {
    where: MeasurementWhereUniqueInput
    create: XOR<MeasurementCreateWithoutCaterInput, MeasurementUncheckedCreateWithoutCaterInput>
  }

  export type MeasurementCreateManyCaterInputEnvelope = {
    data: Enumerable<MeasurementCreateManyCaterInput>
    skipDuplicates?: boolean
  }

  export type NutritionFactCreateWithoutWaterInput = {
    energy?: EnergyCreateNestedManyWithoutNutritionFactInput
    protein?: ProteinCreateNestedOneWithoutNutritionFactInput
    fats?: FatCreateNestedOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateCreateNestedOneWithoutNutritionFactsInput
    fiber?: FiberCreateNestedOneWithoutNutritionFactInput
    vitamins?: VitaminCreateNestedOneWithoutNutritionFactsInput
    minerals?: MineralCreateNestedOneWithoutNutritionFactInput
    cholesterol?: CholesterolCreateNestedOneWithoutNutritionFactInput
    product?: ProductCreateNestedOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedCreateWithoutWaterInput = {
    id?: number
    energy?: EnergyUncheckedCreateNestedManyWithoutNutritionFactInput
    proteinId?: number | null
    fatId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    productId?: number | null
  }

  export type NutritionFactCreateOrConnectWithoutWaterInput = {
    where: NutritionFactWhereUniqueInput
    create: XOR<NutritionFactCreateWithoutWaterInput, NutritionFactUncheckedCreateWithoutWaterInput>
  }

  export type NutritionFactCreateManyWaterInputEnvelope = {
    data: Enumerable<NutritionFactCreateManyWaterInput>
    skipDuplicates?: boolean
  }

  export type MeasurementUpsertWithWhereUniqueWithoutCaterInput = {
    where: MeasurementWhereUniqueInput
    update: XOR<MeasurementUpdateWithoutCaterInput, MeasurementUncheckedUpdateWithoutCaterInput>
    create: XOR<MeasurementCreateWithoutCaterInput, MeasurementUncheckedCreateWithoutCaterInput>
  }

  export type MeasurementUpdateWithWhereUniqueWithoutCaterInput = {
    where: MeasurementWhereUniqueInput
    data: XOR<MeasurementUpdateWithoutCaterInput, MeasurementUncheckedUpdateWithoutCaterInput>
  }

  export type MeasurementUpdateManyWithWhereWithoutCaterInput = {
    where: MeasurementScalarWhereInput
    data: XOR<MeasurementUpdateManyMutationInput, MeasurementUncheckedUpdateManyWithoutMeasurementsInput>
  }

  export type NutritionFactUpsertWithWhereUniqueWithoutWaterInput = {
    where: NutritionFactWhereUniqueInput
    update: XOR<NutritionFactUpdateWithoutWaterInput, NutritionFactUncheckedUpdateWithoutWaterInput>
    create: XOR<NutritionFactCreateWithoutWaterInput, NutritionFactUncheckedCreateWithoutWaterInput>
  }

  export type NutritionFactUpdateWithWhereUniqueWithoutWaterInput = {
    where: NutritionFactWhereUniqueInput
    data: XOR<NutritionFactUpdateWithoutWaterInput, NutritionFactUncheckedUpdateWithoutWaterInput>
  }

  export type NutritionFactUpdateManyWithWhereWithoutWaterInput = {
    where: NutritionFactScalarWhereInput
    data: XOR<NutritionFactUpdateManyMutationInput, NutritionFactUncheckedUpdateManyWithoutNutritionFactInput>
  }

  export type EnergyCreateWithoutNutritionFactInput = {
    measurements?: MeasurementCreateNestedManyWithoutEnergyInput
  }

  export type EnergyUncheckedCreateWithoutNutritionFactInput = {
    id?: number
    measurements?: MeasurementUncheckedCreateNestedManyWithoutEnergyInput
  }

  export type EnergyCreateOrConnectWithoutNutritionFactInput = {
    where: EnergyWhereUniqueInput
    create: XOR<EnergyCreateWithoutNutritionFactInput, EnergyUncheckedCreateWithoutNutritionFactInput>
  }

  export type EnergyCreateManyNutritionFactInputEnvelope = {
    data: Enumerable<EnergyCreateManyNutritionFactInput>
    skipDuplicates?: boolean
  }

  export type ProteinCreateWithoutNutritionFactInput = {
    measurements?: MeasurementCreateNestedManyWithoutProteinInput
  }

  export type ProteinUncheckedCreateWithoutNutritionFactInput = {
    id?: number
    measurements?: MeasurementUncheckedCreateNestedManyWithoutProteinInput
  }

  export type ProteinCreateOrConnectWithoutNutritionFactInput = {
    where: ProteinWhereUniqueInput
    create: XOR<ProteinCreateWithoutNutritionFactInput, ProteinUncheckedCreateWithoutNutritionFactInput>
  }

  export type FatCreateWithoutNutritionFactsInput = {
    total?: TotalFatCreateNestedOneWithoutFatInput
    saturated?: SaturatedFatCreateNestedOneWithoutFatInput
    monounsaturated?: MonosaturatedFatCreateNestedOneWithoutFatInput
    polyunsaturated?: PolyunsaturatedFatCreateNestedOneWithoutFatInput
    trans?: TransFatCreateNestedOneWithoutFatInput
  }

  export type FatUncheckedCreateWithoutNutritionFactsInput = {
    id?: number
    totalFatId: number
    saturatedFatId?: number | null
    monosaturatedFatId?: number | null
    polyunsaturatedFatId?: number | null
    transFatId?: number | null
  }

  export type FatCreateOrConnectWithoutNutritionFactsInput = {
    where: FatWhereUniqueInput
    create: XOR<FatCreateWithoutNutritionFactsInput, FatUncheckedCreateWithoutNutritionFactsInput>
  }

  export type CarbohydrateCreateWithoutNutritionFactsInput = {
    total?: TotalCarbohydrateCreateNestedOneWithoutCarbohydrateInput
    sugar?: SugarCarbohydrateCreateNestedOneWithoutCarbohydrateInput
  }

  export type CarbohydrateUncheckedCreateWithoutNutritionFactsInput = {
    id?: number
    totalCarbohydrateId?: number | null
    sugarCarbohydrateId?: number | null
  }

  export type CarbohydrateCreateOrConnectWithoutNutritionFactsInput = {
    where: CarbohydrateWhereUniqueInput
    create: XOR<CarbohydrateCreateWithoutNutritionFactsInput, CarbohydrateUncheckedCreateWithoutNutritionFactsInput>
  }

  export type FiberCreateWithoutNutritionFactInput = {
    measurements?: MeasurementCreateNestedManyWithoutCiberInput
  }

  export type FiberUncheckedCreateWithoutNutritionFactInput = {
    id?: number
    measurements?: MeasurementUncheckedCreateNestedManyWithoutCiberInput
  }

  export type FiberCreateOrConnectWithoutNutritionFactInput = {
    where: FiberWhereUniqueInput
    create: XOR<FiberCreateWithoutNutritionFactInput, FiberUncheckedCreateWithoutNutritionFactInput>
  }

  export type WaterCreateWithoutNutritionFactInput = {
    measurements?: MeasurementCreateNestedManyWithoutCaterInput
  }

  export type WaterUncheckedCreateWithoutNutritionFactInput = {
    id?: number
    measurements?: MeasurementUncheckedCreateNestedManyWithoutCaterInput
  }

  export type WaterCreateOrConnectWithoutNutritionFactInput = {
    where: WaterWhereUniqueInput
    create: XOR<WaterCreateWithoutNutritionFactInput, WaterUncheckedCreateWithoutNutritionFactInput>
  }

  export type VitaminCreateWithoutNutritionFactsInput = {
    C?: VitaminCCreateNestedOneWithoutVitaminInput
    A?: VitaminACreateNestedOneWithoutVitaminInput
    D?: VitaminDCreateNestedOneWithoutVitaminInput
    E?: VitaminECreateNestedOneWithoutVitaminInput
    B1?: VitaminB1CreateNestedOneWithoutVitaminInput
    B2?: VitaminB2CreateNestedOneWithoutVitaminInput
    B6?: VitaminB6CreateNestedOneWithoutVitaminInput
    B12?: VitaminB12CreateNestedOneWithoutVitaminInput
    measurements?: MeasurementCreateNestedManyWithoutVitaminInput
  }

  export type VitaminUncheckedCreateWithoutNutritionFactsInput = {
    id?: number
    vitaminCId?: number | null
    vitaminAId?: number | null
    vitaminDId?: number | null
    vitaminEId?: number | null
    vitaminB1Id?: number | null
    vitaminB2Id?: number | null
    vitaminB6Id?: number | null
    vitaminB12Id?: number | null
    measurements?: MeasurementUncheckedCreateNestedManyWithoutVitaminInput
  }

  export type VitaminCreateOrConnectWithoutNutritionFactsInput = {
    where: VitaminWhereUniqueInput
    create: XOR<VitaminCreateWithoutNutritionFactsInput, VitaminUncheckedCreateWithoutNutritionFactsInput>
  }

  export type MineralCreateWithoutNutritionFactInput = {
    salt?: SaltCreateNestedOneWithoutMineralsInput
    iron?: IronCreateNestedOneWithoutMineralsInput
    zinc?: ZincCreateNestedOneWithoutMineralsInput
    magnesium?: MagnesiumCreateNestedOneWithoutMineralsInput
    chloride?: ChlorideCreateNestedOneWithoutMineralsInput
    manganese?: ManganeseCreateNestedOneWithoutMineralsInput
    sulfur?: SulfurCreateNestedOneWithoutMineralsInput
    potassium?: PotassiumCreateNestedOneWithoutMineralsInput
    fluoride?: FluorideCreateNestedOneWithoutMineralsInput
    phosphorous?: PhosphorousCreateNestedOneWithoutMineralsInput
    copper?: CopperCreateNestedOneWithoutMineralsInput
    iodine?: IodineCreateNestedOneWithoutMineralsInput
    calcium?: CalciumCreateNestedOneWithoutMineralsInput
  }

  export type MineralUncheckedCreateWithoutNutritionFactInput = {
    id?: number
    saltId?: number | null
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralCreateOrConnectWithoutNutritionFactInput = {
    where: MineralWhereUniqueInput
    create: XOR<MineralCreateWithoutNutritionFactInput, MineralUncheckedCreateWithoutNutritionFactInput>
  }

  export type CholesterolCreateWithoutNutritionFactInput = {
    measurements?: MeasurementCreateNestedManyWithoutCholesterolInput
  }

  export type CholesterolUncheckedCreateWithoutNutritionFactInput = {
    id?: number
    measurements?: MeasurementUncheckedCreateNestedManyWithoutCholesterolInput
  }

  export type CholesterolCreateOrConnectWithoutNutritionFactInput = {
    where: CholesterolWhereUniqueInput
    create: XOR<CholesterolCreateWithoutNutritionFactInput, CholesterolUncheckedCreateWithoutNutritionFactInput>
  }

  export type ProductCreateWithoutNutritionFactInput = {
    name: string
    labels?: LabelCreateNestedManyWithoutProductsInput
    ean?: string | null
    manufacturer: string
    group: string
    serving: ServingCreateNestedOneWithoutProductsInput
    nutritionFactId?: number | null
  }

  export type ProductUncheckedCreateWithoutNutritionFactInput = {
    id?: number
    name: string
    labels?: LabelUncheckedCreateNestedManyWithoutProductsInput
    ean?: string | null
    manufacturer: string
    group: string
    servingId: number
    nutritionFactId?: number | null
  }

  export type ProductCreateOrConnectWithoutNutritionFactInput = {
    where: ProductWhereUniqueInput
    create: XOR<ProductCreateWithoutNutritionFactInput, ProductUncheckedCreateWithoutNutritionFactInput>
  }

  export type EnergyUpsertWithWhereUniqueWithoutNutritionFactInput = {
    where: EnergyWhereUniqueInput
    update: XOR<EnergyUpdateWithoutNutritionFactInput, EnergyUncheckedUpdateWithoutNutritionFactInput>
    create: XOR<EnergyCreateWithoutNutritionFactInput, EnergyUncheckedCreateWithoutNutritionFactInput>
  }

  export type EnergyUpdateWithWhereUniqueWithoutNutritionFactInput = {
    where: EnergyWhereUniqueInput
    data: XOR<EnergyUpdateWithoutNutritionFactInput, EnergyUncheckedUpdateWithoutNutritionFactInput>
  }

  export type EnergyUpdateManyWithWhereWithoutNutritionFactInput = {
    where: EnergyScalarWhereInput
    data: XOR<EnergyUpdateManyMutationInput, EnergyUncheckedUpdateManyWithoutEnergyInput>
  }

  export type ProteinUpsertWithoutNutritionFactInput = {
    update: XOR<ProteinUpdateWithoutNutritionFactInput, ProteinUncheckedUpdateWithoutNutritionFactInput>
    create: XOR<ProteinCreateWithoutNutritionFactInput, ProteinUncheckedCreateWithoutNutritionFactInput>
  }

  export type ProteinUpdateWithoutNutritionFactInput = {
    measurements?: MeasurementUpdateManyWithoutProteinInput
  }

  export type ProteinUncheckedUpdateWithoutNutritionFactInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurements?: MeasurementUncheckedUpdateManyWithoutProteinInput
  }

  export type FatUpsertWithoutNutritionFactsInput = {
    update: XOR<FatUpdateWithoutNutritionFactsInput, FatUncheckedUpdateWithoutNutritionFactsInput>
    create: XOR<FatCreateWithoutNutritionFactsInput, FatUncheckedCreateWithoutNutritionFactsInput>
  }

  export type FatUpdateWithoutNutritionFactsInput = {
    total?: TotalFatUpdateOneWithoutFatInput
    saturated?: SaturatedFatUpdateOneWithoutFatInput
    monounsaturated?: MonosaturatedFatUpdateOneWithoutFatInput
    polyunsaturated?: PolyunsaturatedFatUpdateOneWithoutFatInput
    trans?: TransFatUpdateOneWithoutFatInput
  }

  export type FatUncheckedUpdateWithoutNutritionFactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalFatId?: IntFieldUpdateOperationsInput | number
    saturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    monosaturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    polyunsaturatedFatId?: NullableIntFieldUpdateOperationsInput | number | null
    transFatId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CarbohydrateUpsertWithoutNutritionFactsInput = {
    update: XOR<CarbohydrateUpdateWithoutNutritionFactsInput, CarbohydrateUncheckedUpdateWithoutNutritionFactsInput>
    create: XOR<CarbohydrateCreateWithoutNutritionFactsInput, CarbohydrateUncheckedCreateWithoutNutritionFactsInput>
  }

  export type CarbohydrateUpdateWithoutNutritionFactsInput = {
    total?: TotalCarbohydrateUpdateOneWithoutCarbohydrateInput
    sugar?: SugarCarbohydrateUpdateOneWithoutCarbohydrateInput
  }

  export type CarbohydrateUncheckedUpdateWithoutNutritionFactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    totalCarbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    sugarCarbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FiberUpsertWithoutNutritionFactInput = {
    update: XOR<FiberUpdateWithoutNutritionFactInput, FiberUncheckedUpdateWithoutNutritionFactInput>
    create: XOR<FiberCreateWithoutNutritionFactInput, FiberUncheckedCreateWithoutNutritionFactInput>
  }

  export type FiberUpdateWithoutNutritionFactInput = {
    measurements?: MeasurementUpdateManyWithoutCiberInput
  }

  export type FiberUncheckedUpdateWithoutNutritionFactInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurements?: MeasurementUncheckedUpdateManyWithoutCiberInput
  }

  export type WaterUpsertWithoutNutritionFactInput = {
    update: XOR<WaterUpdateWithoutNutritionFactInput, WaterUncheckedUpdateWithoutNutritionFactInput>
    create: XOR<WaterCreateWithoutNutritionFactInput, WaterUncheckedCreateWithoutNutritionFactInput>
  }

  export type WaterUpdateWithoutNutritionFactInput = {
    measurements?: MeasurementUpdateManyWithoutCaterInput
  }

  export type WaterUncheckedUpdateWithoutNutritionFactInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurements?: MeasurementUncheckedUpdateManyWithoutCaterInput
  }

  export type VitaminUpsertWithoutNutritionFactsInput = {
    update: XOR<VitaminUpdateWithoutNutritionFactsInput, VitaminUncheckedUpdateWithoutNutritionFactsInput>
    create: XOR<VitaminCreateWithoutNutritionFactsInput, VitaminUncheckedCreateWithoutNutritionFactsInput>
  }

  export type VitaminUpdateWithoutNutritionFactsInput = {
    C?: VitaminCUpdateOneWithoutVitaminInput
    A?: VitaminAUpdateOneWithoutVitaminInput
    D?: VitaminDUpdateOneWithoutVitaminInput
    E?: VitaminEUpdateOneWithoutVitaminInput
    B1?: VitaminB1UpdateOneWithoutVitaminInput
    B2?: VitaminB2UpdateOneWithoutVitaminInput
    B6?: VitaminB6UpdateOneWithoutVitaminInput
    B12?: VitaminB12UpdateOneWithoutVitaminInput
    measurements?: MeasurementUpdateManyWithoutVitaminInput
  }

  export type VitaminUncheckedUpdateWithoutNutritionFactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitaminCId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminAId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminDId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminEId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB1Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB2Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB6Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB12Id?: NullableIntFieldUpdateOperationsInput | number | null
    measurements?: MeasurementUncheckedUpdateManyWithoutVitaminInput
  }

  export type MineralUpsertWithoutNutritionFactInput = {
    update: XOR<MineralUpdateWithoutNutritionFactInput, MineralUncheckedUpdateWithoutNutritionFactInput>
    create: XOR<MineralCreateWithoutNutritionFactInput, MineralUncheckedCreateWithoutNutritionFactInput>
  }

  export type MineralUpdateWithoutNutritionFactInput = {
    salt?: SaltUpdateOneWithoutMineralsInput
    iron?: IronUpdateOneWithoutMineralsInput
    zinc?: ZincUpdateOneWithoutMineralsInput
    magnesium?: MagnesiumUpdateOneWithoutMineralsInput
    chloride?: ChlorideUpdateOneWithoutMineralsInput
    manganese?: ManganeseUpdateOneWithoutMineralsInput
    sulfur?: SulfurUpdateOneWithoutMineralsInput
    potassium?: PotassiumUpdateOneWithoutMineralsInput
    fluoride?: FluorideUpdateOneWithoutMineralsInput
    phosphorous?: PhosphorousUpdateOneWithoutMineralsInput
    copper?: CopperUpdateOneWithoutMineralsInput
    iodine?: IodineUpdateOneWithoutMineralsInput
    calcium?: CalciumUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateWithoutNutritionFactInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type CholesterolUpsertWithoutNutritionFactInput = {
    update: XOR<CholesterolUpdateWithoutNutritionFactInput, CholesterolUncheckedUpdateWithoutNutritionFactInput>
    create: XOR<CholesterolCreateWithoutNutritionFactInput, CholesterolUncheckedCreateWithoutNutritionFactInput>
  }

  export type CholesterolUpdateWithoutNutritionFactInput = {
    measurements?: MeasurementUpdateManyWithoutCholesterolInput
  }

  export type CholesterolUncheckedUpdateWithoutNutritionFactInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurements?: MeasurementUncheckedUpdateManyWithoutCholesterolInput
  }

  export type ProductUpsertWithoutNutritionFactInput = {
    update: XOR<ProductUpdateWithoutNutritionFactInput, ProductUncheckedUpdateWithoutNutritionFactInput>
    create: XOR<ProductCreateWithoutNutritionFactInput, ProductUncheckedCreateWithoutNutritionFactInput>
  }

  export type ProductUpdateWithoutNutritionFactInput = {
    name?: StringFieldUpdateOperationsInput | string
    labels?: LabelUpdateManyWithoutProductsInput
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    serving?: ServingUpdateOneRequiredWithoutProductsInput
    nutritionFactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductUncheckedUpdateWithoutNutritionFactInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    labels?: LabelUncheckedUpdateManyWithoutProductsInput
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    servingId?: IntFieldUpdateOperationsInput | number
    nutritionFactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type LabelCreateWithoutProductsInput = {
    name: string
  }

  export type LabelUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
  }

  export type LabelCreateOrConnectWithoutProductsInput = {
    where: LabelWhereUniqueInput
    create: XOR<LabelCreateWithoutProductsInput, LabelUncheckedCreateWithoutProductsInput>
  }

  export type ServingCreateWithoutProductsInput = {
    name: string
    measurement: MeasurementCreateNestedOneWithoutServingsInput
  }

  export type ServingUncheckedCreateWithoutProductsInput = {
    id?: number
    name: string
    measurementId: number
  }

  export type ServingCreateOrConnectWithoutProductsInput = {
    where: ServingWhereUniqueInput
    create: XOR<ServingCreateWithoutProductsInput, ServingUncheckedCreateWithoutProductsInput>
  }

  export type NutritionFactCreateWithoutProductInput = {
    energy?: EnergyCreateNestedManyWithoutNutritionFactInput
    protein?: ProteinCreateNestedOneWithoutNutritionFactInput
    fats?: FatCreateNestedOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateCreateNestedOneWithoutNutritionFactsInput
    fiber?: FiberCreateNestedOneWithoutNutritionFactInput
    water?: WaterCreateNestedOneWithoutNutritionFactInput
    vitamins?: VitaminCreateNestedOneWithoutNutritionFactsInput
    minerals?: MineralCreateNestedOneWithoutNutritionFactInput
    cholesterol?: CholesterolCreateNestedOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedCreateWithoutProductInput = {
    id?: number
    energy?: EnergyUncheckedCreateNestedManyWithoutNutritionFactInput
    proteinId?: number | null
    fatId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
  }

  export type NutritionFactCreateOrConnectWithoutProductInput = {
    where: NutritionFactWhereUniqueInput
    create: XOR<NutritionFactCreateWithoutProductInput, NutritionFactUncheckedCreateWithoutProductInput>
  }

  export type LabelUpsertWithWhereUniqueWithoutProductsInput = {
    where: LabelWhereUniqueInput
    update: XOR<LabelUpdateWithoutProductsInput, LabelUncheckedUpdateWithoutProductsInput>
    create: XOR<LabelCreateWithoutProductsInput, LabelUncheckedCreateWithoutProductsInput>
  }

  export type LabelUpdateWithWhereUniqueWithoutProductsInput = {
    where: LabelWhereUniqueInput
    data: XOR<LabelUpdateWithoutProductsInput, LabelUncheckedUpdateWithoutProductsInput>
  }

  export type LabelUpdateManyWithWhereWithoutProductsInput = {
    where: LabelScalarWhereInput
    data: XOR<LabelUpdateManyMutationInput, LabelUncheckedUpdateManyWithoutLabelsInput>
  }

  export type LabelScalarWhereInput = {
    AND?: Enumerable<LabelScalarWhereInput>
    OR?: Enumerable<LabelScalarWhereInput>
    NOT?: Enumerable<LabelScalarWhereInput>
    id?: IntFilter | number
    name?: StringFilter | string
  }

  export type ServingUpsertWithoutProductsInput = {
    update: XOR<ServingUpdateWithoutProductsInput, ServingUncheckedUpdateWithoutProductsInput>
    create: XOR<ServingCreateWithoutProductsInput, ServingUncheckedCreateWithoutProductsInput>
  }

  export type ServingUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
    measurement?: MeasurementUpdateOneRequiredWithoutServingsInput
  }

  export type ServingUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    measurementId?: IntFieldUpdateOperationsInput | number
  }

  export type NutritionFactUpsertWithoutProductInput = {
    update: XOR<NutritionFactUpdateWithoutProductInput, NutritionFactUncheckedUpdateWithoutProductInput>
    create: XOR<NutritionFactCreateWithoutProductInput, NutritionFactUncheckedCreateWithoutProductInput>
  }

  export type NutritionFactUpdateWithoutProductInput = {
    energy?: EnergyUpdateManyWithoutNutritionFactInput
    protein?: ProteinUpdateOneWithoutNutritionFactInput
    fats?: FatUpdateOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateUpdateOneWithoutNutritionFactsInput
    fiber?: FiberUpdateOneWithoutNutritionFactInput
    water?: WaterUpdateOneWithoutNutritionFactInput
    vitamins?: VitaminUpdateOneWithoutNutritionFactsInput
    minerals?: MineralUpdateOneWithoutNutritionFactInput
    cholesterol?: CholesterolUpdateOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedUpdateWithoutProductInput = {
    id?: IntFieldUpdateOperationsInput | number
    energy?: EnergyUncheckedUpdateManyWithoutNutritionFactInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    fatId?: NullableIntFieldUpdateOperationsInput | number | null
    carbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminId?: NullableIntFieldUpdateOperationsInput | number | null
    mineralId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductUpdateWithoutLabelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    serving?: ServingUpdateOneRequiredWithoutProductsInput
    nutritionFact?: NutritionFactUpdateOneWithoutProductInput
    nutritionFactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductUncheckedUpdateWithoutLabelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    servingId?: IntFieldUpdateOperationsInput | number
    nutritionFact?: NutritionFactUncheckedUpdateOneWithoutProductInput
    nutritionFactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductUncheckedUpdateManyWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    servingId?: IntFieldUpdateOperationsInput | number
    nutritionFactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NutritionFactCreateManyFatsInput = {
    id?: number
    proteinId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type NutritionFactUpdateWithoutFatsInput = {
    energy?: EnergyUpdateManyWithoutNutritionFactInput
    protein?: ProteinUpdateOneWithoutNutritionFactInput
    carbohydrate?: CarbohydrateUpdateOneWithoutNutritionFactsInput
    fiber?: FiberUpdateOneWithoutNutritionFactInput
    water?: WaterUpdateOneWithoutNutritionFactInput
    vitamins?: VitaminUpdateOneWithoutNutritionFactsInput
    minerals?: MineralUpdateOneWithoutNutritionFactInput
    cholesterol?: CholesterolUpdateOneWithoutNutritionFactInput
    product?: ProductUpdateOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedUpdateWithoutFatsInput = {
    id?: IntFieldUpdateOperationsInput | number
    energy?: EnergyUncheckedUpdateManyWithoutNutritionFactInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    carbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminId?: NullableIntFieldUpdateOperationsInput | number | null
    mineralId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NutritionFactUncheckedUpdateManyWithoutNutritionFactsInput = {
    id?: IntFieldUpdateOperationsInput | number
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    carbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminId?: NullableIntFieldUpdateOperationsInput | number | null
    mineralId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NutritionFactCreateManyCarbohydrateInput = {
    id?: number
    proteinId?: number | null
    fatId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type NutritionFactUpdateWithoutCarbohydrateInput = {
    energy?: EnergyUpdateManyWithoutNutritionFactInput
    protein?: ProteinUpdateOneWithoutNutritionFactInput
    fats?: FatUpdateOneWithoutNutritionFactsInput
    fiber?: FiberUpdateOneWithoutNutritionFactInput
    water?: WaterUpdateOneWithoutNutritionFactInput
    vitamins?: VitaminUpdateOneWithoutNutritionFactsInput
    minerals?: MineralUpdateOneWithoutNutritionFactInput
    cholesterol?: CholesterolUpdateOneWithoutNutritionFactInput
    product?: ProductUpdateOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedUpdateWithoutCarbohydrateInput = {
    id?: IntFieldUpdateOperationsInput | number
    energy?: EnergyUncheckedUpdateManyWithoutNutritionFactInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    fatId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminId?: NullableIntFieldUpdateOperationsInput | number | null
    mineralId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NutritionFactCreateManyVitaminsInput = {
    id?: number
    proteinId?: number | null
    fatId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type NutritionFactUpdateWithoutVitaminsInput = {
    energy?: EnergyUpdateManyWithoutNutritionFactInput
    protein?: ProteinUpdateOneWithoutNutritionFactInput
    fats?: FatUpdateOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateUpdateOneWithoutNutritionFactsInput
    fiber?: FiberUpdateOneWithoutNutritionFactInput
    water?: WaterUpdateOneWithoutNutritionFactInput
    minerals?: MineralUpdateOneWithoutNutritionFactInput
    cholesterol?: CholesterolUpdateOneWithoutNutritionFactInput
    product?: ProductUpdateOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedUpdateWithoutVitaminsInput = {
    id?: IntFieldUpdateOperationsInput | number
    energy?: EnergyUncheckedUpdateManyWithoutNutritionFactInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    fatId?: NullableIntFieldUpdateOperationsInput | number | null
    carbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    mineralId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasurementUpdateWithoutVitaminInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutVitaminInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasurementUncheckedUpdateManyWithoutMeasurementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateManySaltInput = {
    id?: number
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralUpdateWithoutSaltInput = {
    nutritionFact?: NutritionFactUpdateManyWithoutMineralsInput
    iron?: IronUpdateOneWithoutMineralsInput
    zinc?: ZincUpdateOneWithoutMineralsInput
    magnesium?: MagnesiumUpdateOneWithoutMineralsInput
    chloride?: ChlorideUpdateOneWithoutMineralsInput
    manganese?: ManganeseUpdateOneWithoutMineralsInput
    sulfur?: SulfurUpdateOneWithoutMineralsInput
    potassium?: PotassiumUpdateOneWithoutMineralsInput
    fluoride?: FluorideUpdateOneWithoutMineralsInput
    phosphorous?: PhosphorousUpdateOneWithoutMineralsInput
    copper?: CopperUpdateOneWithoutMineralsInput
    iodine?: IodineUpdateOneWithoutMineralsInput
    calcium?: CalciumUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateWithoutSaltInput = {
    id?: IntFieldUpdateOperationsInput | number
    nutritionFact?: NutritionFactUncheckedUpdateManyWithoutMineralsInput
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralUncheckedUpdateManyWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateManyZincInput = {
    id?: number
    saltId?: number | null
    ironId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralUpdateWithoutZincInput = {
    salt?: SaltUpdateOneWithoutMineralsInput
    nutritionFact?: NutritionFactUpdateManyWithoutMineralsInput
    iron?: IronUpdateOneWithoutMineralsInput
    magnesium?: MagnesiumUpdateOneWithoutMineralsInput
    chloride?: ChlorideUpdateOneWithoutMineralsInput
    manganese?: ManganeseUpdateOneWithoutMineralsInput
    sulfur?: SulfurUpdateOneWithoutMineralsInput
    potassium?: PotassiumUpdateOneWithoutMineralsInput
    fluoride?: FluorideUpdateOneWithoutMineralsInput
    phosphorous?: PhosphorousUpdateOneWithoutMineralsInput
    copper?: CopperUpdateOneWithoutMineralsInput
    iodine?: IodineUpdateOneWithoutMineralsInput
    calcium?: CalciumUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateWithoutZincInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFact?: NutritionFactUncheckedUpdateManyWithoutMineralsInput
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateManyIronInput = {
    id?: number
    saltId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralUpdateWithoutIronInput = {
    salt?: SaltUpdateOneWithoutMineralsInput
    nutritionFact?: NutritionFactUpdateManyWithoutMineralsInput
    zinc?: ZincUpdateOneWithoutMineralsInput
    magnesium?: MagnesiumUpdateOneWithoutMineralsInput
    chloride?: ChlorideUpdateOneWithoutMineralsInput
    manganese?: ManganeseUpdateOneWithoutMineralsInput
    sulfur?: SulfurUpdateOneWithoutMineralsInput
    potassium?: PotassiumUpdateOneWithoutMineralsInput
    fluoride?: FluorideUpdateOneWithoutMineralsInput
    phosphorous?: PhosphorousUpdateOneWithoutMineralsInput
    copper?: CopperUpdateOneWithoutMineralsInput
    iodine?: IodineUpdateOneWithoutMineralsInput
    calcium?: CalciumUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateWithoutIronInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFact?: NutritionFactUncheckedUpdateManyWithoutMineralsInput
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateManyMagnesiumInput = {
    id?: number
    saltId?: number | null
    ironId?: number | null
    zincId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralUpdateWithoutMagnesiumInput = {
    salt?: SaltUpdateOneWithoutMineralsInput
    nutritionFact?: NutritionFactUpdateManyWithoutMineralsInput
    iron?: IronUpdateOneWithoutMineralsInput
    zinc?: ZincUpdateOneWithoutMineralsInput
    chloride?: ChlorideUpdateOneWithoutMineralsInput
    manganese?: ManganeseUpdateOneWithoutMineralsInput
    sulfur?: SulfurUpdateOneWithoutMineralsInput
    potassium?: PotassiumUpdateOneWithoutMineralsInput
    fluoride?: FluorideUpdateOneWithoutMineralsInput
    phosphorous?: PhosphorousUpdateOneWithoutMineralsInput
    copper?: CopperUpdateOneWithoutMineralsInput
    iodine?: IodineUpdateOneWithoutMineralsInput
    calcium?: CalciumUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateWithoutMagnesiumInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFact?: NutritionFactUncheckedUpdateManyWithoutMineralsInput
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateManyChlorideInput = {
    id?: number
    saltId?: number | null
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralUpdateWithoutChlorideInput = {
    salt?: SaltUpdateOneWithoutMineralsInput
    nutritionFact?: NutritionFactUpdateManyWithoutMineralsInput
    iron?: IronUpdateOneWithoutMineralsInput
    zinc?: ZincUpdateOneWithoutMineralsInput
    magnesium?: MagnesiumUpdateOneWithoutMineralsInput
    manganese?: ManganeseUpdateOneWithoutMineralsInput
    sulfur?: SulfurUpdateOneWithoutMineralsInput
    potassium?: PotassiumUpdateOneWithoutMineralsInput
    fluoride?: FluorideUpdateOneWithoutMineralsInput
    phosphorous?: PhosphorousUpdateOneWithoutMineralsInput
    copper?: CopperUpdateOneWithoutMineralsInput
    iodine?: IodineUpdateOneWithoutMineralsInput
    calcium?: CalciumUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateWithoutChlorideInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFact?: NutritionFactUncheckedUpdateManyWithoutMineralsInput
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateManyManganeseInput = {
    id?: number
    saltId?: number | null
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralUpdateWithoutManganeseInput = {
    salt?: SaltUpdateOneWithoutMineralsInput
    nutritionFact?: NutritionFactUpdateManyWithoutMineralsInput
    iron?: IronUpdateOneWithoutMineralsInput
    zinc?: ZincUpdateOneWithoutMineralsInput
    magnesium?: MagnesiumUpdateOneWithoutMineralsInput
    chloride?: ChlorideUpdateOneWithoutMineralsInput
    sulfur?: SulfurUpdateOneWithoutMineralsInput
    potassium?: PotassiumUpdateOneWithoutMineralsInput
    fluoride?: FluorideUpdateOneWithoutMineralsInput
    phosphorous?: PhosphorousUpdateOneWithoutMineralsInput
    copper?: CopperUpdateOneWithoutMineralsInput
    iodine?: IodineUpdateOneWithoutMineralsInput
    calcium?: CalciumUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateWithoutManganeseInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFact?: NutritionFactUncheckedUpdateManyWithoutMineralsInput
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateManySulfurInput = {
    id?: number
    saltId?: number | null
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralUpdateWithoutSulfurInput = {
    salt?: SaltUpdateOneWithoutMineralsInput
    nutritionFact?: NutritionFactUpdateManyWithoutMineralsInput
    iron?: IronUpdateOneWithoutMineralsInput
    zinc?: ZincUpdateOneWithoutMineralsInput
    magnesium?: MagnesiumUpdateOneWithoutMineralsInput
    chloride?: ChlorideUpdateOneWithoutMineralsInput
    manganese?: ManganeseUpdateOneWithoutMineralsInput
    potassium?: PotassiumUpdateOneWithoutMineralsInput
    fluoride?: FluorideUpdateOneWithoutMineralsInput
    phosphorous?: PhosphorousUpdateOneWithoutMineralsInput
    copper?: CopperUpdateOneWithoutMineralsInput
    iodine?: IodineUpdateOneWithoutMineralsInput
    calcium?: CalciumUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateWithoutSulfurInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFact?: NutritionFactUncheckedUpdateManyWithoutMineralsInput
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateManyPotassiumInput = {
    id?: number
    saltId?: number | null
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralUpdateWithoutPotassiumInput = {
    salt?: SaltUpdateOneWithoutMineralsInput
    nutritionFact?: NutritionFactUpdateManyWithoutMineralsInput
    iron?: IronUpdateOneWithoutMineralsInput
    zinc?: ZincUpdateOneWithoutMineralsInput
    magnesium?: MagnesiumUpdateOneWithoutMineralsInput
    chloride?: ChlorideUpdateOneWithoutMineralsInput
    manganese?: ManganeseUpdateOneWithoutMineralsInput
    sulfur?: SulfurUpdateOneWithoutMineralsInput
    fluoride?: FluorideUpdateOneWithoutMineralsInput
    phosphorous?: PhosphorousUpdateOneWithoutMineralsInput
    copper?: CopperUpdateOneWithoutMineralsInput
    iodine?: IodineUpdateOneWithoutMineralsInput
    calcium?: CalciumUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateWithoutPotassiumInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFact?: NutritionFactUncheckedUpdateManyWithoutMineralsInput
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateManyFluorideInput = {
    id?: number
    saltId?: number | null
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralUpdateWithoutFluorideInput = {
    salt?: SaltUpdateOneWithoutMineralsInput
    nutritionFact?: NutritionFactUpdateManyWithoutMineralsInput
    iron?: IronUpdateOneWithoutMineralsInput
    zinc?: ZincUpdateOneWithoutMineralsInput
    magnesium?: MagnesiumUpdateOneWithoutMineralsInput
    chloride?: ChlorideUpdateOneWithoutMineralsInput
    manganese?: ManganeseUpdateOneWithoutMineralsInput
    sulfur?: SulfurUpdateOneWithoutMineralsInput
    potassium?: PotassiumUpdateOneWithoutMineralsInput
    phosphorous?: PhosphorousUpdateOneWithoutMineralsInput
    copper?: CopperUpdateOneWithoutMineralsInput
    iodine?: IodineUpdateOneWithoutMineralsInput
    calcium?: CalciumUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateWithoutFluorideInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFact?: NutritionFactUncheckedUpdateManyWithoutMineralsInput
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateManyPhosphorousInput = {
    id?: number
    saltId?: number | null
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    copperId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralUpdateWithoutPhosphorousInput = {
    salt?: SaltUpdateOneWithoutMineralsInput
    nutritionFact?: NutritionFactUpdateManyWithoutMineralsInput
    iron?: IronUpdateOneWithoutMineralsInput
    zinc?: ZincUpdateOneWithoutMineralsInput
    magnesium?: MagnesiumUpdateOneWithoutMineralsInput
    chloride?: ChlorideUpdateOneWithoutMineralsInput
    manganese?: ManganeseUpdateOneWithoutMineralsInput
    sulfur?: SulfurUpdateOneWithoutMineralsInput
    potassium?: PotassiumUpdateOneWithoutMineralsInput
    fluoride?: FluorideUpdateOneWithoutMineralsInput
    copper?: CopperUpdateOneWithoutMineralsInput
    iodine?: IodineUpdateOneWithoutMineralsInput
    calcium?: CalciumUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateWithoutPhosphorousInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFact?: NutritionFactUncheckedUpdateManyWithoutMineralsInput
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateManyCopperInput = {
    id?: number
    saltId?: number | null
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    iodineId?: number | null
    calciumId?: number | null
  }

  export type MineralUpdateWithoutCopperInput = {
    salt?: SaltUpdateOneWithoutMineralsInput
    nutritionFact?: NutritionFactUpdateManyWithoutMineralsInput
    iron?: IronUpdateOneWithoutMineralsInput
    zinc?: ZincUpdateOneWithoutMineralsInput
    magnesium?: MagnesiumUpdateOneWithoutMineralsInput
    chloride?: ChlorideUpdateOneWithoutMineralsInput
    manganese?: ManganeseUpdateOneWithoutMineralsInput
    sulfur?: SulfurUpdateOneWithoutMineralsInput
    potassium?: PotassiumUpdateOneWithoutMineralsInput
    fluoride?: FluorideUpdateOneWithoutMineralsInput
    phosphorous?: PhosphorousUpdateOneWithoutMineralsInput
    iodine?: IodineUpdateOneWithoutMineralsInput
    calcium?: CalciumUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateWithoutCopperInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFact?: NutritionFactUncheckedUpdateManyWithoutMineralsInput
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateManyIodineInput = {
    id?: number
    saltId?: number | null
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    calciumId?: number | null
  }

  export type MineralUpdateWithoutIodineInput = {
    salt?: SaltUpdateOneWithoutMineralsInput
    nutritionFact?: NutritionFactUpdateManyWithoutMineralsInput
    iron?: IronUpdateOneWithoutMineralsInput
    zinc?: ZincUpdateOneWithoutMineralsInput
    magnesium?: MagnesiumUpdateOneWithoutMineralsInput
    chloride?: ChlorideUpdateOneWithoutMineralsInput
    manganese?: ManganeseUpdateOneWithoutMineralsInput
    sulfur?: SulfurUpdateOneWithoutMineralsInput
    potassium?: PotassiumUpdateOneWithoutMineralsInput
    fluoride?: FluorideUpdateOneWithoutMineralsInput
    phosphorous?: PhosphorousUpdateOneWithoutMineralsInput
    copper?: CopperUpdateOneWithoutMineralsInput
    calcium?: CalciumUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateWithoutIodineInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFact?: NutritionFactUncheckedUpdateManyWithoutMineralsInput
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    calciumId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MineralCreateManyCalciumInput = {
    id?: number
    saltId?: number | null
    ironId?: number | null
    zincId?: number | null
    magnesiumId?: number | null
    chlorideId?: number | null
    manganeseId?: number | null
    sulfurId?: number | null
    potassiumId?: number | null
    fluorideId?: number | null
    phosphorousId?: number | null
    copperId?: number | null
    iodineId?: number | null
  }

  export type MineralUpdateWithoutCalciumInput = {
    salt?: SaltUpdateOneWithoutMineralsInput
    nutritionFact?: NutritionFactUpdateManyWithoutMineralsInput
    iron?: IronUpdateOneWithoutMineralsInput
    zinc?: ZincUpdateOneWithoutMineralsInput
    magnesium?: MagnesiumUpdateOneWithoutMineralsInput
    chloride?: ChlorideUpdateOneWithoutMineralsInput
    manganese?: ManganeseUpdateOneWithoutMineralsInput
    sulfur?: SulfurUpdateOneWithoutMineralsInput
    potassium?: PotassiumUpdateOneWithoutMineralsInput
    fluoride?: FluorideUpdateOneWithoutMineralsInput
    phosphorous?: PhosphorousUpdateOneWithoutMineralsInput
    copper?: CopperUpdateOneWithoutMineralsInput
    iodine?: IodineUpdateOneWithoutMineralsInput
  }

  export type MineralUncheckedUpdateWithoutCalciumInput = {
    id?: IntFieldUpdateOperationsInput | number
    saltId?: NullableIntFieldUpdateOperationsInput | number | null
    nutritionFact?: NutritionFactUncheckedUpdateManyWithoutMineralsInput
    ironId?: NullableIntFieldUpdateOperationsInput | number | null
    zincId?: NullableIntFieldUpdateOperationsInput | number | null
    magnesiumId?: NullableIntFieldUpdateOperationsInput | number | null
    chlorideId?: NullableIntFieldUpdateOperationsInput | number | null
    manganeseId?: NullableIntFieldUpdateOperationsInput | number | null
    sulfurId?: NullableIntFieldUpdateOperationsInput | number | null
    potassiumId?: NullableIntFieldUpdateOperationsInput | number | null
    fluorideId?: NullableIntFieldUpdateOperationsInput | number | null
    phosphorousId?: NullableIntFieldUpdateOperationsInput | number | null
    copperId?: NullableIntFieldUpdateOperationsInput | number | null
    iodineId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NutritionFactCreateManyMineralsInput = {
    id?: number
    proteinId?: number | null
    fatId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type NutritionFactUpdateWithoutMineralsInput = {
    energy?: EnergyUpdateManyWithoutNutritionFactInput
    protein?: ProteinUpdateOneWithoutNutritionFactInput
    fats?: FatUpdateOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateUpdateOneWithoutNutritionFactsInput
    fiber?: FiberUpdateOneWithoutNutritionFactInput
    water?: WaterUpdateOneWithoutNutritionFactInput
    vitamins?: VitaminUpdateOneWithoutNutritionFactsInput
    cholesterol?: CholesterolUpdateOneWithoutNutritionFactInput
    product?: ProductUpdateOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedUpdateWithoutMineralsInput = {
    id?: IntFieldUpdateOperationsInput | number
    energy?: EnergyUncheckedUpdateManyWithoutNutritionFactInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    fatId?: NullableIntFieldUpdateOperationsInput | number | null
    carbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NutritionFactUncheckedUpdateManyWithoutNutritionFactInput = {
    id?: IntFieldUpdateOperationsInput | number
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    fatId?: NullableIntFieldUpdateOperationsInput | number | null
    carbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasurementCreateManyUnitInput = {
    id?: number
    value?: Decimal | number | string | null
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type MeasurementUpdateWithoutUnitInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutUnitInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServingCreateManyMeasurementInput = {
    id?: number
    name: string
  }

  export type SaltCreateManyMeasurementInput = {
    id?: number
  }

  export type ZincCreateManyMeasurementInput = {
    id?: number
  }

  export type IronCreateManyMeasurementInput = {
    id?: number
  }

  export type MagnesiumCreateManyMeasurementInput = {
    id?: number
  }

  export type ChlorideCreateManyMeasurementInput = {
    id?: number
  }

  export type ManganeseCreateManyMeasurementInput = {
    id?: number
  }

  export type SulfurCreateManyMeasurementInput = {
    id?: number
  }

  export type PotassiumCreateManyMeasurementInput = {
    id?: number
  }

  export type FluorideCreateManyMeasurementInput = {
    id?: number
  }

  export type PhosphorousCreateManyMeasurementInput = {
    id?: number
  }

  export type CopperCreateManyMeasurementInput = {
    id?: number
  }

  export type IodineCreateManyMeasurementInput = {
    id?: number
  }

  export type CalciumCreateManyMeasurementInput = {
    id?: number
  }

  export type TotalFatCreateManyMeasurementInput = {
    id?: number
  }

  export type SaturatedFatCreateManyMeasurementInput = {
    id?: number
  }

  export type MonosaturatedFatCreateManyMeasurementInput = {
    id?: number
  }

  export type PolyunsaturatedFatCreateManyMeasurementInput = {
    id?: number
  }

  export type TransFatCreateManyMeasurementInput = {
    id?: number
  }

  export type TotalCarbohydrateCreateManyMeasurementInput = {
    id?: number
  }

  export type SugarCarbohydrateCreateManyMeasurementInput = {
    id?: number
  }

  export type VitaminCCreateManyMeasurementInput = {
    id?: number
  }

  export type VitaminACreateManyMeasurementInput = {
    id?: number
  }

  export type VitaminDCreateManyMeasurementInput = {
    id?: number
  }

  export type VitaminECreateManyMeasurementInput = {
    id?: number
  }

  export type VitaminB1CreateManyMeasurementInput = {
    id?: number
  }

  export type VitaminB2CreateManyMeasurementInput = {
    id?: number
  }

  export type VitaminB6CreateManyMeasurementInput = {
    id?: number
  }

  export type VitaminB12CreateManyMeasurementInput = {
    id?: number
  }

  export type ServingUpdateWithoutMeasurementInput = {
    name?: StringFieldUpdateOperationsInput | string
    products?: ProductUpdateManyWithoutServingInput
  }

  export type ServingUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    products?: ProductUncheckedUpdateManyWithoutServingInput
  }

  export type ServingUncheckedUpdateManyWithoutServingsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type VitaminUpdateWithoutMeasurementsInput = {
    C?: VitaminCUpdateOneWithoutVitaminInput
    A?: VitaminAUpdateOneWithoutVitaminInput
    D?: VitaminDUpdateOneWithoutVitaminInput
    E?: VitaminEUpdateOneWithoutVitaminInput
    B1?: VitaminB1UpdateOneWithoutVitaminInput
    B2?: VitaminB2UpdateOneWithoutVitaminInput
    B6?: VitaminB6UpdateOneWithoutVitaminInput
    B12?: VitaminB12UpdateOneWithoutVitaminInput
    nutritionFacts?: NutritionFactUpdateManyWithoutVitaminsInput
  }

  export type VitaminUncheckedUpdateWithoutMeasurementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nutritionFacts?: NutritionFactUncheckedUpdateManyWithoutVitaminsInput
    vitaminCId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminAId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminDId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminEId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB1Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB2Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB6Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB12Id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type VitaminUncheckedUpdateManyWithoutVitaminInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitaminCId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminAId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminDId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminEId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB1Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB2Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB6Id?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminB12Id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type SaltUpdateWithoutMeasurementInput = {
    minerals?: MineralUpdateManyWithoutSaltInput
  }

  export type SaltUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutSaltInput
  }

  export type SaltUncheckedUpdateManyWithoutSaltInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ZincUpdateWithoutMeasurementInput = {
    minerals?: MineralUpdateManyWithoutZincInput
  }

  export type ZincUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutZincInput
  }

  export type ZincUncheckedUpdateManyWithoutZincInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type IronUpdateWithoutMeasurementInput = {
    minerals?: MineralUpdateManyWithoutIronInput
  }

  export type IronUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutIronInput
  }

  export type IronUncheckedUpdateManyWithoutIronInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type MagnesiumUpdateWithoutMeasurementInput = {
    minerals?: MineralUpdateManyWithoutMagnesiumInput
  }

  export type MagnesiumUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutMagnesiumInput
  }

  export type MagnesiumUncheckedUpdateManyWithoutMagnesiumInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ChlorideUpdateWithoutMeasurementInput = {
    minerals?: MineralUpdateManyWithoutChlorideInput
  }

  export type ChlorideUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutChlorideInput
  }

  export type ChlorideUncheckedUpdateManyWithoutChlorideInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type ManganeseUpdateWithoutMeasurementInput = {
    minerals?: MineralUpdateManyWithoutManganeseInput
  }

  export type ManganeseUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutManganeseInput
  }

  export type ManganeseUncheckedUpdateManyWithoutManganeseInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type SulfurUpdateWithoutMeasurementInput = {
    minerals?: MineralUpdateManyWithoutSulfurInput
  }

  export type SulfurUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutSulfurInput
  }

  export type SulfurUncheckedUpdateManyWithoutSulfurInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PotassiumUpdateWithoutMeasurementInput = {
    minerals?: MineralUpdateManyWithoutPotassiumInput
  }

  export type PotassiumUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutPotassiumInput
  }

  export type PotassiumUncheckedUpdateManyWithoutPotassiumInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type FluorideUpdateWithoutMeasurementInput = {
    minerals?: MineralUpdateManyWithoutFluorideInput
  }

  export type FluorideUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutFluorideInput
  }

  export type FluorideUncheckedUpdateManyWithoutFluorideInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PhosphorousUpdateWithoutMeasurementInput = {
    minerals?: MineralUpdateManyWithoutPhosphorousInput
  }

  export type PhosphorousUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutPhosphorousInput
  }

  export type PhosphorousUncheckedUpdateManyWithoutPhosphorousInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type CopperUpdateWithoutMeasurementInput = {
    minerals?: MineralUpdateManyWithoutCopperInput
  }

  export type CopperUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutCopperInput
  }

  export type CopperUncheckedUpdateManyWithoutCopperInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type IodineUpdateWithoutMeasurementInput = {
    minerals?: MineralUpdateManyWithoutIodineInput
  }

  export type IodineUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutIodineInput
  }

  export type IodineUncheckedUpdateManyWithoutIodineInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type CalciumUpdateWithoutMeasurementInput = {
    minerals?: MineralUpdateManyWithoutCalciumInput
  }

  export type CalciumUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    minerals?: MineralUncheckedUpdateManyWithoutCalciumInput
  }

  export type CalciumUncheckedUpdateManyWithoutCalciumInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type TotalFatUpdateWithoutMeasurementInput = {
    fat?: FatUpdateOneWithoutTotalInput
  }

  export type TotalFatUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    fat?: FatUncheckedUpdateOneWithoutTotalInput
  }

  export type TotalFatUncheckedUpdateManyWithoutTotalFatInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type SaturatedFatUpdateWithoutMeasurementInput = {
    fat?: FatUpdateOneWithoutSaturatedInput
  }

  export type SaturatedFatUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    fat?: FatUncheckedUpdateOneWithoutSaturatedInput
  }

  export type SaturatedFatUncheckedUpdateManyWithoutSaturatedFatInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type MonosaturatedFatUpdateWithoutMeasurementInput = {
    fat?: FatUpdateOneWithoutMonounsaturatedInput
  }

  export type MonosaturatedFatUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    fat?: FatUncheckedUpdateOneWithoutMonounsaturatedInput
  }

  export type MonosaturatedFatUncheckedUpdateManyWithoutMonosaturatedFatInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type PolyunsaturatedFatUpdateWithoutMeasurementInput = {
    fat?: FatUpdateOneWithoutPolyunsaturatedInput
  }

  export type PolyunsaturatedFatUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    fat?: FatUncheckedUpdateOneWithoutPolyunsaturatedInput
  }

  export type PolyunsaturatedFatUncheckedUpdateManyWithoutPolyunsaturatedFatInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type TransFatUpdateWithoutMeasurementInput = {
    fat?: FatUpdateOneWithoutTransInput
  }

  export type TransFatUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    fat?: FatUncheckedUpdateOneWithoutTransInput
  }

  export type TransFatUncheckedUpdateManyWithoutTransFatInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type TotalCarbohydrateUpdateWithoutMeasurementInput = {
    carbohydrate?: CarbohydrateUpdateOneWithoutTotalInput
  }

  export type TotalCarbohydrateUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    carbohydrate?: CarbohydrateUncheckedUpdateOneWithoutTotalInput
  }

  export type TotalCarbohydrateUncheckedUpdateManyWithoutTotalCarbohydrateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type SugarCarbohydrateUpdateWithoutMeasurementInput = {
    carbohydrate?: CarbohydrateUpdateOneWithoutSugarInput
  }

  export type SugarCarbohydrateUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    carbohydrate?: CarbohydrateUncheckedUpdateOneWithoutSugarInput
  }

  export type SugarCarbohydrateUncheckedUpdateManyWithoutSugarCarbohydrateInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminCUpdateWithoutMeasurementInput = {
    vitamin?: VitaminUpdateOneWithoutCInput
  }

  export type VitaminCUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutCInput
  }

  export type VitaminCUncheckedUpdateManyWithoutVitaminCInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminAUpdateWithoutMeasurementInput = {
    vitamin?: VitaminUpdateOneWithoutAInput
  }

  export type VitaminAUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutAInput
  }

  export type VitaminAUncheckedUpdateManyWithoutVitaminAInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminDUpdateWithoutMeasurementInput = {
    vitamin?: VitaminUpdateOneWithoutDInput
  }

  export type VitaminDUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutDInput
  }

  export type VitaminDUncheckedUpdateManyWithoutVitaminDInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminEUpdateWithoutMeasurementInput = {
    vitamin?: VitaminUpdateOneWithoutEInput
  }

  export type VitaminEUncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutEInput
  }

  export type VitaminEUncheckedUpdateManyWithoutVitaminEInput = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB1UpdateWithoutMeasurementInput = {
    vitamin?: VitaminUpdateOneWithoutB1Input
  }

  export type VitaminB1UncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutB1Input
  }

  export type VitaminB1UncheckedUpdateManyWithoutVitaminB1Input = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB2UpdateWithoutMeasurementInput = {
    vitamin?: VitaminUpdateOneWithoutB2Input
  }

  export type VitaminB2UncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutB2Input
  }

  export type VitaminB2UncheckedUpdateManyWithoutVitaminB2Input = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB6UpdateWithoutMeasurementInput = {
    vitamin?: VitaminUpdateOneWithoutB6Input
  }

  export type VitaminB6UncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutB6Input
  }

  export type VitaminB6UncheckedUpdateManyWithoutVitaminB6Input = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type VitaminB12UpdateWithoutMeasurementInput = {
    vitamin?: VitaminUpdateOneWithoutB12Input
  }

  export type VitaminB12UncheckedUpdateWithoutMeasurementInput = {
    id?: IntFieldUpdateOperationsInput | number
    vitamin?: VitaminUncheckedUpdateOneWithoutB12Input
  }

  export type VitaminB12UncheckedUpdateManyWithoutVitaminB12Input = {
    id?: IntFieldUpdateOperationsInput | number
  }

  export type EnergyUpdateWithoutMeasurementsInput = {
    nutritionFact?: NutritionFactUpdateOneRequiredWithoutEnergyInput
  }

  export type EnergyUncheckedUpdateWithoutMeasurementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nutritionFactId?: IntFieldUpdateOperationsInput | number
  }

  export type EnergyUncheckedUpdateManyWithoutEnergyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nutritionFactId?: IntFieldUpdateOperationsInput | number
  }

  export type ProductCreateManyServingInput = {
    id?: number
    name: string
    ean?: string | null
    manufacturer: string
    group: string
    nutritionFactId?: number | null
  }

  export type ProductUpdateWithoutServingInput = {
    name?: StringFieldUpdateOperationsInput | string
    labels?: LabelUpdateManyWithoutProductsInput
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    nutritionFact?: NutritionFactUpdateOneWithoutProductInput
    nutritionFactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProductUncheckedUpdateWithoutServingInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    labels?: LabelUncheckedUpdateManyWithoutProductsInput
    ean?: NullableStringFieldUpdateOperationsInput | string | null
    manufacturer?: StringFieldUpdateOperationsInput | string
    group?: StringFieldUpdateOperationsInput | string
    nutritionFact?: NutritionFactUncheckedUpdateOneWithoutProductInput
    nutritionFactId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasurementUpdateWithoutEnergyInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutEnergyInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasurementCreateManyProteinInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    cholesterolId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type NutritionFactCreateManyProteinInput = {
    id?: number
    fatId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type MeasurementUpdateWithoutProteinInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutProteinInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NutritionFactUpdateWithoutProteinInput = {
    energy?: EnergyUpdateManyWithoutNutritionFactInput
    fats?: FatUpdateOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateUpdateOneWithoutNutritionFactsInput
    fiber?: FiberUpdateOneWithoutNutritionFactInput
    water?: WaterUpdateOneWithoutNutritionFactInput
    vitamins?: VitaminUpdateOneWithoutNutritionFactsInput
    minerals?: MineralUpdateOneWithoutNutritionFactInput
    cholesterol?: CholesterolUpdateOneWithoutNutritionFactInput
    product?: ProductUpdateOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedUpdateWithoutProteinInput = {
    id?: IntFieldUpdateOperationsInput | number
    energy?: EnergyUncheckedUpdateManyWithoutNutritionFactInput
    fatId?: NullableIntFieldUpdateOperationsInput | number | null
    carbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminId?: NullableIntFieldUpdateOperationsInput | number | null
    mineralId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasurementCreateManyCholesterolInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    proteinId?: number | null
    fiberId?: number | null
    waterId?: number | null
  }

  export type NutritionFactCreateManyCholesterolInput = {
    id?: number
    proteinId?: number | null
    fatId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type MeasurementUpdateWithoutCholesterolInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutCholesterolInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NutritionFactUpdateWithoutCholesterolInput = {
    energy?: EnergyUpdateManyWithoutNutritionFactInput
    protein?: ProteinUpdateOneWithoutNutritionFactInput
    fats?: FatUpdateOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateUpdateOneWithoutNutritionFactsInput
    fiber?: FiberUpdateOneWithoutNutritionFactInput
    water?: WaterUpdateOneWithoutNutritionFactInput
    vitamins?: VitaminUpdateOneWithoutNutritionFactsInput
    minerals?: MineralUpdateOneWithoutNutritionFactInput
    product?: ProductUpdateOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedUpdateWithoutCholesterolInput = {
    id?: IntFieldUpdateOperationsInput | number
    energy?: EnergyUncheckedUpdateManyWithoutNutritionFactInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    fatId?: NullableIntFieldUpdateOperationsInput | number | null
    carbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminId?: NullableIntFieldUpdateOperationsInput | number | null
    mineralId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasurementCreateManyCiberInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    proteinId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
  }

  export type NutritionFactCreateManyFiberInput = {
    id?: number
    proteinId?: number | null
    fatId?: number | null
    carbohydrateId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    waterId?: number | null
    productId?: number | null
  }

  export type MeasurementUpdateWithoutCiberInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    cater?: WaterUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutCiberInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NutritionFactUpdateWithoutFiberInput = {
    energy?: EnergyUpdateManyWithoutNutritionFactInput
    protein?: ProteinUpdateOneWithoutNutritionFactInput
    fats?: FatUpdateOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateUpdateOneWithoutNutritionFactsInput
    water?: WaterUpdateOneWithoutNutritionFactInput
    vitamins?: VitaminUpdateOneWithoutNutritionFactsInput
    minerals?: MineralUpdateOneWithoutNutritionFactInput
    cholesterol?: CholesterolUpdateOneWithoutNutritionFactInput
    product?: ProductUpdateOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedUpdateWithoutFiberInput = {
    id?: IntFieldUpdateOperationsInput | number
    energy?: EnergyUncheckedUpdateManyWithoutNutritionFactInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    fatId?: NullableIntFieldUpdateOperationsInput | number | null
    carbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminId?: NullableIntFieldUpdateOperationsInput | number | null
    mineralId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    waterId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type MeasurementCreateManyCaterInput = {
    id?: number
    value?: Decimal | number | string | null
    unitId: number
    proteinId?: number | null
    cholesterolId?: number | null
    fiberId?: number | null
  }

  export type NutritionFactCreateManyWaterInput = {
    id?: number
    proteinId?: number | null
    fatId?: number | null
    carbohydrateId?: number | null
    fiberId?: number | null
    vitaminId?: number | null
    mineralId?: number | null
    cholesterolId?: number | null
    productId?: number | null
  }

  export type MeasurementUpdateWithoutCaterInput = {
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unit?: UnitUpdateOneRequiredWithoutMeasurementsInput
    servings?: ServingUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUpdateManyWithoutMeasurementsInput
    salt?: SaltUpdateManyWithoutMeasurementInput
    zinc?: ZincUpdateManyWithoutMeasurementInput
    iron?: IronUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUpdateManyWithoutMeasurementInput
    copper?: CopperUpdateManyWithoutMeasurementInput
    iodine?: IodineUpdateManyWithoutMeasurementInput
    calcium?: CalciumUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUpdateManyWithoutMeasurementInput
    transFat?: TransFatUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UpdateManyWithoutMeasurementInput
    energy?: EnergyUpdateManyWithoutMeasurementsInput
    protein?: ProteinUpdateOneWithoutMeasurementsInput
    cholesterol?: CholesterolUpdateOneWithoutMeasurementsInput
    ciber?: FiberUpdateOneWithoutMeasurementsInput
  }

  export type MeasurementUncheckedUpdateWithoutCaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    value?: NullableDecimalFieldUpdateOperationsInput | Decimal | number | string | null
    unitId?: IntFieldUpdateOperationsInput | number
    servings?: ServingUncheckedUpdateManyWithoutMeasurementInput
    vitamin?: VitaminUncheckedUpdateManyWithoutMeasurementsInput
    salt?: SaltUncheckedUpdateManyWithoutMeasurementInput
    zinc?: ZincUncheckedUpdateManyWithoutMeasurementInput
    iron?: IronUncheckedUpdateManyWithoutMeasurementInput
    magnesium?: MagnesiumUncheckedUpdateManyWithoutMeasurementInput
    chloride?: ChlorideUncheckedUpdateManyWithoutMeasurementInput
    manganese?: ManganeseUncheckedUpdateManyWithoutMeasurementInput
    sulfur?: SulfurUncheckedUpdateManyWithoutMeasurementInput
    potassium?: PotassiumUncheckedUpdateManyWithoutMeasurementInput
    fluoride?: FluorideUncheckedUpdateManyWithoutMeasurementInput
    phosphorous?: PhosphorousUncheckedUpdateManyWithoutMeasurementInput
    copper?: CopperUncheckedUpdateManyWithoutMeasurementInput
    iodine?: IodineUncheckedUpdateManyWithoutMeasurementInput
    calcium?: CalciumUncheckedUpdateManyWithoutMeasurementInput
    totalFat?: TotalFatUncheckedUpdateManyWithoutMeasurementInput
    saturatedFat?: SaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    monosaturatedFat?: MonosaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    polyunsaturatedFat?: PolyunsaturatedFatUncheckedUpdateManyWithoutMeasurementInput
    transFat?: TransFatUncheckedUpdateManyWithoutMeasurementInput
    totalCarbohydrate?: TotalCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    sugarCarbohydrate?: SugarCarbohydrateUncheckedUpdateManyWithoutMeasurementInput
    vitaminC?: VitaminCUncheckedUpdateManyWithoutMeasurementInput
    vitaminA?: VitaminAUncheckedUpdateManyWithoutMeasurementInput
    vitaminD?: VitaminDUncheckedUpdateManyWithoutMeasurementInput
    vitaminE?: VitaminEUncheckedUpdateManyWithoutMeasurementInput
    vitaminB1?: VitaminB1UncheckedUpdateManyWithoutMeasurementInput
    vitaminB2?: VitaminB2UncheckedUpdateManyWithoutMeasurementInput
    vitaminB6?: VitaminB6UncheckedUpdateManyWithoutMeasurementInput
    vitaminB12?: VitaminB12UncheckedUpdateManyWithoutMeasurementInput
    energy?: EnergyUncheckedUpdateManyWithoutMeasurementsInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type NutritionFactUpdateWithoutWaterInput = {
    energy?: EnergyUpdateManyWithoutNutritionFactInput
    protein?: ProteinUpdateOneWithoutNutritionFactInput
    fats?: FatUpdateOneWithoutNutritionFactsInput
    carbohydrate?: CarbohydrateUpdateOneWithoutNutritionFactsInput
    fiber?: FiberUpdateOneWithoutNutritionFactInput
    vitamins?: VitaminUpdateOneWithoutNutritionFactsInput
    minerals?: MineralUpdateOneWithoutNutritionFactInput
    cholesterol?: CholesterolUpdateOneWithoutNutritionFactInput
    product?: ProductUpdateOneWithoutNutritionFactInput
  }

  export type NutritionFactUncheckedUpdateWithoutWaterInput = {
    id?: IntFieldUpdateOperationsInput | number
    energy?: EnergyUncheckedUpdateManyWithoutNutritionFactInput
    proteinId?: NullableIntFieldUpdateOperationsInput | number | null
    fatId?: NullableIntFieldUpdateOperationsInput | number | null
    carbohydrateId?: NullableIntFieldUpdateOperationsInput | number | null
    fiberId?: NullableIntFieldUpdateOperationsInput | number | null
    vitaminId?: NullableIntFieldUpdateOperationsInput | number | null
    mineralId?: NullableIntFieldUpdateOperationsInput | number | null
    cholesterolId?: NullableIntFieldUpdateOperationsInput | number | null
    productId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type EnergyCreateManyNutritionFactInput = {
    id?: number
  }

  export type EnergyUpdateWithoutNutritionFactInput = {
    measurements?: MeasurementUpdateManyWithoutEnergyInput
  }

  export type EnergyUncheckedUpdateWithoutNutritionFactInput = {
    id?: IntFieldUpdateOperationsInput | number
    measurements?: MeasurementUncheckedUpdateManyWithoutEnergyInput
  }

  export type LabelUpdateWithoutProductsInput = {
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LabelUncheckedUpdateWithoutProductsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }

  export type LabelUncheckedUpdateManyWithoutLabelsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.DMMF.Document;
}